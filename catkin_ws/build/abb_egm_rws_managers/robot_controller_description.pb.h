// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot_controller_description.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_robot_5fcontroller_5fdescription_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_robot_5fcontroller_5fdescription_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_robot_5fcontroller_5fdescription_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_robot_5fcontroller_5fdescription_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_robot_5fcontroller_5fdescription_2eproto;
namespace abb {
namespace robot {
class AddInIndicators;
struct AddInIndicatorsDefaultTypeInternal;
extern AddInIndicatorsDefaultTypeInternal _AddInIndicators_default_instance_;
class Arm;
struct ArmDefaultTypeInternal;
extern ArmDefaultTypeInternal _Arm_default_instance_;
class Cartesian;
struct CartesianDefaultTypeInternal;
extern CartesianDefaultTypeInternal _Cartesian_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Joint;
struct JointDefaultTypeInternal;
extern JointDefaultTypeInternal _Joint_default_instance_;
class MechanicalUnit;
struct MechanicalUnitDefaultTypeInternal;
extern MechanicalUnitDefaultTypeInternal _MechanicalUnit_default_instance_;
class MechanicalUnitGroup;
struct MechanicalUnitGroupDefaultTypeInternal;
extern MechanicalUnitGroupDefaultTypeInternal _MechanicalUnitGroup_default_instance_;
class OptionIndicators;
struct OptionIndicatorsDefaultTypeInternal;
extern OptionIndicatorsDefaultTypeInternal _OptionIndicators_default_instance_;
class Pose;
struct PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class RAPIDModule;
struct RAPIDModuleDefaultTypeInternal;
extern RAPIDModuleDefaultTypeInternal _RAPIDModule_default_instance_;
class RAPIDTask;
struct RAPIDTaskDefaultTypeInternal;
extern RAPIDTaskDefaultTypeInternal _RAPIDTask_default_instance_;
class Robot;
struct RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class RobotControllerDescription;
struct RobotControllerDescriptionDefaultTypeInternal;
extern RobotControllerDescriptionDefaultTypeInternal _RobotControllerDescription_default_instance_;
class RobotIndicators;
struct RobotIndicatorsDefaultTypeInternal;
extern RobotIndicatorsDefaultTypeInternal _RobotIndicators_default_instance_;
class RobotWareVersion;
struct RobotWareVersionDefaultTypeInternal;
extern RobotWareVersionDefaultTypeInternal _RobotWareVersion_default_instance_;
class Single;
struct SingleDefaultTypeInternal;
extern SingleDefaultTypeInternal _Single_default_instance_;
class StandardizedJoint;
struct StandardizedJointDefaultTypeInternal;
extern StandardizedJointDefaultTypeInternal _StandardizedJoint_default_instance_;
class SystemIndicators;
struct SystemIndicatorsDefaultTypeInternal;
extern SystemIndicatorsDefaultTypeInternal _SystemIndicators_default_instance_;
class Transmission;
struct TransmissionDefaultTypeInternal;
extern TransmissionDefaultTypeInternal _Transmission_default_instance_;
}  // namespace robot
}  // namespace abb
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace abb {
namespace robot {
enum MechanicalUnit_Type : int {
  MechanicalUnit_Type_UNDEFINED = 0,
  MechanicalUnit_Type_NONE = 1,
  MechanicalUnit_Type_TCP_ROBOT = 2,
  MechanicalUnit_Type_ROBOT = 3,
  MechanicalUnit_Type_SINGLE = 4,
};

bool MechanicalUnit_Type_IsValid(int value);
extern const uint32_t MechanicalUnit_Type_internal_data_[];
constexpr MechanicalUnit_Type MechanicalUnit_Type_Type_MIN = static_cast<MechanicalUnit_Type>(0);
constexpr MechanicalUnit_Type MechanicalUnit_Type_Type_MAX = static_cast<MechanicalUnit_Type>(4);
constexpr int MechanicalUnit_Type_Type_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
MechanicalUnit_Type_descriptor();
template <typename T>
const std::string& MechanicalUnit_Type_Name(T value) {
  static_assert(std::is_same<T, MechanicalUnit_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return MechanicalUnit_Type_Name(static_cast<MechanicalUnit_Type>(value));
}
template <>
inline const std::string& MechanicalUnit_Type_Name(MechanicalUnit_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MechanicalUnit_Type_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool MechanicalUnit_Type_Parse(absl::string_view name, MechanicalUnit_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MechanicalUnit_Type>(
      MechanicalUnit_Type_descriptor(), name, value);
}
enum MechanicalUnit_Mode : int {
  MechanicalUnit_Mode_DEACTIVATED = 0,
  MechanicalUnit_Mode_ACTIVATED = 1,
};

bool MechanicalUnit_Mode_IsValid(int value);
extern const uint32_t MechanicalUnit_Mode_internal_data_[];
constexpr MechanicalUnit_Mode MechanicalUnit_Mode_Mode_MIN = static_cast<MechanicalUnit_Mode>(0);
constexpr MechanicalUnit_Mode MechanicalUnit_Mode_Mode_MAX = static_cast<MechanicalUnit_Mode>(1);
constexpr int MechanicalUnit_Mode_Mode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
MechanicalUnit_Mode_descriptor();
template <typename T>
const std::string& MechanicalUnit_Mode_Name(T value) {
  static_assert(std::is_same<T, MechanicalUnit_Mode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Mode_Name().");
  return MechanicalUnit_Mode_Name(static_cast<MechanicalUnit_Mode>(value));
}
template <>
inline const std::string& MechanicalUnit_Mode_Name(MechanicalUnit_Mode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MechanicalUnit_Mode_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool MechanicalUnit_Mode_Parse(absl::string_view name, MechanicalUnit_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MechanicalUnit_Mode>(
      MechanicalUnit_Mode_descriptor(), name, value);
}
enum RAPIDTask_ExecutionState : int {
  RAPIDTask_ExecutionState_UNKNOWN = 1,
  RAPIDTask_ExecutionState_READY = 2,
  RAPIDTask_ExecutionState_STOPPED = 3,
  RAPIDTask_ExecutionState_STARTED = 4,
  RAPIDTask_ExecutionState_UNINITIALIZED = 5,
};

bool RAPIDTask_ExecutionState_IsValid(int value);
extern const uint32_t RAPIDTask_ExecutionState_internal_data_[];
constexpr RAPIDTask_ExecutionState RAPIDTask_ExecutionState_ExecutionState_MIN = static_cast<RAPIDTask_ExecutionState>(1);
constexpr RAPIDTask_ExecutionState RAPIDTask_ExecutionState_ExecutionState_MAX = static_cast<RAPIDTask_ExecutionState>(5);
constexpr int RAPIDTask_ExecutionState_ExecutionState_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
RAPIDTask_ExecutionState_descriptor();
template <typename T>
const std::string& RAPIDTask_ExecutionState_Name(T value) {
  static_assert(std::is_same<T, RAPIDTask_ExecutionState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ExecutionState_Name().");
  return RAPIDTask_ExecutionState_Name(static_cast<RAPIDTask_ExecutionState>(value));
}
template <>
inline const std::string& RAPIDTask_ExecutionState_Name(RAPIDTask_ExecutionState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RAPIDTask_ExecutionState_descriptor,
                                                 1, 5>(
      static_cast<int>(value));
}
inline bool RAPIDTask_ExecutionState_Parse(absl::string_view name, RAPIDTask_ExecutionState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RAPIDTask_ExecutionState>(
      RAPIDTask_ExecutionState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Transmission final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Transmission) */ {
 public:
  inline Transmission() : Transmission(nullptr) {}
  ~Transmission() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Transmission(::google::protobuf::internal::ConstantInitialized);

  inline Transmission(const Transmission& from)
      : Transmission(nullptr, from) {}
  Transmission(Transmission&& from) noexcept
    : Transmission() {
    *this = ::std::move(from);
  }

  inline Transmission& operator=(const Transmission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transmission& operator=(Transmission&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transmission& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transmission* internal_default_instance() {
    return reinterpret_cast<const Transmission*>(
               &_Transmission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Transmission& a, Transmission& b) {
    a.Swap(&b);
  }
  inline void Swap(Transmission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transmission* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transmission* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transmission>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Transmission& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Transmission& from) {
    Transmission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Transmission* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.Transmission";
  }
  protected:
  explicit Transmission(::google::protobuf::Arena* arena);
  Transmission(::google::protobuf::Arena* arena, const Transmission& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRotatingMoveFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional bool rotating_move = 2;
  bool has_rotating_move() const;
  void clear_rotating_move() ;
  bool rotating_move() const;
  void set_rotating_move(bool value);

  private:
  bool _internal_rotating_move() const;
  void _internal_set_rotating_move(bool value);

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.Transmission)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    bool rotating_move_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class StandardizedJoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.StandardizedJoint) */ {
 public:
  inline StandardizedJoint() : StandardizedJoint(nullptr) {}
  ~StandardizedJoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StandardizedJoint(::google::protobuf::internal::ConstantInitialized);

  inline StandardizedJoint(const StandardizedJoint& from)
      : StandardizedJoint(nullptr, from) {}
  StandardizedJoint(StandardizedJoint&& from) noexcept
    : StandardizedJoint() {
    *this = ::std::move(from);
  }

  inline StandardizedJoint& operator=(const StandardizedJoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline StandardizedJoint& operator=(StandardizedJoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StandardizedJoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const StandardizedJoint* internal_default_instance() {
    return reinterpret_cast<const StandardizedJoint*>(
               &_StandardizedJoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StandardizedJoint& a, StandardizedJoint& b) {
    a.Swap(&b);
  }
  inline void Swap(StandardizedJoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StandardizedJoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StandardizedJoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StandardizedJoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StandardizedJoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StandardizedJoint& from) {
    StandardizedJoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StandardizedJoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.StandardizedJoint";
  }
  protected:
  explicit StandardizedJoint(::google::protobuf::Arena* arena);
  StandardizedJoint(::google::protobuf::Arena* arena, const StandardizedJoint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginalNameFieldNumber = 1,
    kStandardizedNameFieldNumber = 2,
    kLowerJointBoundFieldNumber = 4,
    kUpperJointBoundFieldNumber = 5,
    kRotatingMoveFieldNumber = 3,
  };
  // optional string original_name = 1;
  bool has_original_name() const;
  void clear_original_name() ;
  const std::string& original_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_original_name(Arg_&& arg, Args_... args);
  std::string* mutable_original_name();
  PROTOBUF_NODISCARD std::string* release_original_name();
  void set_allocated_original_name(std::string* value);

  private:
  const std::string& _internal_original_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_name(
      const std::string& value);
  std::string* _internal_mutable_original_name();

  public:
  // optional string standardized_name = 2;
  bool has_standardized_name() const;
  void clear_standardized_name() ;
  const std::string& standardized_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_standardized_name(Arg_&& arg, Args_... args);
  std::string* mutable_standardized_name();
  PROTOBUF_NODISCARD std::string* release_standardized_name();
  void set_allocated_standardized_name(std::string* value);

  private:
  const std::string& _internal_standardized_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_standardized_name(
      const std::string& value);
  std::string* _internal_mutable_standardized_name();

  public:
  // optional double lower_joint_bound = 4;
  bool has_lower_joint_bound() const;
  void clear_lower_joint_bound() ;
  double lower_joint_bound() const;
  void set_lower_joint_bound(double value);

  private:
  double _internal_lower_joint_bound() const;
  void _internal_set_lower_joint_bound(double value);

  public:
  // optional double upper_joint_bound = 5;
  bool has_upper_joint_bound() const;
  void clear_upper_joint_bound() ;
  double upper_joint_bound() const;
  void set_upper_joint_bound(double value);

  private:
  double _internal_upper_joint_bound() const;
  void _internal_set_upper_joint_bound(double value);

  public:
  // optional bool rotating_move = 3;
  bool has_rotating_move() const;
  void clear_rotating_move() ;
  bool rotating_move() const;
  void set_rotating_move(bool value);

  private:
  bool _internal_rotating_move() const;
  void _internal_set_rotating_move(bool value);

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.StandardizedJoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr original_name_;
    ::google::protobuf::internal::ArenaStringPtr standardized_name_;
    double lower_joint_bound_;
    double upper_joint_bound_;
    bool rotating_move_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class RobotWareVersion final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.RobotWareVersion) */ {
 public:
  inline RobotWareVersion() : RobotWareVersion(nullptr) {}
  ~RobotWareVersion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RobotWareVersion(::google::protobuf::internal::ConstantInitialized);

  inline RobotWareVersion(const RobotWareVersion& from)
      : RobotWareVersion(nullptr, from) {}
  RobotWareVersion(RobotWareVersion&& from) noexcept
    : RobotWareVersion() {
    *this = ::std::move(from);
  }

  inline RobotWareVersion& operator=(const RobotWareVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotWareVersion& operator=(RobotWareVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotWareVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotWareVersion* internal_default_instance() {
    return reinterpret_cast<const RobotWareVersion*>(
               &_RobotWareVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RobotWareVersion& a, RobotWareVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotWareVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotWareVersion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotWareVersion* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotWareVersion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RobotWareVersion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RobotWareVersion& from) {
    RobotWareVersion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RobotWareVersion* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.RobotWareVersion";
  }
  protected:
  explicit RobotWareVersion(::google::protobuf::Arena* arena);
  RobotWareVersion(::google::protobuf::Arena* arena, const RobotWareVersion& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMajorNumberFieldNumber = 2,
    kMinorNumberFieldNumber = 3,
    kPatchNumberFieldNumber = 4,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional uint32 major_number = 2;
  bool has_major_number() const;
  void clear_major_number() ;
  ::uint32_t major_number() const;
  void set_major_number(::uint32_t value);

  private:
  ::uint32_t _internal_major_number() const;
  void _internal_set_major_number(::uint32_t value);

  public:
  // optional uint32 minor_number = 3;
  bool has_minor_number() const;
  void clear_minor_number() ;
  ::uint32_t minor_number() const;
  void set_minor_number(::uint32_t value);

  private:
  ::uint32_t _internal_minor_number() const;
  void _internal_set_minor_number(::uint32_t value);

  public:
  // optional uint32 patch_number = 4;
  bool has_patch_number() const;
  void clear_patch_number() ;
  ::uint32_t patch_number() const;
  void set_patch_number(::uint32_t value);

  private:
  ::uint32_t _internal_patch_number() const;
  void _internal_set_patch_number(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.RobotWareVersion)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint32_t major_number_;
    ::uint32_t minor_number_;
    ::uint32_t patch_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class RobotIndicators final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.RobotIndicators) */ {
 public:
  inline RobotIndicators() : RobotIndicators(nullptr) {}
  ~RobotIndicators() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RobotIndicators(::google::protobuf::internal::ConstantInitialized);

  inline RobotIndicators(const RobotIndicators& from)
      : RobotIndicators(nullptr, from) {}
  RobotIndicators(RobotIndicators&& from) noexcept
    : RobotIndicators() {
    *this = ::std::move(from);
  }

  inline RobotIndicators& operator=(const RobotIndicators& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotIndicators& operator=(RobotIndicators&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotIndicators& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotIndicators* internal_default_instance() {
    return reinterpret_cast<const RobotIndicators*>(
               &_RobotIndicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RobotIndicators& a, RobotIndicators& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotIndicators* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotIndicators* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotIndicators* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotIndicators>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RobotIndicators& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RobotIndicators& from) {
    RobotIndicators::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RobotIndicators* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.RobotIndicators";
  }
  protected:
  explicit RobotIndicators(::google::protobuf::Arena* arena);
  RobotIndicators(::google::protobuf::Arena* arena, const RobotIndicators& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIrb14000FieldNumber = 1,
  };
  // optional bool irb14000 = 1;
  bool has_irb14000() const;
  void clear_irb14000() ;
  bool irb14000() const;
  void set_irb14000(bool value);

  private:
  bool _internal_irb14000() const;
  void _internal_set_irb14000(bool value);

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.RobotIndicators)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool irb14000_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class RAPIDModule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.RAPIDModule) */ {
 public:
  inline RAPIDModule() : RAPIDModule(nullptr) {}
  ~RAPIDModule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RAPIDModule(::google::protobuf::internal::ConstantInitialized);

  inline RAPIDModule(const RAPIDModule& from)
      : RAPIDModule(nullptr, from) {}
  RAPIDModule(RAPIDModule&& from) noexcept
    : RAPIDModule() {
    *this = ::std::move(from);
  }

  inline RAPIDModule& operator=(const RAPIDModule& from) {
    CopyFrom(from);
    return *this;
  }
  inline RAPIDModule& operator=(RAPIDModule&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RAPIDModule& default_instance() {
    return *internal_default_instance();
  }
  static inline const RAPIDModule* internal_default_instance() {
    return reinterpret_cast<const RAPIDModule*>(
               &_RAPIDModule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RAPIDModule& a, RAPIDModule& b) {
    a.Swap(&b);
  }
  inline void Swap(RAPIDModule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RAPIDModule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RAPIDModule* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RAPIDModule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RAPIDModule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RAPIDModule& from) {
    RAPIDModule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RAPIDModule* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.RAPIDModule";
  }
  protected:
  explicit RAPIDModule(::google::protobuf::Arena* arena);
  RAPIDModule(::google::protobuf::Arena* arena, const RAPIDModule& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string type = 2;
  bool has_type() const;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.RAPIDModule)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class Quaternion final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Quaternion(::google::protobuf::internal::ConstantInitialized);

  inline Quaternion(const Quaternion& from)
      : Quaternion(nullptr, from) {}
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Quaternion& from) {
    Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Quaternion* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.Quaternion";
  }
  protected:
  explicit Quaternion(::google::protobuf::Arena* arena);
  Quaternion(::google::protobuf::Arena* arena, const Quaternion& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQ1FieldNumber = 1,
    kQ2FieldNumber = 2,
    kQ3FieldNumber = 3,
    kQ4FieldNumber = 4,
  };
  // optional double q1 = 1;
  bool has_q1() const;
  void clear_q1() ;
  double q1() const;
  void set_q1(double value);

  private:
  double _internal_q1() const;
  void _internal_set_q1(double value);

  public:
  // optional double q2 = 2;
  bool has_q2() const;
  void clear_q2() ;
  double q2() const;
  void set_q2(double value);

  private:
  double _internal_q2() const;
  void _internal_set_q2(double value);

  public:
  // optional double q3 = 3;
  bool has_q3() const;
  void clear_q3() ;
  double q3() const;
  void set_q3(double value);

  private:
  double _internal_q3() const;
  void _internal_set_q3(double value);

  public:
  // optional double q4 = 4;
  bool has_q4() const;
  void clear_q4() ;
  double q4() const;
  void set_q4(double value);

  private:
  double _internal_q4() const;
  void _internal_set_q4(double value);

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.Quaternion)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double q1_;
    double q2_;
    double q3_;
    double q4_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class OptionIndicators final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.OptionIndicators) */ {
 public:
  inline OptionIndicators() : OptionIndicators(nullptr) {}
  ~OptionIndicators() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OptionIndicators(::google::protobuf::internal::ConstantInitialized);

  inline OptionIndicators(const OptionIndicators& from)
      : OptionIndicators(nullptr, from) {}
  OptionIndicators(OptionIndicators&& from) noexcept
    : OptionIndicators() {
    *this = ::std::move(from);
  }

  inline OptionIndicators& operator=(const OptionIndicators& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionIndicators& operator=(OptionIndicators&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionIndicators& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptionIndicators* internal_default_instance() {
    return reinterpret_cast<const OptionIndicators*>(
               &_OptionIndicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OptionIndicators& a, OptionIndicators& b) {
    a.Swap(&b);
  }
  inline void Swap(OptionIndicators* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionIndicators* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptionIndicators* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptionIndicators>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OptionIndicators& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OptionIndicators& from) {
    OptionIndicators::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OptionIndicators* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.OptionIndicators";
  }
  protected:
  explicit OptionIndicators(::google::protobuf::Arena* arena);
  OptionIndicators(::google::protobuf::Arena* arena, const OptionIndicators& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEgmFieldNumber = 1,
    kLeadthroughFieldNumber = 2,
    kMultimoveFieldNumber = 3,
  };
  // optional bool egm = 1;
  bool has_egm() const;
  void clear_egm() ;
  bool egm() const;
  void set_egm(bool value);

  private:
  bool _internal_egm() const;
  void _internal_set_egm(bool value);

  public:
  // optional bool leadthrough = 2;
  bool has_leadthrough() const;
  void clear_leadthrough() ;
  bool leadthrough() const;
  void set_leadthrough(bool value);

  private:
  bool _internal_leadthrough() const;
  void _internal_set_leadthrough(bool value);

  public:
  // optional bool multimove = 3;
  bool has_multimove() const;
  void clear_multimove() ;
  bool multimove() const;
  void set_multimove(bool value);

  private:
  bool _internal_multimove() const;
  void _internal_set_multimove(bool value);

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.OptionIndicators)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool egm_;
    bool leadthrough_;
    bool multimove_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class Cartesian final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Cartesian) */ {
 public:
  inline Cartesian() : Cartesian(nullptr) {}
  ~Cartesian() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Cartesian(::google::protobuf::internal::ConstantInitialized);

  inline Cartesian(const Cartesian& from)
      : Cartesian(nullptr, from) {}
  Cartesian(Cartesian&& from) noexcept
    : Cartesian() {
    *this = ::std::move(from);
  }

  inline Cartesian& operator=(const Cartesian& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cartesian& operator=(Cartesian&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cartesian& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cartesian* internal_default_instance() {
    return reinterpret_cast<const Cartesian*>(
               &_Cartesian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Cartesian& a, Cartesian& b) {
    a.Swap(&b);
  }
  inline void Swap(Cartesian* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cartesian* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cartesian* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cartesian>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Cartesian& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Cartesian& from) {
    Cartesian::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Cartesian* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.Cartesian";
  }
  protected:
  explicit Cartesian(::google::protobuf::Arena* arena);
  Cartesian(::google::protobuf::Arena* arena, const Cartesian& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional double x = 1;
  bool has_x() const;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // optional double y = 2;
  bool has_y() const;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // optional double z = 3;
  bool has_z() const;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.Cartesian)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class Arm final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Arm) */ {
 public:
  inline Arm() : Arm(nullptr) {}
  ~Arm() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Arm(::google::protobuf::internal::ConstantInitialized);

  inline Arm(const Arm& from)
      : Arm(nullptr, from) {}
  Arm(Arm&& from) noexcept
    : Arm() {
    *this = ::std::move(from);
  }

  inline Arm& operator=(const Arm& from) {
    CopyFrom(from);
    return *this;
  }
  inline Arm& operator=(Arm&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Arm& default_instance() {
    return *internal_default_instance();
  }
  static inline const Arm* internal_default_instance() {
    return reinterpret_cast<const Arm*>(
               &_Arm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Arm& a, Arm& b) {
    a.Swap(&b);
  }
  inline void Swap(Arm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Arm* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Arm* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Arm>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Arm& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Arm& from) {
    Arm::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Arm* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.Arm";
  }
  protected:
  explicit Arm(::google::protobuf::Arena* arena);
  Arm(::google::protobuf::Arena* arena, const Arm& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLowerJointBoundFieldNumber = 2,
    kUpperJointBoundFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional double lower_joint_bound = 2;
  bool has_lower_joint_bound() const;
  void clear_lower_joint_bound() ;
  double lower_joint_bound() const;
  void set_lower_joint_bound(double value);

  private:
  double _internal_lower_joint_bound() const;
  void _internal_set_lower_joint_bound(double value);

  public:
  // optional double upper_joint_bound = 3;
  bool has_upper_joint_bound() const;
  void clear_upper_joint_bound() ;
  double upper_joint_bound() const;
  void set_upper_joint_bound(double value);

  private:
  double _internal_upper_joint_bound() const;
  void _internal_set_upper_joint_bound(double value);

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.Arm)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      26, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    double lower_joint_bound_;
    double upper_joint_bound_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class AddInIndicators final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.AddInIndicators) */ {
 public:
  inline AddInIndicators() : AddInIndicators(nullptr) {}
  ~AddInIndicators() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddInIndicators(::google::protobuf::internal::ConstantInitialized);

  inline AddInIndicators(const AddInIndicators& from)
      : AddInIndicators(nullptr, from) {}
  AddInIndicators(AddInIndicators&& from) noexcept
    : AddInIndicators() {
    *this = ::std::move(from);
  }

  inline AddInIndicators& operator=(const AddInIndicators& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddInIndicators& operator=(AddInIndicators&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddInIndicators& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddInIndicators* internal_default_instance() {
    return reinterpret_cast<const AddInIndicators*>(
               &_AddInIndicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AddInIndicators& a, AddInIndicators& b) {
    a.Swap(&b);
  }
  inline void Swap(AddInIndicators* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddInIndicators* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddInIndicators* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddInIndicators>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddInIndicators& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddInIndicators& from) {
    AddInIndicators::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddInIndicators* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.AddInIndicators";
  }
  protected:
  explicit AddInIndicators(::google::protobuf::Arena* arena);
  AddInIndicators(::google::protobuf::Arena* arena, const AddInIndicators& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSmartGripperFieldNumber = 1,
    kStateMachine10FieldNumber = 2,
    kStateMachine11FieldNumber = 3,
  };
  // optional bool smart_gripper = 1;
  bool has_smart_gripper() const;
  void clear_smart_gripper() ;
  bool smart_gripper() const;
  void set_smart_gripper(bool value);

  private:
  bool _internal_smart_gripper() const;
  void _internal_set_smart_gripper(bool value);

  public:
  // optional bool state_machine_1_0 = 2;
  bool has_state_machine_1_0() const;
  void clear_state_machine_1_0() ;
  bool state_machine_1_0() const;
  void set_state_machine_1_0(bool value);

  private:
  bool _internal_state_machine_1_0() const;
  void _internal_set_state_machine_1_0(bool value);

  public:
  // optional bool state_machine_1_1 = 3;
  bool has_state_machine_1_1() const;
  void clear_state_machine_1_1() ;
  bool state_machine_1_1() const;
  void set_state_machine_1_1(bool value);

  private:
  bool _internal_state_machine_1_1() const;
  void _internal_set_state_machine_1_1(bool value);

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.AddInIndicators)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool smart_gripper_;
    bool state_machine_1_0_;
    bool state_machine_1_1_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class SystemIndicators final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.SystemIndicators) */ {
 public:
  inline SystemIndicators() : SystemIndicators(nullptr) {}
  ~SystemIndicators() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SystemIndicators(::google::protobuf::internal::ConstantInitialized);

  inline SystemIndicators(const SystemIndicators& from)
      : SystemIndicators(nullptr, from) {}
  SystemIndicators(SystemIndicators&& from) noexcept
    : SystemIndicators() {
    *this = ::std::move(from);
  }

  inline SystemIndicators& operator=(const SystemIndicators& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemIndicators& operator=(SystemIndicators&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemIndicators& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemIndicators* internal_default_instance() {
    return reinterpret_cast<const SystemIndicators*>(
               &_SystemIndicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SystemIndicators& a, SystemIndicators& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemIndicators* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemIndicators* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemIndicators* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemIndicators>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SystemIndicators& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SystemIndicators& from) {
    SystemIndicators::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SystemIndicators* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.SystemIndicators";
  }
  protected:
  explicit SystemIndicators(::google::protobuf::Arena* arena);
  SystemIndicators(::google::protobuf::Arena* arena, const SystemIndicators& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotsFieldNumber = 1,
    kOptionsFieldNumber = 2,
    kAddinsFieldNumber = 3,
  };
  // optional .abb.robot.RobotIndicators robots = 1;
  bool has_robots() const;
  void clear_robots() ;
  const ::abb::robot::RobotIndicators& robots() const;
  PROTOBUF_NODISCARD ::abb::robot::RobotIndicators* release_robots();
  ::abb::robot::RobotIndicators* mutable_robots();
  void set_allocated_robots(::abb::robot::RobotIndicators* value);
  void unsafe_arena_set_allocated_robots(::abb::robot::RobotIndicators* value);
  ::abb::robot::RobotIndicators* unsafe_arena_release_robots();

  private:
  const ::abb::robot::RobotIndicators& _internal_robots() const;
  ::abb::robot::RobotIndicators* _internal_mutable_robots();

  public:
  // optional .abb.robot.OptionIndicators options = 2;
  bool has_options() const;
  void clear_options() ;
  const ::abb::robot::OptionIndicators& options() const;
  PROTOBUF_NODISCARD ::abb::robot::OptionIndicators* release_options();
  ::abb::robot::OptionIndicators* mutable_options();
  void set_allocated_options(::abb::robot::OptionIndicators* value);
  void unsafe_arena_set_allocated_options(::abb::robot::OptionIndicators* value);
  ::abb::robot::OptionIndicators* unsafe_arena_release_options();

  private:
  const ::abb::robot::OptionIndicators& _internal_options() const;
  ::abb::robot::OptionIndicators* _internal_mutable_options();

  public:
  // optional .abb.robot.AddInIndicators addins = 3;
  bool has_addins() const;
  void clear_addins() ;
  const ::abb::robot::AddInIndicators& addins() const;
  PROTOBUF_NODISCARD ::abb::robot::AddInIndicators* release_addins();
  ::abb::robot::AddInIndicators* mutable_addins();
  void set_allocated_addins(::abb::robot::AddInIndicators* value);
  void unsafe_arena_set_allocated_addins(::abb::robot::AddInIndicators* value);
  ::abb::robot::AddInIndicators* unsafe_arena_release_addins();

  private:
  const ::abb::robot::AddInIndicators& _internal_addins() const;
  ::abb::robot::AddInIndicators* _internal_mutable_addins();

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.SystemIndicators)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::robot::RobotIndicators* robots_;
    ::abb::robot::OptionIndicators* options_;
    ::abb::robot::AddInIndicators* addins_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class RAPIDTask final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.RAPIDTask) */ {
 public:
  inline RAPIDTask() : RAPIDTask(nullptr) {}
  ~RAPIDTask() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RAPIDTask(::google::protobuf::internal::ConstantInitialized);

  inline RAPIDTask(const RAPIDTask& from)
      : RAPIDTask(nullptr, from) {}
  RAPIDTask(RAPIDTask&& from) noexcept
    : RAPIDTask() {
    *this = ::std::move(from);
  }

  inline RAPIDTask& operator=(const RAPIDTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline RAPIDTask& operator=(RAPIDTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RAPIDTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const RAPIDTask* internal_default_instance() {
    return reinterpret_cast<const RAPIDTask*>(
               &_RAPIDTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RAPIDTask& a, RAPIDTask& b) {
    a.Swap(&b);
  }
  inline void Swap(RAPIDTask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RAPIDTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RAPIDTask* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RAPIDTask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RAPIDTask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RAPIDTask& from) {
    RAPIDTask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RAPIDTask* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.RAPIDTask";
  }
  protected:
  explicit RAPIDTask(::google::protobuf::Arena* arena);
  RAPIDTask(::google::protobuf::Arena* arena, const RAPIDTask& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ExecutionState = RAPIDTask_ExecutionState;
  static constexpr ExecutionState UNKNOWN = RAPIDTask_ExecutionState_UNKNOWN;
  static constexpr ExecutionState READY = RAPIDTask_ExecutionState_READY;
  static constexpr ExecutionState STOPPED = RAPIDTask_ExecutionState_STOPPED;
  static constexpr ExecutionState STARTED = RAPIDTask_ExecutionState_STARTED;
  static constexpr ExecutionState UNINITIALIZED = RAPIDTask_ExecutionState_UNINITIALIZED;
  static inline bool ExecutionState_IsValid(int value) {
    return RAPIDTask_ExecutionState_IsValid(value);
  }
  static constexpr ExecutionState ExecutionState_MIN = RAPIDTask_ExecutionState_ExecutionState_MIN;
  static constexpr ExecutionState ExecutionState_MAX = RAPIDTask_ExecutionState_ExecutionState_MAX;
  static constexpr int ExecutionState_ARRAYSIZE = RAPIDTask_ExecutionState_ExecutionState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ExecutionState_descriptor() {
    return RAPIDTask_ExecutionState_descriptor();
  }
  template <typename T>
  static inline const std::string& ExecutionState_Name(T value) {
    return RAPIDTask_ExecutionState_Name(value);
  }
  static inline bool ExecutionState_Parse(absl::string_view name, ExecutionState* value) {
    return RAPIDTask_ExecutionState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModulesFieldNumber = 5,
    kNameFieldNumber = 1,
    kIsMotionTaskFieldNumber = 2,
    kIsActiveFieldNumber = 3,
    kExecutionStateFieldNumber = 4,
  };
  // repeated .abb.robot.RAPIDModule modules = 5;
  int modules_size() const;
  private:
  int _internal_modules_size() const;

  public:
  void clear_modules() ;
  ::abb::robot::RAPIDModule* mutable_modules(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDModule >*
      mutable_modules();
  private:
  const ::google::protobuf::RepeatedPtrField<::abb::robot::RAPIDModule>& _internal_modules() const;
  ::google::protobuf::RepeatedPtrField<::abb::robot::RAPIDModule>* _internal_mutable_modules();
  public:
  const ::abb::robot::RAPIDModule& modules(int index) const;
  ::abb::robot::RAPIDModule* add_modules();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDModule >&
      modules() const;
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional bool is_motion_task = 2;
  bool has_is_motion_task() const;
  void clear_is_motion_task() ;
  bool is_motion_task() const;
  void set_is_motion_task(bool value);

  private:
  bool _internal_is_motion_task() const;
  void _internal_set_is_motion_task(bool value);

  public:
  // optional bool is_active = 3;
  bool has_is_active() const;
  void clear_is_active() ;
  bool is_active() const;
  void set_is_active(bool value);

  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);

  public:
  // optional .abb.robot.RAPIDTask.ExecutionState execution_state = 4 [default = UNKNOWN];
  bool has_execution_state() const;
  void clear_execution_state() ;
  ::abb::robot::RAPIDTask_ExecutionState execution_state() const;
  void set_execution_state(::abb::robot::RAPIDTask_ExecutionState value);

  private:
  ::abb::robot::RAPIDTask_ExecutionState _internal_execution_state() const;
  void _internal_set_execution_state(::abb::robot::RAPIDTask_ExecutionState value);

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.RAPIDTask)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDModule > modules_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    bool is_motion_task_;
    bool is_active_;
    int execution_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class Pose final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Pose) */ {
 public:
  inline Pose() : Pose(nullptr) {}
  ~Pose() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Pose(::google::protobuf::internal::ConstantInitialized);

  inline Pose(const Pose& from)
      : Pose(nullptr, from) {}
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pose& operator=(Pose&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(Pose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pose* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pose* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pose& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Pose& from) {
    Pose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Pose* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.Pose";
  }
  protected:
  explicit Pose(::google::protobuf::Arena* arena);
  Pose(::google::protobuf::Arena* arena, const Pose& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
  };
  // optional .abb.robot.Cartesian position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::abb::robot::Cartesian& position() const;
  PROTOBUF_NODISCARD ::abb::robot::Cartesian* release_position();
  ::abb::robot::Cartesian* mutable_position();
  void set_allocated_position(::abb::robot::Cartesian* value);
  void unsafe_arena_set_allocated_position(::abb::robot::Cartesian* value);
  ::abb::robot::Cartesian* unsafe_arena_release_position();

  private:
  const ::abb::robot::Cartesian& _internal_position() const;
  ::abb::robot::Cartesian* _internal_mutable_position();

  public:
  // optional .abb.robot.Quaternion rotation = 2;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::abb::robot::Quaternion& rotation() const;
  PROTOBUF_NODISCARD ::abb::robot::Quaternion* release_rotation();
  ::abb::robot::Quaternion* mutable_rotation();
  void set_allocated_rotation(::abb::robot::Quaternion* value);
  void unsafe_arena_set_allocated_rotation(::abb::robot::Quaternion* value);
  ::abb::robot::Quaternion* unsafe_arena_release_rotation();

  private:
  const ::abb::robot::Quaternion& _internal_rotation() const;
  ::abb::robot::Quaternion* _internal_mutable_rotation();

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.Pose)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::robot::Cartesian* position_;
    ::abb::robot::Quaternion* rotation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class Joint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Joint) */ {
 public:
  inline Joint() : Joint(nullptr) {}
  ~Joint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Joint(::google::protobuf::internal::ConstantInitialized);

  inline Joint(const Joint& from)
      : Joint(nullptr, from) {}
  Joint(Joint&& from) noexcept
    : Joint() {
    *this = ::std::move(from);
  }

  inline Joint& operator=(const Joint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Joint& operator=(Joint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Joint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Joint* internal_default_instance() {
    return reinterpret_cast<const Joint*>(
               &_Joint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Joint& a, Joint& b) {
    a.Swap(&b);
  }
  inline void Swap(Joint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Joint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Joint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Joint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Joint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Joint& from) {
    Joint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Joint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.Joint";
  }
  protected:
  explicit Joint(::google::protobuf::Arena* arena);
  Joint(::google::protobuf::Arena* arena, const Joint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kArmFieldNumber = 4,
    kTransmissionFieldNumber = 5,
    kLogicalAxisFieldNumber = 2,
    kKinematicAxisNumberFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional .abb.robot.Arm arm = 4;
  bool has_arm() const;
  void clear_arm() ;
  const ::abb::robot::Arm& arm() const;
  PROTOBUF_NODISCARD ::abb::robot::Arm* release_arm();
  ::abb::robot::Arm* mutable_arm();
  void set_allocated_arm(::abb::robot::Arm* value);
  void unsafe_arena_set_allocated_arm(::abb::robot::Arm* value);
  ::abb::robot::Arm* unsafe_arena_release_arm();

  private:
  const ::abb::robot::Arm& _internal_arm() const;
  ::abb::robot::Arm* _internal_mutable_arm();

  public:
  // optional .abb.robot.Transmission transmission = 5;
  bool has_transmission() const;
  void clear_transmission() ;
  const ::abb::robot::Transmission& transmission() const;
  PROTOBUF_NODISCARD ::abb::robot::Transmission* release_transmission();
  ::abb::robot::Transmission* mutable_transmission();
  void set_allocated_transmission(::abb::robot::Transmission* value);
  void unsafe_arena_set_allocated_transmission(::abb::robot::Transmission* value);
  ::abb::robot::Transmission* unsafe_arena_release_transmission();

  private:
  const ::abb::robot::Transmission& _internal_transmission() const;
  ::abb::robot::Transmission* _internal_mutable_transmission();

  public:
  // optional int32 logical_axis = 2;
  bool has_logical_axis() const;
  void clear_logical_axis() ;
  ::int32_t logical_axis() const;
  void set_logical_axis(::int32_t value);

  private:
  ::int32_t _internal_logical_axis() const;
  void _internal_set_logical_axis(::int32_t value);

  public:
  // optional int32 kinematic_axis_number = 3;
  bool has_kinematic_axis_number() const;
  void clear_kinematic_axis_number() ;
  ::int32_t kinematic_axis_number() const;
  void set_kinematic_axis_number(::int32_t value);

  private:
  ::int32_t _internal_kinematic_axis_number() const;
  void _internal_set_kinematic_axis_number(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.Joint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      28, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::abb::robot::Arm* arm_;
    ::abb::robot::Transmission* transmission_;
    ::int32_t logical_axis_;
    ::int32_t kinematic_axis_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class Header final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Header(::google::protobuf::internal::ConstantInitialized);

  inline Header(const Header& from)
      : Header(nullptr, from) {}
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Header* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.Header";
  }
  protected:
  explicit Header(::google::protobuf::Arena* arena);
  Header(::google::protobuf::Arena* arena, const Header& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 6,
    kIpAddressFieldNumber = 1,
    kSystemNameFieldNumber = 4,
    kSystemTypeFieldNumber = 5,
    kRobotWareVersionFieldNumber = 3,
    kRwsPortNumberFieldNumber = 2,
  };
  // repeated string options = 6;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  const std::string& options(int index) const;
  std::string* mutable_options(int index);
  void set_options(int index, const std::string& value);
  void set_options(int index, std::string&& value);
  void set_options(int index, const char* value);
  void set_options(int index, const char* value, std::size_t size);
  void set_options(int index, absl::string_view value);
  std::string* add_options();
  void add_options(const std::string& value);
  void add_options(std::string&& value);
  void add_options(const char* value);
  void add_options(const char* value, std::size_t size);
  void add_options(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& options() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_options();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_options() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_options();

  public:
  // optional string ip_address = 1;
  bool has_ip_address() const;
  void clear_ip_address() ;
  const std::string& ip_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_address(Arg_&& arg, Args_... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* value);

  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(
      const std::string& value);
  std::string* _internal_mutable_ip_address();

  public:
  // optional string system_name = 4;
  bool has_system_name() const;
  void clear_system_name() ;
  const std::string& system_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_system_name(Arg_&& arg, Args_... args);
  std::string* mutable_system_name();
  PROTOBUF_NODISCARD std::string* release_system_name();
  void set_allocated_system_name(std::string* value);

  private:
  const std::string& _internal_system_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system_name(
      const std::string& value);
  std::string* _internal_mutable_system_name();

  public:
  // optional string system_type = 5;
  bool has_system_type() const;
  void clear_system_type() ;
  const std::string& system_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_system_type(Arg_&& arg, Args_... args);
  std::string* mutable_system_type();
  PROTOBUF_NODISCARD std::string* release_system_type();
  void set_allocated_system_type(std::string* value);

  private:
  const std::string& _internal_system_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system_type(
      const std::string& value);
  std::string* _internal_mutable_system_type();

  public:
  // optional .abb.robot.RobotWareVersion robot_ware_version = 3;
  bool has_robot_ware_version() const;
  void clear_robot_ware_version() ;
  const ::abb::robot::RobotWareVersion& robot_ware_version() const;
  PROTOBUF_NODISCARD ::abb::robot::RobotWareVersion* release_robot_ware_version();
  ::abb::robot::RobotWareVersion* mutable_robot_ware_version();
  void set_allocated_robot_ware_version(::abb::robot::RobotWareVersion* value);
  void unsafe_arena_set_allocated_robot_ware_version(::abb::robot::RobotWareVersion* value);
  ::abb::robot::RobotWareVersion* unsafe_arena_release_robot_ware_version();

  private:
  const ::abb::robot::RobotWareVersion& _internal_robot_ware_version() const;
  ::abb::robot::RobotWareVersion* _internal_mutable_robot_ware_version();

  public:
  // optional uint32 rws_port_number = 2;
  bool has_rws_port_number() const;
  void clear_rws_port_number() ;
  ::uint32_t rws_port_number() const;
  void set_rws_port_number(::uint32_t value);

  private:
  ::uint32_t _internal_rws_port_number() const;
  void _internal_set_rws_port_number(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.Header)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      64, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> options_;
    ::google::protobuf::internal::ArenaStringPtr ip_address_;
    ::google::protobuf::internal::ArenaStringPtr system_name_;
    ::google::protobuf::internal::ArenaStringPtr system_type_;
    ::abb::robot::RobotWareVersion* robot_ware_version_;
    ::uint32_t rws_port_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class Single final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Single) */ {
 public:
  inline Single() : Single(nullptr) {}
  ~Single() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Single(::google::protobuf::internal::ConstantInitialized);

  inline Single(const Single& from)
      : Single(nullptr, from) {}
  Single(Single&& from) noexcept
    : Single() {
    *this = ::std::move(from);
  }

  inline Single& operator=(const Single& from) {
    CopyFrom(from);
    return *this;
  }
  inline Single& operator=(Single&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Single& default_instance() {
    return *internal_default_instance();
  }
  static inline const Single* internal_default_instance() {
    return reinterpret_cast<const Single*>(
               &_Single_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Single& a, Single& b) {
    a.Swap(&b);
  }
  inline void Swap(Single* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Single* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Single* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Single>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Single& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Single& from) {
    Single::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Single* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.Single";
  }
  protected:
  explicit Single(::google::protobuf::Arena* arena);
  Single(::google::protobuf::Arena* arena, const Single& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kBaseFrameMovedByFieldNumber = 5,
    kJointFieldNumber = 3,
    kBaseFrameFieldNumber = 4,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string type = 2;
  bool has_type() const;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // optional string base_frame_moved_by = 5;
  bool has_base_frame_moved_by() const;
  void clear_base_frame_moved_by() ;
  const std::string& base_frame_moved_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_base_frame_moved_by(Arg_&& arg, Args_... args);
  std::string* mutable_base_frame_moved_by();
  PROTOBUF_NODISCARD std::string* release_base_frame_moved_by();
  void set_allocated_base_frame_moved_by(std::string* value);

  private:
  const std::string& _internal_base_frame_moved_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_frame_moved_by(
      const std::string& value);
  std::string* _internal_mutable_base_frame_moved_by();

  public:
  // optional .abb.robot.Joint joint = 3;
  bool has_joint() const;
  void clear_joint() ;
  const ::abb::robot::Joint& joint() const;
  PROTOBUF_NODISCARD ::abb::robot::Joint* release_joint();
  ::abb::robot::Joint* mutable_joint();
  void set_allocated_joint(::abb::robot::Joint* value);
  void unsafe_arena_set_allocated_joint(::abb::robot::Joint* value);
  ::abb::robot::Joint* unsafe_arena_release_joint();

  private:
  const ::abb::robot::Joint& _internal_joint() const;
  ::abb::robot::Joint* _internal_mutable_joint();

  public:
  // optional .abb.robot.Pose base_frame = 4;
  bool has_base_frame() const;
  void clear_base_frame() ;
  const ::abb::robot::Pose& base_frame() const;
  PROTOBUF_NODISCARD ::abb::robot::Pose* release_base_frame();
  ::abb::robot::Pose* mutable_base_frame();
  void set_allocated_base_frame(::abb::robot::Pose* value);
  void unsafe_arena_set_allocated_base_frame(::abb::robot::Pose* value);
  ::abb::robot::Pose* unsafe_arena_release_base_frame();

  private:
  const ::abb::robot::Pose& _internal_base_frame() const;
  ::abb::robot::Pose* _internal_mutable_base_frame();

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.Single)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr base_frame_moved_by_;
    ::abb::robot::Joint* joint_;
    ::abb::robot::Pose* base_frame_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class Robot final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Robot) */ {
 public:
  inline Robot() : Robot(nullptr) {}
  ~Robot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Robot(::google::protobuf::internal::ConstantInitialized);

  inline Robot(const Robot& from)
      : Robot(nullptr, from) {}
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot& operator=(Robot&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Robot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Robot& from) {
    Robot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Robot* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.Robot";
  }
  protected:
  explicit Robot(::google::protobuf::Arena* arena);
  Robot(::google::protobuf::Arena* arena, const Robot& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 3,
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kBaseFrameMovedByFieldNumber = 5,
    kBaseFrameFieldNumber = 4,
  };
  // repeated .abb.robot.Joint joints = 3;
  int joints_size() const;
  private:
  int _internal_joints_size() const;

  public:
  void clear_joints() ;
  ::abb::robot::Joint* mutable_joints(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::Joint >*
      mutable_joints();
  private:
  const ::google::protobuf::RepeatedPtrField<::abb::robot::Joint>& _internal_joints() const;
  ::google::protobuf::RepeatedPtrField<::abb::robot::Joint>* _internal_mutable_joints();
  public:
  const ::abb::robot::Joint& joints(int index) const;
  ::abb::robot::Joint* add_joints();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::Joint >&
      joints() const;
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string type = 2;
  bool has_type() const;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // optional string base_frame_moved_by = 5;
  bool has_base_frame_moved_by() const;
  void clear_base_frame_moved_by() ;
  const std::string& base_frame_moved_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_base_frame_moved_by(Arg_&& arg, Args_... args);
  std::string* mutable_base_frame_moved_by();
  PROTOBUF_NODISCARD std::string* release_base_frame_moved_by();
  void set_allocated_base_frame_moved_by(std::string* value);

  private:
  const std::string& _internal_base_frame_moved_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_frame_moved_by(
      const std::string& value);
  std::string* _internal_mutable_base_frame_moved_by();

  public:
  // optional .abb.robot.Pose base_frame = 4;
  bool has_base_frame() const;
  void clear_base_frame() ;
  const ::abb::robot::Pose& base_frame() const;
  PROTOBUF_NODISCARD ::abb::robot::Pose* release_base_frame();
  ::abb::robot::Pose* mutable_base_frame();
  void set_allocated_base_frame(::abb::robot::Pose* value);
  void unsafe_arena_set_allocated_base_frame(::abb::robot::Pose* value);
  ::abb::robot::Pose* unsafe_arena_release_base_frame();

  private:
  const ::abb::robot::Pose& _internal_base_frame() const;
  ::abb::robot::Pose* _internal_mutable_base_frame();

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.Robot)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::abb::robot::Joint > joints_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr base_frame_moved_by_;
    ::abb::robot::Pose* base_frame_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class MechanicalUnit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.MechanicalUnit) */ {
 public:
  inline MechanicalUnit() : MechanicalUnit(nullptr) {}
  ~MechanicalUnit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MechanicalUnit(::google::protobuf::internal::ConstantInitialized);

  inline MechanicalUnit(const MechanicalUnit& from)
      : MechanicalUnit(nullptr, from) {}
  MechanicalUnit(MechanicalUnit&& from) noexcept
    : MechanicalUnit() {
    *this = ::std::move(from);
  }

  inline MechanicalUnit& operator=(const MechanicalUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline MechanicalUnit& operator=(MechanicalUnit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MechanicalUnit& default_instance() {
    return *internal_default_instance();
  }
  static inline const MechanicalUnit* internal_default_instance() {
    return reinterpret_cast<const MechanicalUnit*>(
               &_MechanicalUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MechanicalUnit& a, MechanicalUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(MechanicalUnit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MechanicalUnit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MechanicalUnit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MechanicalUnit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MechanicalUnit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MechanicalUnit& from) {
    MechanicalUnit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MechanicalUnit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.MechanicalUnit";
  }
  protected:
  explicit MechanicalUnit(::google::protobuf::Arena* arena);
  MechanicalUnit(::google::protobuf::Arena* arena, const MechanicalUnit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = MechanicalUnit_Type;
  static constexpr Type UNDEFINED = MechanicalUnit_Type_UNDEFINED;
  static constexpr Type NONE = MechanicalUnit_Type_NONE;
  static constexpr Type TCP_ROBOT = MechanicalUnit_Type_TCP_ROBOT;
  static constexpr Type ROBOT = MechanicalUnit_Type_ROBOT;
  static constexpr Type SINGLE = MechanicalUnit_Type_SINGLE;
  static inline bool Type_IsValid(int value) {
    return MechanicalUnit_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = MechanicalUnit_Type_Type_MIN;
  static constexpr Type Type_MAX = MechanicalUnit_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = MechanicalUnit_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return MechanicalUnit_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return MechanicalUnit_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return MechanicalUnit_Type_Parse(name, value);
  }

  using Mode = MechanicalUnit_Mode;
  static constexpr Mode DEACTIVATED = MechanicalUnit_Mode_DEACTIVATED;
  static constexpr Mode ACTIVATED = MechanicalUnit_Mode_ACTIVATED;
  static inline bool Mode_IsValid(int value) {
    return MechanicalUnit_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN = MechanicalUnit_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX = MechanicalUnit_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE = MechanicalUnit_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Mode_descriptor() {
    return MechanicalUnit_Mode_descriptor();
  }
  template <typename T>
  static inline const std::string& Mode_Name(T value) {
    return MechanicalUnit_Mode_Name(value);
  }
  static inline bool Mode_Parse(absl::string_view name, Mode* value) {
    return MechanicalUnit_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSinglesFieldNumber = 3,
    kStandardizedJointsFieldNumber = 12,
    kNameFieldNumber = 1,
    kTaskNameFieldNumber = 5,
    kIsIntegratedUnitFieldNumber = 8,
    kHasIntegratedUnitFieldNumber = 9,
    kStatusFieldNumber = 10,
    kRobotFieldNumber = 2,
    kTypeFieldNumber = 4,
    kAxesFieldNumber = 6,
    kAxesTotalFieldNumber = 7,
    kModeFieldNumber = 11,
  };
  // repeated .abb.robot.Single singles = 3;
  int singles_size() const;
  private:
  int _internal_singles_size() const;

  public:
  void clear_singles() ;
  ::abb::robot::Single* mutable_singles(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::Single >*
      mutable_singles();
  private:
  const ::google::protobuf::RepeatedPtrField<::abb::robot::Single>& _internal_singles() const;
  ::google::protobuf::RepeatedPtrField<::abb::robot::Single>* _internal_mutable_singles();
  public:
  const ::abb::robot::Single& singles(int index) const;
  ::abb::robot::Single* add_singles();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::Single >&
      singles() const;
  // repeated .abb.robot.StandardizedJoint standardized_joints = 12;
  int standardized_joints_size() const;
  private:
  int _internal_standardized_joints_size() const;

  public:
  void clear_standardized_joints() ;
  ::abb::robot::StandardizedJoint* mutable_standardized_joints(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::StandardizedJoint >*
      mutable_standardized_joints();
  private:
  const ::google::protobuf::RepeatedPtrField<::abb::robot::StandardizedJoint>& _internal_standardized_joints() const;
  ::google::protobuf::RepeatedPtrField<::abb::robot::StandardizedJoint>* _internal_mutable_standardized_joints();
  public:
  const ::abb::robot::StandardizedJoint& standardized_joints(int index) const;
  ::abb::robot::StandardizedJoint* add_standardized_joints();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::StandardizedJoint >&
      standardized_joints() const;
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string task_name = 5;
  bool has_task_name() const;
  void clear_task_name() ;
  const std::string& task_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_name(Arg_&& arg, Args_... args);
  std::string* mutable_task_name();
  PROTOBUF_NODISCARD std::string* release_task_name();
  void set_allocated_task_name(std::string* value);

  private:
  const std::string& _internal_task_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_name(
      const std::string& value);
  std::string* _internal_mutable_task_name();

  public:
  // optional string is_integrated_unit = 8;
  bool has_is_integrated_unit() const;
  void clear_is_integrated_unit() ;
  const std::string& is_integrated_unit() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_is_integrated_unit(Arg_&& arg, Args_... args);
  std::string* mutable_is_integrated_unit();
  PROTOBUF_NODISCARD std::string* release_is_integrated_unit();
  void set_allocated_is_integrated_unit(std::string* value);

  private:
  const std::string& _internal_is_integrated_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_is_integrated_unit(
      const std::string& value);
  std::string* _internal_mutable_is_integrated_unit();

  public:
  // optional string has_integrated_unit = 9;
  bool has_has_integrated_unit() const;
  void clear_has_integrated_unit() ;
  const std::string& has_integrated_unit() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_has_integrated_unit(Arg_&& arg, Args_... args);
  std::string* mutable_has_integrated_unit();
  PROTOBUF_NODISCARD std::string* release_has_integrated_unit();
  void set_allocated_has_integrated_unit(std::string* value);

  private:
  const std::string& _internal_has_integrated_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_has_integrated_unit(
      const std::string& value);
  std::string* _internal_mutable_has_integrated_unit();

  public:
  // optional string status = 10;
  bool has_status() const;
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // optional .abb.robot.Robot robot = 2;
  bool has_robot() const;
  void clear_robot() ;
  const ::abb::robot::Robot& robot() const;
  PROTOBUF_NODISCARD ::abb::robot::Robot* release_robot();
  ::abb::robot::Robot* mutable_robot();
  void set_allocated_robot(::abb::robot::Robot* value);
  void unsafe_arena_set_allocated_robot(::abb::robot::Robot* value);
  ::abb::robot::Robot* unsafe_arena_release_robot();

  private:
  const ::abb::robot::Robot& _internal_robot() const;
  ::abb::robot::Robot* _internal_mutable_robot();

  public:
  // optional .abb.robot.MechanicalUnit.Type type = 4 [default = UNDEFINED];
  bool has_type() const;
  void clear_type() ;
  ::abb::robot::MechanicalUnit_Type type() const;
  void set_type(::abb::robot::MechanicalUnit_Type value);

  private:
  ::abb::robot::MechanicalUnit_Type _internal_type() const;
  void _internal_set_type(::abb::robot::MechanicalUnit_Type value);

  public:
  // optional int32 axes = 6;
  bool has_axes() const;
  void clear_axes() ;
  ::int32_t axes() const;
  void set_axes(::int32_t value);

  private:
  ::int32_t _internal_axes() const;
  void _internal_set_axes(::int32_t value);

  public:
  // optional int32 axes_total = 7;
  bool has_axes_total() const;
  void clear_axes_total() ;
  ::int32_t axes_total() const;
  void set_axes_total(::int32_t value);

  private:
  ::int32_t _internal_axes_total() const;
  void _internal_set_axes_total(::int32_t value);

  public:
  // optional .abb.robot.MechanicalUnit.Mode mode = 11 [default = DEACTIVATED];
  bool has_mode() const;
  void clear_mode() ;
  ::abb::robot::MechanicalUnit_Mode mode() const;
  void set_mode(::abb::robot::MechanicalUnit_Mode value);

  private:
  ::abb::robot::MechanicalUnit_Mode _internal_mode() const;
  void _internal_set_mode(::abb::robot::MechanicalUnit_Mode value);

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.MechanicalUnit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 5,
      97, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::abb::robot::Single > singles_;
    ::google::protobuf::RepeatedPtrField< ::abb::robot::StandardizedJoint > standardized_joints_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr task_name_;
    ::google::protobuf::internal::ArenaStringPtr is_integrated_unit_;
    ::google::protobuf::internal::ArenaStringPtr has_integrated_unit_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::abb::robot::Robot* robot_;
    int type_;
    ::int32_t axes_;
    ::int32_t axes_total_;
    int mode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class MechanicalUnitGroup final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.MechanicalUnitGroup) */ {
 public:
  inline MechanicalUnitGroup() : MechanicalUnitGroup(nullptr) {}
  ~MechanicalUnitGroup() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MechanicalUnitGroup(::google::protobuf::internal::ConstantInitialized);

  inline MechanicalUnitGroup(const MechanicalUnitGroup& from)
      : MechanicalUnitGroup(nullptr, from) {}
  MechanicalUnitGroup(MechanicalUnitGroup&& from) noexcept
    : MechanicalUnitGroup() {
    *this = ::std::move(from);
  }

  inline MechanicalUnitGroup& operator=(const MechanicalUnitGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline MechanicalUnitGroup& operator=(MechanicalUnitGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MechanicalUnitGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const MechanicalUnitGroup* internal_default_instance() {
    return reinterpret_cast<const MechanicalUnitGroup*>(
               &_MechanicalUnitGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MechanicalUnitGroup& a, MechanicalUnitGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(MechanicalUnitGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MechanicalUnitGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MechanicalUnitGroup* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MechanicalUnitGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MechanicalUnitGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MechanicalUnitGroup& from) {
    MechanicalUnitGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MechanicalUnitGroup* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.MechanicalUnitGroup";
  }
  protected:
  explicit MechanicalUnitGroup(::google::protobuf::Arena* arena);
  MechanicalUnitGroup(::google::protobuf::Arena* arena, const MechanicalUnitGroup& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMechanicalUnitsFieldNumber = 3,
    kNameFieldNumber = 1,
    kRobotFieldNumber = 2,
  };
  // repeated .abb.robot.MechanicalUnit mechanical_units = 3;
  int mechanical_units_size() const;
  private:
  int _internal_mechanical_units_size() const;

  public:
  void clear_mechanical_units() ;
  ::abb::robot::MechanicalUnit* mutable_mechanical_units(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnit >*
      mutable_mechanical_units();
  private:
  const ::google::protobuf::RepeatedPtrField<::abb::robot::MechanicalUnit>& _internal_mechanical_units() const;
  ::google::protobuf::RepeatedPtrField<::abb::robot::MechanicalUnit>* _internal_mutable_mechanical_units();
  public:
  const ::abb::robot::MechanicalUnit& mechanical_units(int index) const;
  ::abb::robot::MechanicalUnit* add_mechanical_units();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnit >&
      mechanical_units() const;
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional .abb.robot.MechanicalUnit robot = 2;
  bool has_robot() const;
  void clear_robot() ;
  const ::abb::robot::MechanicalUnit& robot() const;
  PROTOBUF_NODISCARD ::abb::robot::MechanicalUnit* release_robot();
  ::abb::robot::MechanicalUnit* mutable_robot();
  void set_allocated_robot(::abb::robot::MechanicalUnit* value);
  void unsafe_arena_set_allocated_robot(::abb::robot::MechanicalUnit* value);
  ::abb::robot::MechanicalUnit* unsafe_arena_release_robot();

  private:
  const ::abb::robot::MechanicalUnit& _internal_robot() const;
  ::abb::robot::MechanicalUnit* _internal_mutable_robot();

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.MechanicalUnitGroup)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnit > mechanical_units_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::abb::robot::MechanicalUnit* robot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};// -------------------------------------------------------------------

class RobotControllerDescription final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.RobotControllerDescription) */ {
 public:
  inline RobotControllerDescription() : RobotControllerDescription(nullptr) {}
  ~RobotControllerDescription() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RobotControllerDescription(::google::protobuf::internal::ConstantInitialized);

  inline RobotControllerDescription(const RobotControllerDescription& from)
      : RobotControllerDescription(nullptr, from) {}
  RobotControllerDescription(RobotControllerDescription&& from) noexcept
    : RobotControllerDescription() {
    *this = ::std::move(from);
  }

  inline RobotControllerDescription& operator=(const RobotControllerDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotControllerDescription& operator=(RobotControllerDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotControllerDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotControllerDescription* internal_default_instance() {
    return reinterpret_cast<const RobotControllerDescription*>(
               &_RobotControllerDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RobotControllerDescription& a, RobotControllerDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotControllerDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotControllerDescription* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotControllerDescription* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotControllerDescription>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RobotControllerDescription& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RobotControllerDescription& from) {
    RobotControllerDescription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RobotControllerDescription* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.robot.RobotControllerDescription";
  }
  protected:
  explicit RobotControllerDescription(::google::protobuf::Arena* arena);
  RobotControllerDescription(::google::protobuf::Arena* arena, const RobotControllerDescription& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMechanicalUnitsGroupsFieldNumber = 3,
    kRapidTasksFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kSystemIndicatorsFieldNumber = 2,
  };
  // repeated .abb.robot.MechanicalUnitGroup mechanical_units_groups = 3;
  int mechanical_units_groups_size() const;
  private:
  int _internal_mechanical_units_groups_size() const;

  public:
  void clear_mechanical_units_groups() ;
  ::abb::robot::MechanicalUnitGroup* mutable_mechanical_units_groups(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnitGroup >*
      mutable_mechanical_units_groups();
  private:
  const ::google::protobuf::RepeatedPtrField<::abb::robot::MechanicalUnitGroup>& _internal_mechanical_units_groups() const;
  ::google::protobuf::RepeatedPtrField<::abb::robot::MechanicalUnitGroup>* _internal_mutable_mechanical_units_groups();
  public:
  const ::abb::robot::MechanicalUnitGroup& mechanical_units_groups(int index) const;
  ::abb::robot::MechanicalUnitGroup* add_mechanical_units_groups();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnitGroup >&
      mechanical_units_groups() const;
  // repeated .abb.robot.RAPIDTask rapid_tasks = 4;
  int rapid_tasks_size() const;
  private:
  int _internal_rapid_tasks_size() const;

  public:
  void clear_rapid_tasks() ;
  ::abb::robot::RAPIDTask* mutable_rapid_tasks(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDTask >*
      mutable_rapid_tasks();
  private:
  const ::google::protobuf::RepeatedPtrField<::abb::robot::RAPIDTask>& _internal_rapid_tasks() const;
  ::google::protobuf::RepeatedPtrField<::abb::robot::RAPIDTask>* _internal_mutable_rapid_tasks();
  public:
  const ::abb::robot::RAPIDTask& rapid_tasks(int index) const;
  ::abb::robot::RAPIDTask* add_rapid_tasks();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDTask >&
      rapid_tasks() const;
  // optional .abb.robot.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::abb::robot::Header& header() const;
  PROTOBUF_NODISCARD ::abb::robot::Header* release_header();
  ::abb::robot::Header* mutable_header();
  void set_allocated_header(::abb::robot::Header* value);
  void unsafe_arena_set_allocated_header(::abb::robot::Header* value);
  ::abb::robot::Header* unsafe_arena_release_header();

  private:
  const ::abb::robot::Header& _internal_header() const;
  ::abb::robot::Header* _internal_mutable_header();

  public:
  // optional .abb.robot.SystemIndicators system_indicators = 2;
  bool has_system_indicators() const;
  void clear_system_indicators() ;
  const ::abb::robot::SystemIndicators& system_indicators() const;
  PROTOBUF_NODISCARD ::abb::robot::SystemIndicators* release_system_indicators();
  ::abb::robot::SystemIndicators* mutable_system_indicators();
  void set_allocated_system_indicators(::abb::robot::SystemIndicators* value);
  void unsafe_arena_set_allocated_system_indicators(::abb::robot::SystemIndicators* value);
  ::abb::robot::SystemIndicators* unsafe_arena_release_system_indicators();

  private:
  const ::abb::robot::SystemIndicators& _internal_system_indicators() const;
  ::abb::robot::SystemIndicators* _internal_mutable_system_indicators();

  public:
  // @@protoc_insertion_point(class_scope:abb.robot.RobotControllerDescription)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnitGroup > mechanical_units_groups_;
    ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDTask > rapid_tasks_;
    ::abb::robot::Header* header_;
    ::abb::robot::SystemIndicators* system_indicators_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Header

// optional string ip_address = 1;
inline bool Header::has_ip_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Header::clear_ip_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Header::ip_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Header.ip_address)
  return _internal_ip_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header::set_ip_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ip_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.Header.ip_address)
}
inline std::string* Header::mutable_ip_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.ip_address)
  return _s;
}
inline const std::string& Header::_internal_ip_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_address_.Get();
}
inline void Header::_internal_set_ip_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ip_address_.Set(value, GetArena());
}
inline std::string* Header::_internal_mutable_ip_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ip_address_.Mutable( GetArena());
}
inline std::string* Header::release_ip_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Header.ip_address)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ip_address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ip_address_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Header::set_allocated_ip_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ip_address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_address_.IsDefault()) {
          _impl_.ip_address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Header.ip_address)
}

// optional uint32 rws_port_number = 2;
inline bool Header::has_rws_port_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Header::clear_rws_port_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rws_port_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t Header::rws_port_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.Header.rws_port_number)
  return _internal_rws_port_number();
}
inline void Header::set_rws_port_number(::uint32_t value) {
  _internal_set_rws_port_number(value);
  // @@protoc_insertion_point(field_set:abb.robot.Header.rws_port_number)
}
inline ::uint32_t Header::_internal_rws_port_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rws_port_number_;
}
inline void Header::_internal_set_rws_port_number(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rws_port_number_ = value;
}

// optional .abb.robot.RobotWareVersion robot_ware_version = 3;
inline bool Header::has_robot_ware_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ware_version_ != nullptr);
  return value;
}
inline void Header::clear_robot_ware_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.robot_ware_version_ != nullptr) _impl_.robot_ware_version_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::robot::RobotWareVersion& Header::_internal_robot_ware_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::RobotWareVersion* p = _impl_.robot_ware_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::RobotWareVersion&>(::abb::robot::_RobotWareVersion_default_instance_);
}
inline const ::abb::robot::RobotWareVersion& Header::robot_ware_version() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Header.robot_ware_version)
  return _internal_robot_ware_version();
}
inline void Header::unsafe_arena_set_allocated_robot_ware_version(::abb::robot::RobotWareVersion* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.robot_ware_version_);
  }
  _impl_.robot_ware_version_ = reinterpret_cast<::abb::robot::RobotWareVersion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Header.robot_ware_version)
}
inline ::abb::robot::RobotWareVersion* Header::release_robot_ware_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::robot::RobotWareVersion* released = _impl_.robot_ware_version_;
  _impl_.robot_ware_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::RobotWareVersion* Header::unsafe_arena_release_robot_ware_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Header.robot_ware_version)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::robot::RobotWareVersion* temp = _impl_.robot_ware_version_;
  _impl_.robot_ware_version_ = nullptr;
  return temp;
}
inline ::abb::robot::RobotWareVersion* Header::_internal_mutable_robot_ware_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.robot_ware_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::RobotWareVersion>(GetArena());
    _impl_.robot_ware_version_ = reinterpret_cast<::abb::robot::RobotWareVersion*>(p);
  }
  return _impl_.robot_ware_version_;
}
inline ::abb::robot::RobotWareVersion* Header::mutable_robot_ware_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::RobotWareVersion* _msg = _internal_mutable_robot_ware_version();
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.robot_ware_version)
  return _msg;
}
inline void Header::set_allocated_robot_ware_version(::abb::robot::RobotWareVersion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::RobotWareVersion*>(_impl_.robot_ware_version_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::RobotWareVersion*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.robot_ware_version_ = reinterpret_cast<::abb::robot::RobotWareVersion*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Header.robot_ware_version)
}

// optional string system_name = 4;
inline bool Header::has_system_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Header::clear_system_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.system_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Header::system_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Header.system_name)
  return _internal_system_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header::set_system_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.system_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.Header.system_name)
}
inline std::string* Header::mutable_system_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_system_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.system_name)
  return _s;
}
inline const std::string& Header::_internal_system_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.system_name_.Get();
}
inline void Header::_internal_set_system_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.system_name_.Set(value, GetArena());
}
inline std::string* Header::_internal_mutable_system_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.system_name_.Mutable( GetArena());
}
inline std::string* Header::release_system_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Header.system_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.system_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.system_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Header::set_allocated_system_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.system_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.system_name_.IsDefault()) {
          _impl_.system_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Header.system_name)
}

// optional string system_type = 5;
inline bool Header::has_system_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Header::clear_system_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.system_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Header::system_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Header.system_type)
  return _internal_system_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header::set_system_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.system_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.Header.system_type)
}
inline std::string* Header::mutable_system_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_system_type();
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.system_type)
  return _s;
}
inline const std::string& Header::_internal_system_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.system_type_.Get();
}
inline void Header::_internal_set_system_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.system_type_.Set(value, GetArena());
}
inline std::string* Header::_internal_mutable_system_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.system_type_.Mutable( GetArena());
}
inline std::string* Header::release_system_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Header.system_type)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.system_type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.system_type_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Header::set_allocated_system_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.system_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.system_type_.IsDefault()) {
          _impl_.system_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Header.system_type)
}

// repeated string options = 6;
inline int Header::_internal_options_size() const {
  return _internal_options().size();
}
inline int Header::options_size() const {
  return _internal_options_size();
}
inline void Header::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.options_.Clear();
}
inline std::string* Header::add_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_options()->Add();
  // @@protoc_insertion_point(field_add_mutable:abb.robot.Header.options)
  return _s;
}
inline const std::string& Header::options(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Header.options)
  return _internal_options().Get(index);
}
inline std::string* Header::mutable_options(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.options)
  return _internal_mutable_options()->Mutable(index);
}
inline void Header::set_options(int index, const std::string& value) {
  _internal_mutable_options()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:abb.robot.Header.options)
}
inline void Header::set_options(int index, std::string&& value) {
  _internal_mutable_options()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:abb.robot.Header.options)
}
inline void Header::set_options(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_options()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:abb.robot.Header.options)
}
inline void Header::set_options(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_options()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Header.options)
}
inline void Header::set_options(int index, absl::string_view value) {
  _internal_mutable_options()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:abb.robot.Header.options)
}
inline void Header::add_options(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_options()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:abb.robot.Header.options)
}
inline void Header::add_options(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_options()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:abb.robot.Header.options)
}
inline void Header::add_options(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_options()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:abb.robot.Header.options)
}
inline void Header::add_options(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_options()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:abb.robot.Header.options)
}
inline void Header::add_options(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_options()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:abb.robot.Header.options)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Header::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.robot.Header.options)
  return _internal_options();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Header::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.Header.options)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_options();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Header::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.options_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Header::_internal_mutable_options() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.options_;
}

// -------------------------------------------------------------------

// RobotControllerDescription

// optional .abb.robot.Header header = 1;
inline bool RobotControllerDescription::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void RobotControllerDescription::clear_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::robot::Header& RobotControllerDescription::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Header&>(::abb::robot::_Header_default_instance_);
}
inline const ::abb::robot::Header& RobotControllerDescription::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.RobotControllerDescription.header)
  return _internal_header();
}
inline void RobotControllerDescription::unsafe_arena_set_allocated_header(::abb::robot::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::abb::robot::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.RobotControllerDescription.header)
}
inline ::abb::robot::Header* RobotControllerDescription::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::robot::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::Header* RobotControllerDescription::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.RobotControllerDescription.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::robot::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::abb::robot::Header* RobotControllerDescription::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::abb::robot::Header*>(p);
  }
  return _impl_.header_;
}
inline ::abb::robot::Header* RobotControllerDescription::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotControllerDescription.header)
  return _msg;
}
inline void RobotControllerDescription::set_allocated_header(::abb::robot::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::Header*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::Header*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::abb::robot::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RobotControllerDescription.header)
}

// optional .abb.robot.SystemIndicators system_indicators = 2;
inline bool RobotControllerDescription::has_system_indicators() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_indicators_ != nullptr);
  return value;
}
inline void RobotControllerDescription::clear_system_indicators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.system_indicators_ != nullptr) _impl_.system_indicators_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::robot::SystemIndicators& RobotControllerDescription::_internal_system_indicators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::SystemIndicators* p = _impl_.system_indicators_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::SystemIndicators&>(::abb::robot::_SystemIndicators_default_instance_);
}
inline const ::abb::robot::SystemIndicators& RobotControllerDescription::system_indicators() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.RobotControllerDescription.system_indicators)
  return _internal_system_indicators();
}
inline void RobotControllerDescription::unsafe_arena_set_allocated_system_indicators(::abb::robot::SystemIndicators* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.system_indicators_);
  }
  _impl_.system_indicators_ = reinterpret_cast<::abb::robot::SystemIndicators*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.RobotControllerDescription.system_indicators)
}
inline ::abb::robot::SystemIndicators* RobotControllerDescription::release_system_indicators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::SystemIndicators* released = _impl_.system_indicators_;
  _impl_.system_indicators_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::SystemIndicators* RobotControllerDescription::unsafe_arena_release_system_indicators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.RobotControllerDescription.system_indicators)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::SystemIndicators* temp = _impl_.system_indicators_;
  _impl_.system_indicators_ = nullptr;
  return temp;
}
inline ::abb::robot::SystemIndicators* RobotControllerDescription::_internal_mutable_system_indicators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.system_indicators_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::SystemIndicators>(GetArena());
    _impl_.system_indicators_ = reinterpret_cast<::abb::robot::SystemIndicators*>(p);
  }
  return _impl_.system_indicators_;
}
inline ::abb::robot::SystemIndicators* RobotControllerDescription::mutable_system_indicators() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::SystemIndicators* _msg = _internal_mutable_system_indicators();
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotControllerDescription.system_indicators)
  return _msg;
}
inline void RobotControllerDescription::set_allocated_system_indicators(::abb::robot::SystemIndicators* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::SystemIndicators*>(_impl_.system_indicators_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::SystemIndicators*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.system_indicators_ = reinterpret_cast<::abb::robot::SystemIndicators*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RobotControllerDescription.system_indicators)
}

// repeated .abb.robot.MechanicalUnitGroup mechanical_units_groups = 3;
inline int RobotControllerDescription::_internal_mechanical_units_groups_size() const {
  return _internal_mechanical_units_groups().size();
}
inline int RobotControllerDescription::mechanical_units_groups_size() const {
  return _internal_mechanical_units_groups_size();
}
inline void RobotControllerDescription::clear_mechanical_units_groups() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mechanical_units_groups_.Clear();
}
inline ::abb::robot::MechanicalUnitGroup* RobotControllerDescription::mutable_mechanical_units_groups(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return _internal_mutable_mechanical_units_groups()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::MechanicalUnitGroup>* RobotControllerDescription::mutable_mechanical_units_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.RobotControllerDescription.mechanical_units_groups)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_mechanical_units_groups();
}
inline const ::abb::robot::MechanicalUnitGroup& RobotControllerDescription::mechanical_units_groups(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return _internal_mechanical_units_groups().Get(index);
}
inline ::abb::robot::MechanicalUnitGroup* RobotControllerDescription::add_mechanical_units_groups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::abb::robot::MechanicalUnitGroup* _add = _internal_mutable_mechanical_units_groups()->Add();
  // @@protoc_insertion_point(field_add:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::MechanicalUnitGroup>& RobotControllerDescription::mechanical_units_groups() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return _internal_mechanical_units_groups();
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::MechanicalUnitGroup>&
RobotControllerDescription::_internal_mechanical_units_groups() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mechanical_units_groups_;
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::MechanicalUnitGroup>*
RobotControllerDescription::_internal_mutable_mechanical_units_groups() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.mechanical_units_groups_;
}

// repeated .abb.robot.RAPIDTask rapid_tasks = 4;
inline int RobotControllerDescription::_internal_rapid_tasks_size() const {
  return _internal_rapid_tasks().size();
}
inline int RobotControllerDescription::rapid_tasks_size() const {
  return _internal_rapid_tasks_size();
}
inline void RobotControllerDescription::clear_rapid_tasks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rapid_tasks_.Clear();
}
inline ::abb::robot::RAPIDTask* RobotControllerDescription::mutable_rapid_tasks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotControllerDescription.rapid_tasks)
  return _internal_mutable_rapid_tasks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::RAPIDTask>* RobotControllerDescription::mutable_rapid_tasks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.RobotControllerDescription.rapid_tasks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_rapid_tasks();
}
inline const ::abb::robot::RAPIDTask& RobotControllerDescription::rapid_tasks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.RobotControllerDescription.rapid_tasks)
  return _internal_rapid_tasks().Get(index);
}
inline ::abb::robot::RAPIDTask* RobotControllerDescription::add_rapid_tasks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::abb::robot::RAPIDTask* _add = _internal_mutable_rapid_tasks()->Add();
  // @@protoc_insertion_point(field_add:abb.robot.RobotControllerDescription.rapid_tasks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::RAPIDTask>& RobotControllerDescription::rapid_tasks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.robot.RobotControllerDescription.rapid_tasks)
  return _internal_rapid_tasks();
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::RAPIDTask>&
RobotControllerDescription::_internal_rapid_tasks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rapid_tasks_;
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::RAPIDTask>*
RobotControllerDescription::_internal_mutable_rapid_tasks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.rapid_tasks_;
}

// -------------------------------------------------------------------

// RobotWareVersion

// optional string name = 1;
inline bool RobotWareVersion::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RobotWareVersion::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RobotWareVersion::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.RobotWareVersion.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RobotWareVersion::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.RobotWareVersion.name)
}
inline std::string* RobotWareVersion::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotWareVersion.name)
  return _s;
}
inline const std::string& RobotWareVersion::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void RobotWareVersion::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* RobotWareVersion::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* RobotWareVersion::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.RobotWareVersion.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RobotWareVersion::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RobotWareVersion.name)
}

// optional uint32 major_number = 2;
inline bool RobotWareVersion::has_major_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RobotWareVersion::clear_major_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.major_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t RobotWareVersion::major_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotWareVersion.major_number)
  return _internal_major_number();
}
inline void RobotWareVersion::set_major_number(::uint32_t value) {
  _internal_set_major_number(value);
  // @@protoc_insertion_point(field_set:abb.robot.RobotWareVersion.major_number)
}
inline ::uint32_t RobotWareVersion::_internal_major_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.major_number_;
}
inline void RobotWareVersion::_internal_set_major_number(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.major_number_ = value;
}

// optional uint32 minor_number = 3;
inline bool RobotWareVersion::has_minor_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RobotWareVersion::clear_minor_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minor_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t RobotWareVersion::minor_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotWareVersion.minor_number)
  return _internal_minor_number();
}
inline void RobotWareVersion::set_minor_number(::uint32_t value) {
  _internal_set_minor_number(value);
  // @@protoc_insertion_point(field_set:abb.robot.RobotWareVersion.minor_number)
}
inline ::uint32_t RobotWareVersion::_internal_minor_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minor_number_;
}
inline void RobotWareVersion::_internal_set_minor_number(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.minor_number_ = value;
}

// optional uint32 patch_number = 4;
inline bool RobotWareVersion::has_patch_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RobotWareVersion::clear_patch_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.patch_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t RobotWareVersion::patch_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotWareVersion.patch_number)
  return _internal_patch_number();
}
inline void RobotWareVersion::set_patch_number(::uint32_t value) {
  _internal_set_patch_number(value);
  // @@protoc_insertion_point(field_set:abb.robot.RobotWareVersion.patch_number)
}
inline ::uint32_t RobotWareVersion::_internal_patch_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.patch_number_;
}
inline void RobotWareVersion::_internal_set_patch_number(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.patch_number_ = value;
}

// -------------------------------------------------------------------

// Cartesian

// optional double x = 1;
inline bool Cartesian::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Cartesian::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Cartesian::x() const {
  // @@protoc_insertion_point(field_get:abb.robot.Cartesian.x)
  return _internal_x();
}
inline void Cartesian::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.robot.Cartesian.x)
}
inline double Cartesian::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Cartesian::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// optional double y = 2;
inline bool Cartesian::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Cartesian::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Cartesian::y() const {
  // @@protoc_insertion_point(field_get:abb.robot.Cartesian.y)
  return _internal_y();
}
inline void Cartesian::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.robot.Cartesian.y)
}
inline double Cartesian::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Cartesian::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// optional double z = 3;
inline bool Cartesian::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Cartesian::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Cartesian::z() const {
  // @@protoc_insertion_point(field_get:abb.robot.Cartesian.z)
  return _internal_z();
}
inline void Cartesian::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.robot.Cartesian.z)
}
inline double Cartesian::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Cartesian::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Quaternion

// optional double q1 = 1;
inline bool Quaternion::has_q1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Quaternion::clear_q1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.q1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Quaternion::q1() const {
  // @@protoc_insertion_point(field_get:abb.robot.Quaternion.q1)
  return _internal_q1();
}
inline void Quaternion::set_q1(double value) {
  _internal_set_q1(value);
  // @@protoc_insertion_point(field_set:abb.robot.Quaternion.q1)
}
inline double Quaternion::_internal_q1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.q1_;
}
inline void Quaternion::_internal_set_q1(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.q1_ = value;
}

// optional double q2 = 2;
inline bool Quaternion::has_q2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Quaternion::clear_q2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.q2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Quaternion::q2() const {
  // @@protoc_insertion_point(field_get:abb.robot.Quaternion.q2)
  return _internal_q2();
}
inline void Quaternion::set_q2(double value) {
  _internal_set_q2(value);
  // @@protoc_insertion_point(field_set:abb.robot.Quaternion.q2)
}
inline double Quaternion::_internal_q2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.q2_;
}
inline void Quaternion::_internal_set_q2(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.q2_ = value;
}

// optional double q3 = 3;
inline bool Quaternion::has_q3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Quaternion::clear_q3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.q3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Quaternion::q3() const {
  // @@protoc_insertion_point(field_get:abb.robot.Quaternion.q3)
  return _internal_q3();
}
inline void Quaternion::set_q3(double value) {
  _internal_set_q3(value);
  // @@protoc_insertion_point(field_set:abb.robot.Quaternion.q3)
}
inline double Quaternion::_internal_q3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.q3_;
}
inline void Quaternion::_internal_set_q3(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.q3_ = value;
}

// optional double q4 = 4;
inline bool Quaternion::has_q4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Quaternion::clear_q4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.q4_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double Quaternion::q4() const {
  // @@protoc_insertion_point(field_get:abb.robot.Quaternion.q4)
  return _internal_q4();
}
inline void Quaternion::set_q4(double value) {
  _internal_set_q4(value);
  // @@protoc_insertion_point(field_set:abb.robot.Quaternion.q4)
}
inline double Quaternion::_internal_q4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.q4_;
}
inline void Quaternion::_internal_set_q4(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.q4_ = value;
}

// -------------------------------------------------------------------

// Pose

// optional .abb.robot.Cartesian position = 1;
inline bool Pose::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Pose::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::robot::Cartesian& Pose::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::Cartesian* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Cartesian&>(::abb::robot::_Cartesian_default_instance_);
}
inline const ::abb::robot::Cartesian& Pose::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Pose.position)
  return _internal_position();
}
inline void Pose::unsafe_arena_set_allocated_position(::abb::robot::Cartesian* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::abb::robot::Cartesian*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Pose.position)
}
inline ::abb::robot::Cartesian* Pose::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::robot::Cartesian* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::Cartesian* Pose::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Pose.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::robot::Cartesian* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::abb::robot::Cartesian* Pose::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Cartesian>(GetArena());
    _impl_.position_ = reinterpret_cast<::abb::robot::Cartesian*>(p);
  }
  return _impl_.position_;
}
inline ::abb::robot::Cartesian* Pose::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::Cartesian* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:abb.robot.Pose.position)
  return _msg;
}
inline void Pose::set_allocated_position(::abb::robot::Cartesian* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::Cartesian*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::Cartesian*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::abb::robot::Cartesian*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Pose.position)
}

// optional .abb.robot.Quaternion rotation = 2;
inline bool Pose::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void Pose::clear_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::robot::Quaternion& Pose::_internal_rotation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::Quaternion* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Quaternion&>(::abb::robot::_Quaternion_default_instance_);
}
inline const ::abb::robot::Quaternion& Pose::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Pose.rotation)
  return _internal_rotation();
}
inline void Pose::unsafe_arena_set_allocated_rotation(::abb::robot::Quaternion* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::abb::robot::Quaternion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Pose.rotation)
}
inline ::abb::robot::Quaternion* Pose::release_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::Quaternion* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::Quaternion* Pose::unsafe_arena_release_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Pose.rotation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::abb::robot::Quaternion* Pose::_internal_mutable_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Quaternion>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::abb::robot::Quaternion*>(p);
  }
  return _impl_.rotation_;
}
inline ::abb::robot::Quaternion* Pose::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::Quaternion* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:abb.robot.Pose.rotation)
  return _msg;
}
inline void Pose::set_allocated_rotation(::abb::robot::Quaternion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::Quaternion*>(_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::Quaternion*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rotation_ = reinterpret_cast<::abb::robot::Quaternion*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Pose.rotation)
}

// -------------------------------------------------------------------

// RobotIndicators

// optional bool irb14000 = 1;
inline bool RobotIndicators::has_irb14000() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RobotIndicators::clear_irb14000() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.irb14000_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool RobotIndicators::irb14000() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotIndicators.irb14000)
  return _internal_irb14000();
}
inline void RobotIndicators::set_irb14000(bool value) {
  _internal_set_irb14000(value);
  // @@protoc_insertion_point(field_set:abb.robot.RobotIndicators.irb14000)
}
inline bool RobotIndicators::_internal_irb14000() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.irb14000_;
}
inline void RobotIndicators::_internal_set_irb14000(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.irb14000_ = value;
}

// -------------------------------------------------------------------

// OptionIndicators

// optional bool egm = 1;
inline bool OptionIndicators::has_egm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void OptionIndicators::clear_egm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.egm_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool OptionIndicators::egm() const {
  // @@protoc_insertion_point(field_get:abb.robot.OptionIndicators.egm)
  return _internal_egm();
}
inline void OptionIndicators::set_egm(bool value) {
  _internal_set_egm(value);
  // @@protoc_insertion_point(field_set:abb.robot.OptionIndicators.egm)
}
inline bool OptionIndicators::_internal_egm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.egm_;
}
inline void OptionIndicators::_internal_set_egm(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.egm_ = value;
}

// optional bool leadthrough = 2;
inline bool OptionIndicators::has_leadthrough() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void OptionIndicators::clear_leadthrough() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leadthrough_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool OptionIndicators::leadthrough() const {
  // @@protoc_insertion_point(field_get:abb.robot.OptionIndicators.leadthrough)
  return _internal_leadthrough();
}
inline void OptionIndicators::set_leadthrough(bool value) {
  _internal_set_leadthrough(value);
  // @@protoc_insertion_point(field_set:abb.robot.OptionIndicators.leadthrough)
}
inline bool OptionIndicators::_internal_leadthrough() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leadthrough_;
}
inline void OptionIndicators::_internal_set_leadthrough(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.leadthrough_ = value;
}

// optional bool multimove = 3;
inline bool OptionIndicators::has_multimove() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void OptionIndicators::clear_multimove() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.multimove_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool OptionIndicators::multimove() const {
  // @@protoc_insertion_point(field_get:abb.robot.OptionIndicators.multimove)
  return _internal_multimove();
}
inline void OptionIndicators::set_multimove(bool value) {
  _internal_set_multimove(value);
  // @@protoc_insertion_point(field_set:abb.robot.OptionIndicators.multimove)
}
inline bool OptionIndicators::_internal_multimove() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.multimove_;
}
inline void OptionIndicators::_internal_set_multimove(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.multimove_ = value;
}

// -------------------------------------------------------------------

// AddInIndicators

// optional bool smart_gripper = 1;
inline bool AddInIndicators::has_smart_gripper() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AddInIndicators::clear_smart_gripper() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.smart_gripper_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool AddInIndicators::smart_gripper() const {
  // @@protoc_insertion_point(field_get:abb.robot.AddInIndicators.smart_gripper)
  return _internal_smart_gripper();
}
inline void AddInIndicators::set_smart_gripper(bool value) {
  _internal_set_smart_gripper(value);
  // @@protoc_insertion_point(field_set:abb.robot.AddInIndicators.smart_gripper)
}
inline bool AddInIndicators::_internal_smart_gripper() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.smart_gripper_;
}
inline void AddInIndicators::_internal_set_smart_gripper(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.smart_gripper_ = value;
}

// optional bool state_machine_1_0 = 2;
inline bool AddInIndicators::has_state_machine_1_0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AddInIndicators::clear_state_machine_1_0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_machine_1_0_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool AddInIndicators::state_machine_1_0() const {
  // @@protoc_insertion_point(field_get:abb.robot.AddInIndicators.state_machine_1_0)
  return _internal_state_machine_1_0();
}
inline void AddInIndicators::set_state_machine_1_0(bool value) {
  _internal_set_state_machine_1_0(value);
  // @@protoc_insertion_point(field_set:abb.robot.AddInIndicators.state_machine_1_0)
}
inline bool AddInIndicators::_internal_state_machine_1_0() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_machine_1_0_;
}
inline void AddInIndicators::_internal_set_state_machine_1_0(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_machine_1_0_ = value;
}

// optional bool state_machine_1_1 = 3;
inline bool AddInIndicators::has_state_machine_1_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AddInIndicators::clear_state_machine_1_1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_machine_1_1_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool AddInIndicators::state_machine_1_1() const {
  // @@protoc_insertion_point(field_get:abb.robot.AddInIndicators.state_machine_1_1)
  return _internal_state_machine_1_1();
}
inline void AddInIndicators::set_state_machine_1_1(bool value) {
  _internal_set_state_machine_1_1(value);
  // @@protoc_insertion_point(field_set:abb.robot.AddInIndicators.state_machine_1_1)
}
inline bool AddInIndicators::_internal_state_machine_1_1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_machine_1_1_;
}
inline void AddInIndicators::_internal_set_state_machine_1_1(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.state_machine_1_1_ = value;
}

// -------------------------------------------------------------------

// SystemIndicators

// optional .abb.robot.RobotIndicators robots = 1;
inline bool SystemIndicators::has_robots() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robots_ != nullptr);
  return value;
}
inline void SystemIndicators::clear_robots() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.robots_ != nullptr) _impl_.robots_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::robot::RobotIndicators& SystemIndicators::_internal_robots() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::RobotIndicators* p = _impl_.robots_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::RobotIndicators&>(::abb::robot::_RobotIndicators_default_instance_);
}
inline const ::abb::robot::RobotIndicators& SystemIndicators::robots() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.SystemIndicators.robots)
  return _internal_robots();
}
inline void SystemIndicators::unsafe_arena_set_allocated_robots(::abb::robot::RobotIndicators* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.robots_);
  }
  _impl_.robots_ = reinterpret_cast<::abb::robot::RobotIndicators*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.SystemIndicators.robots)
}
inline ::abb::robot::RobotIndicators* SystemIndicators::release_robots() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::robot::RobotIndicators* released = _impl_.robots_;
  _impl_.robots_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::RobotIndicators* SystemIndicators::unsafe_arena_release_robots() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.SystemIndicators.robots)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::robot::RobotIndicators* temp = _impl_.robots_;
  _impl_.robots_ = nullptr;
  return temp;
}
inline ::abb::robot::RobotIndicators* SystemIndicators::_internal_mutable_robots() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.robots_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::RobotIndicators>(GetArena());
    _impl_.robots_ = reinterpret_cast<::abb::robot::RobotIndicators*>(p);
  }
  return _impl_.robots_;
}
inline ::abb::robot::RobotIndicators* SystemIndicators::mutable_robots() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::RobotIndicators* _msg = _internal_mutable_robots();
  // @@protoc_insertion_point(field_mutable:abb.robot.SystemIndicators.robots)
  return _msg;
}
inline void SystemIndicators::set_allocated_robots(::abb::robot::RobotIndicators* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::RobotIndicators*>(_impl_.robots_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::RobotIndicators*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.robots_ = reinterpret_cast<::abb::robot::RobotIndicators*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.SystemIndicators.robots)
}

// optional .abb.robot.OptionIndicators options = 2;
inline bool SystemIndicators::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline void SystemIndicators::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::robot::OptionIndicators& SystemIndicators::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::OptionIndicators* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::OptionIndicators&>(::abb::robot::_OptionIndicators_default_instance_);
}
inline const ::abb::robot::OptionIndicators& SystemIndicators::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.SystemIndicators.options)
  return _internal_options();
}
inline void SystemIndicators::unsafe_arena_set_allocated_options(::abb::robot::OptionIndicators* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::abb::robot::OptionIndicators*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.SystemIndicators.options)
}
inline ::abb::robot::OptionIndicators* SystemIndicators::release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::OptionIndicators* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::OptionIndicators* SystemIndicators::unsafe_arena_release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.SystemIndicators.options)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::OptionIndicators* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::abb::robot::OptionIndicators* SystemIndicators::_internal_mutable_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::OptionIndicators>(GetArena());
    _impl_.options_ = reinterpret_cast<::abb::robot::OptionIndicators*>(p);
  }
  return _impl_.options_;
}
inline ::abb::robot::OptionIndicators* SystemIndicators::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::OptionIndicators* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:abb.robot.SystemIndicators.options)
  return _msg;
}
inline void SystemIndicators::set_allocated_options(::abb::robot::OptionIndicators* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::OptionIndicators*>(_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::OptionIndicators*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.options_ = reinterpret_cast<::abb::robot::OptionIndicators*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.SystemIndicators.options)
}

// optional .abb.robot.AddInIndicators addins = 3;
inline bool SystemIndicators::has_addins() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.addins_ != nullptr);
  return value;
}
inline void SystemIndicators::clear_addins() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.addins_ != nullptr) _impl_.addins_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::robot::AddInIndicators& SystemIndicators::_internal_addins() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::AddInIndicators* p = _impl_.addins_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::AddInIndicators&>(::abb::robot::_AddInIndicators_default_instance_);
}
inline const ::abb::robot::AddInIndicators& SystemIndicators::addins() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.SystemIndicators.addins)
  return _internal_addins();
}
inline void SystemIndicators::unsafe_arena_set_allocated_addins(::abb::robot::AddInIndicators* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.addins_);
  }
  _impl_.addins_ = reinterpret_cast<::abb::robot::AddInIndicators*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.SystemIndicators.addins)
}
inline ::abb::robot::AddInIndicators* SystemIndicators::release_addins() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::robot::AddInIndicators* released = _impl_.addins_;
  _impl_.addins_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::AddInIndicators* SystemIndicators::unsafe_arena_release_addins() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.SystemIndicators.addins)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::robot::AddInIndicators* temp = _impl_.addins_;
  _impl_.addins_ = nullptr;
  return temp;
}
inline ::abb::robot::AddInIndicators* SystemIndicators::_internal_mutable_addins() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.addins_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::AddInIndicators>(GetArena());
    _impl_.addins_ = reinterpret_cast<::abb::robot::AddInIndicators*>(p);
  }
  return _impl_.addins_;
}
inline ::abb::robot::AddInIndicators* SystemIndicators::mutable_addins() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::AddInIndicators* _msg = _internal_mutable_addins();
  // @@protoc_insertion_point(field_mutable:abb.robot.SystemIndicators.addins)
  return _msg;
}
inline void SystemIndicators::set_allocated_addins(::abb::robot::AddInIndicators* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::AddInIndicators*>(_impl_.addins_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::AddInIndicators*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.addins_ = reinterpret_cast<::abb::robot::AddInIndicators*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.SystemIndicators.addins)
}

// -------------------------------------------------------------------

// Transmission

// optional string name = 1;
inline bool Transmission::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Transmission::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Transmission::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Transmission.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Transmission::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.Transmission.name)
}
inline std::string* Transmission::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Transmission.name)
  return _s;
}
inline const std::string& Transmission::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Transmission::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Transmission::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Transmission::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Transmission.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Transmission::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Transmission.name)
}

// optional bool rotating_move = 2;
inline bool Transmission::has_rotating_move() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Transmission::clear_rotating_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rotating_move_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool Transmission::rotating_move() const {
  // @@protoc_insertion_point(field_get:abb.robot.Transmission.rotating_move)
  return _internal_rotating_move();
}
inline void Transmission::set_rotating_move(bool value) {
  _internal_set_rotating_move(value);
  // @@protoc_insertion_point(field_set:abb.robot.Transmission.rotating_move)
}
inline bool Transmission::_internal_rotating_move() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rotating_move_;
}
inline void Transmission::_internal_set_rotating_move(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rotating_move_ = value;
}

// -------------------------------------------------------------------

// Arm

// optional string name = 1;
inline bool Arm::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Arm::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Arm::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Arm.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Arm::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.Arm.name)
}
inline std::string* Arm::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Arm.name)
  return _s;
}
inline const std::string& Arm::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Arm::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Arm::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Arm::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Arm.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Arm::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Arm.name)
}

// optional double lower_joint_bound = 2;
inline bool Arm::has_lower_joint_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Arm::clear_lower_joint_bound() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lower_joint_bound_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Arm::lower_joint_bound() const {
  // @@protoc_insertion_point(field_get:abb.robot.Arm.lower_joint_bound)
  return _internal_lower_joint_bound();
}
inline void Arm::set_lower_joint_bound(double value) {
  _internal_set_lower_joint_bound(value);
  // @@protoc_insertion_point(field_set:abb.robot.Arm.lower_joint_bound)
}
inline double Arm::_internal_lower_joint_bound() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lower_joint_bound_;
}
inline void Arm::_internal_set_lower_joint_bound(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.lower_joint_bound_ = value;
}

// optional double upper_joint_bound = 3;
inline bool Arm::has_upper_joint_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Arm::clear_upper_joint_bound() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.upper_joint_bound_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Arm::upper_joint_bound() const {
  // @@protoc_insertion_point(field_get:abb.robot.Arm.upper_joint_bound)
  return _internal_upper_joint_bound();
}
inline void Arm::set_upper_joint_bound(double value) {
  _internal_set_upper_joint_bound(value);
  // @@protoc_insertion_point(field_set:abb.robot.Arm.upper_joint_bound)
}
inline double Arm::_internal_upper_joint_bound() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.upper_joint_bound_;
}
inline void Arm::_internal_set_upper_joint_bound(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.upper_joint_bound_ = value;
}

// -------------------------------------------------------------------

// Joint

// optional string name = 1;
inline bool Joint::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Joint::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Joint::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Joint.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Joint::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.Joint.name)
}
inline std::string* Joint::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Joint.name)
  return _s;
}
inline const std::string& Joint::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Joint::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Joint::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Joint::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Joint.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Joint::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Joint.name)
}

// optional int32 logical_axis = 2;
inline bool Joint::has_logical_axis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Joint::clear_logical_axis() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.logical_axis_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t Joint::logical_axis() const {
  // @@protoc_insertion_point(field_get:abb.robot.Joint.logical_axis)
  return _internal_logical_axis();
}
inline void Joint::set_logical_axis(::int32_t value) {
  _internal_set_logical_axis(value);
  // @@protoc_insertion_point(field_set:abb.robot.Joint.logical_axis)
}
inline ::int32_t Joint::_internal_logical_axis() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.logical_axis_;
}
inline void Joint::_internal_set_logical_axis(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.logical_axis_ = value;
}

// optional int32 kinematic_axis_number = 3;
inline bool Joint::has_kinematic_axis_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Joint::clear_kinematic_axis_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kinematic_axis_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t Joint::kinematic_axis_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.Joint.kinematic_axis_number)
  return _internal_kinematic_axis_number();
}
inline void Joint::set_kinematic_axis_number(::int32_t value) {
  _internal_set_kinematic_axis_number(value);
  // @@protoc_insertion_point(field_set:abb.robot.Joint.kinematic_axis_number)
}
inline ::int32_t Joint::_internal_kinematic_axis_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kinematic_axis_number_;
}
inline void Joint::_internal_set_kinematic_axis_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.kinematic_axis_number_ = value;
}

// optional .abb.robot.Arm arm = 4;
inline bool Joint::has_arm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arm_ != nullptr);
  return value;
}
inline void Joint::clear_arm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.arm_ != nullptr) _impl_.arm_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::robot::Arm& Joint::_internal_arm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::Arm* p = _impl_.arm_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Arm&>(::abb::robot::_Arm_default_instance_);
}
inline const ::abb::robot::Arm& Joint::arm() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Joint.arm)
  return _internal_arm();
}
inline void Joint::unsafe_arena_set_allocated_arm(::abb::robot::Arm* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arm_);
  }
  _impl_.arm_ = reinterpret_cast<::abb::robot::Arm*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Joint.arm)
}
inline ::abb::robot::Arm* Joint::release_arm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::Arm* released = _impl_.arm_;
  _impl_.arm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::Arm* Joint::unsafe_arena_release_arm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Joint.arm)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::Arm* temp = _impl_.arm_;
  _impl_.arm_ = nullptr;
  return temp;
}
inline ::abb::robot::Arm* Joint::_internal_mutable_arm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.arm_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Arm>(GetArena());
    _impl_.arm_ = reinterpret_cast<::abb::robot::Arm*>(p);
  }
  return _impl_.arm_;
}
inline ::abb::robot::Arm* Joint::mutable_arm() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::Arm* _msg = _internal_mutable_arm();
  // @@protoc_insertion_point(field_mutable:abb.robot.Joint.arm)
  return _msg;
}
inline void Joint::set_allocated_arm(::abb::robot::Arm* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::Arm*>(_impl_.arm_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::Arm*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.arm_ = reinterpret_cast<::abb::robot::Arm*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Joint.arm)
}

// optional .abb.robot.Transmission transmission = 5;
inline bool Joint::has_transmission() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transmission_ != nullptr);
  return value;
}
inline void Joint::clear_transmission() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transmission_ != nullptr) _impl_.transmission_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::robot::Transmission& Joint::_internal_transmission() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::Transmission* p = _impl_.transmission_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Transmission&>(::abb::robot::_Transmission_default_instance_);
}
inline const ::abb::robot::Transmission& Joint::transmission() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Joint.transmission)
  return _internal_transmission();
}
inline void Joint::unsafe_arena_set_allocated_transmission(::abb::robot::Transmission* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transmission_);
  }
  _impl_.transmission_ = reinterpret_cast<::abb::robot::Transmission*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Joint.transmission)
}
inline ::abb::robot::Transmission* Joint::release_transmission() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::robot::Transmission* released = _impl_.transmission_;
  _impl_.transmission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::Transmission* Joint::unsafe_arena_release_transmission() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Joint.transmission)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::robot::Transmission* temp = _impl_.transmission_;
  _impl_.transmission_ = nullptr;
  return temp;
}
inline ::abb::robot::Transmission* Joint::_internal_mutable_transmission() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.transmission_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Transmission>(GetArena());
    _impl_.transmission_ = reinterpret_cast<::abb::robot::Transmission*>(p);
  }
  return _impl_.transmission_;
}
inline ::abb::robot::Transmission* Joint::mutable_transmission() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::Transmission* _msg = _internal_mutable_transmission();
  // @@protoc_insertion_point(field_mutable:abb.robot.Joint.transmission)
  return _msg;
}
inline void Joint::set_allocated_transmission(::abb::robot::Transmission* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::Transmission*>(_impl_.transmission_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::Transmission*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.transmission_ = reinterpret_cast<::abb::robot::Transmission*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Joint.transmission)
}

// -------------------------------------------------------------------

// StandardizedJoint

// optional string original_name = 1;
inline bool StandardizedJoint::has_original_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StandardizedJoint::clear_original_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.original_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StandardizedJoint::original_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.original_name)
  return _internal_original_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StandardizedJoint::set_original_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.original_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.original_name)
}
inline std::string* StandardizedJoint::mutable_original_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_original_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.StandardizedJoint.original_name)
  return _s;
}
inline const std::string& StandardizedJoint::_internal_original_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.original_name_.Get();
}
inline void StandardizedJoint::_internal_set_original_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.original_name_.Set(value, GetArena());
}
inline std::string* StandardizedJoint::_internal_mutable_original_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.original_name_.Mutable( GetArena());
}
inline std::string* StandardizedJoint::release_original_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.StandardizedJoint.original_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.original_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.original_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StandardizedJoint::set_allocated_original_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.original_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.original_name_.IsDefault()) {
          _impl_.original_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.StandardizedJoint.original_name)
}

// optional string standardized_name = 2;
inline bool StandardizedJoint::has_standardized_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StandardizedJoint::clear_standardized_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.standardized_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StandardizedJoint::standardized_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.standardized_name)
  return _internal_standardized_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StandardizedJoint::set_standardized_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.standardized_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.standardized_name)
}
inline std::string* StandardizedJoint::mutable_standardized_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_standardized_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.StandardizedJoint.standardized_name)
  return _s;
}
inline const std::string& StandardizedJoint::_internal_standardized_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.standardized_name_.Get();
}
inline void StandardizedJoint::_internal_set_standardized_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.standardized_name_.Set(value, GetArena());
}
inline std::string* StandardizedJoint::_internal_mutable_standardized_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.standardized_name_.Mutable( GetArena());
}
inline std::string* StandardizedJoint::release_standardized_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.StandardizedJoint.standardized_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.standardized_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.standardized_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StandardizedJoint::set_allocated_standardized_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.standardized_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.standardized_name_.IsDefault()) {
          _impl_.standardized_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.StandardizedJoint.standardized_name)
}

// optional bool rotating_move = 3;
inline bool StandardizedJoint::has_rotating_move() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void StandardizedJoint::clear_rotating_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rotating_move_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool StandardizedJoint::rotating_move() const {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.rotating_move)
  return _internal_rotating_move();
}
inline void StandardizedJoint::set_rotating_move(bool value) {
  _internal_set_rotating_move(value);
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.rotating_move)
}
inline bool StandardizedJoint::_internal_rotating_move() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rotating_move_;
}
inline void StandardizedJoint::_internal_set_rotating_move(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rotating_move_ = value;
}

// optional double lower_joint_bound = 4;
inline bool StandardizedJoint::has_lower_joint_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StandardizedJoint::clear_lower_joint_bound() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lower_joint_bound_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double StandardizedJoint::lower_joint_bound() const {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.lower_joint_bound)
  return _internal_lower_joint_bound();
}
inline void StandardizedJoint::set_lower_joint_bound(double value) {
  _internal_set_lower_joint_bound(value);
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.lower_joint_bound)
}
inline double StandardizedJoint::_internal_lower_joint_bound() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lower_joint_bound_;
}
inline void StandardizedJoint::_internal_set_lower_joint_bound(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.lower_joint_bound_ = value;
}

// optional double upper_joint_bound = 5;
inline bool StandardizedJoint::has_upper_joint_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void StandardizedJoint::clear_upper_joint_bound() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.upper_joint_bound_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double StandardizedJoint::upper_joint_bound() const {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.upper_joint_bound)
  return _internal_upper_joint_bound();
}
inline void StandardizedJoint::set_upper_joint_bound(double value) {
  _internal_set_upper_joint_bound(value);
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.upper_joint_bound)
}
inline double StandardizedJoint::_internal_upper_joint_bound() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.upper_joint_bound_;
}
inline void StandardizedJoint::_internal_set_upper_joint_bound(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.upper_joint_bound_ = value;
}

// -------------------------------------------------------------------

// Single

// optional string name = 1;
inline bool Single::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Single::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Single::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Single.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Single::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.Single.name)
}
inline std::string* Single::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.name)
  return _s;
}
inline const std::string& Single::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Single::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Single::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Single::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Single.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Single::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.name)
}

// optional string type = 2;
inline bool Single::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Single::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Single::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Single.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Single::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.Single.type)
}
inline std::string* Single::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.type)
  return _s;
}
inline const std::string& Single::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void Single::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Single::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Single::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Single.type)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Single::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.type)
}

// optional .abb.robot.Joint joint = 3;
inline bool Single::has_joint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joint_ != nullptr);
  return value;
}
inline void Single::clear_joint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.joint_ != nullptr) _impl_.joint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::robot::Joint& Single::_internal_joint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::Joint* p = _impl_.joint_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Joint&>(::abb::robot::_Joint_default_instance_);
}
inline const ::abb::robot::Joint& Single::joint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Single.joint)
  return _internal_joint();
}
inline void Single::unsafe_arena_set_allocated_joint(::abb::robot::Joint* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joint_);
  }
  _impl_.joint_ = reinterpret_cast<::abb::robot::Joint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Single.joint)
}
inline ::abb::robot::Joint* Single::release_joint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::robot::Joint* released = _impl_.joint_;
  _impl_.joint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::Joint* Single::unsafe_arena_release_joint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Single.joint)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::robot::Joint* temp = _impl_.joint_;
  _impl_.joint_ = nullptr;
  return temp;
}
inline ::abb::robot::Joint* Single::_internal_mutable_joint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.joint_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Joint>(GetArena());
    _impl_.joint_ = reinterpret_cast<::abb::robot::Joint*>(p);
  }
  return _impl_.joint_;
}
inline ::abb::robot::Joint* Single::mutable_joint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::Joint* _msg = _internal_mutable_joint();
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.joint)
  return _msg;
}
inline void Single::set_allocated_joint(::abb::robot::Joint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::Joint*>(_impl_.joint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::Joint*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.joint_ = reinterpret_cast<::abb::robot::Joint*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.joint)
}

// optional .abb.robot.Pose base_frame = 4;
inline bool Single::has_base_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_frame_ != nullptr);
  return value;
}
inline void Single::clear_base_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.base_frame_ != nullptr) _impl_.base_frame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::abb::robot::Pose& Single::_internal_base_frame() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::Pose* p = _impl_.base_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Pose&>(::abb::robot::_Pose_default_instance_);
}
inline const ::abb::robot::Pose& Single::base_frame() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Single.base_frame)
  return _internal_base_frame();
}
inline void Single::unsafe_arena_set_allocated_base_frame(::abb::robot::Pose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_frame_);
  }
  _impl_.base_frame_ = reinterpret_cast<::abb::robot::Pose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Single.base_frame)
}
inline ::abb::robot::Pose* Single::release_base_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::abb::robot::Pose* released = _impl_.base_frame_;
  _impl_.base_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::Pose* Single::unsafe_arena_release_base_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Single.base_frame)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::abb::robot::Pose* temp = _impl_.base_frame_;
  _impl_.base_frame_ = nullptr;
  return temp;
}
inline ::abb::robot::Pose* Single::_internal_mutable_base_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.base_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Pose>(GetArena());
    _impl_.base_frame_ = reinterpret_cast<::abb::robot::Pose*>(p);
  }
  return _impl_.base_frame_;
}
inline ::abb::robot::Pose* Single::mutable_base_frame() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::Pose* _msg = _internal_mutable_base_frame();
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.base_frame)
  return _msg;
}
inline void Single::set_allocated_base_frame(::abb::robot::Pose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::Pose*>(_impl_.base_frame_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::Pose*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.base_frame_ = reinterpret_cast<::abb::robot::Pose*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.base_frame)
}

// optional string base_frame_moved_by = 5;
inline bool Single::has_base_frame_moved_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Single::clear_base_frame_moved_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.base_frame_moved_by_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Single::base_frame_moved_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Single.base_frame_moved_by)
  return _internal_base_frame_moved_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Single::set_base_frame_moved_by(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.base_frame_moved_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.Single.base_frame_moved_by)
}
inline std::string* Single::mutable_base_frame_moved_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_base_frame_moved_by();
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.base_frame_moved_by)
  return _s;
}
inline const std::string& Single::_internal_base_frame_moved_by() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.base_frame_moved_by_.Get();
}
inline void Single::_internal_set_base_frame_moved_by(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.base_frame_moved_by_.Set(value, GetArena());
}
inline std::string* Single::_internal_mutable_base_frame_moved_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.base_frame_moved_by_.Mutable( GetArena());
}
inline std::string* Single::release_base_frame_moved_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Single.base_frame_moved_by)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.base_frame_moved_by_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_frame_moved_by_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Single::set_allocated_base_frame_moved_by(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.base_frame_moved_by_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.base_frame_moved_by_.IsDefault()) {
          _impl_.base_frame_moved_by_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.base_frame_moved_by)
}

// -------------------------------------------------------------------

// Robot

// optional string name = 1;
inline bool Robot::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Robot::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Robot::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Robot::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.Robot.name)
}
inline std::string* Robot::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.name)
  return _s;
}
inline const std::string& Robot::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Robot::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Robot::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Robot::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Robot.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Robot::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Robot.name)
}

// optional string type = 2;
inline bool Robot::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Robot::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Robot::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Robot::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.Robot.type)
}
inline std::string* Robot::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.type)
  return _s;
}
inline const std::string& Robot::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void Robot::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Robot::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Robot::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Robot.type)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Robot::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Robot.type)
}

// repeated .abb.robot.Joint joints = 3;
inline int Robot::_internal_joints_size() const {
  return _internal_joints().size();
}
inline int Robot::joints_size() const {
  return _internal_joints_size();
}
inline void Robot::clear_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.joints_.Clear();
}
inline ::abb::robot::Joint* Robot::mutable_joints(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.joints)
  return _internal_mutable_joints()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::Joint>* Robot::mutable_joints()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.Robot.joints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_joints();
}
inline const ::abb::robot::Joint& Robot::joints(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.joints)
  return _internal_joints().Get(index);
}
inline ::abb::robot::Joint* Robot::add_joints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::abb::robot::Joint* _add = _internal_mutable_joints()->Add();
  // @@protoc_insertion_point(field_add:abb.robot.Robot.joints)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::Joint>& Robot::joints() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.robot.Robot.joints)
  return _internal_joints();
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::Joint>&
Robot::_internal_joints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.joints_;
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::Joint>*
Robot::_internal_mutable_joints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.joints_;
}

// optional .abb.robot.Pose base_frame = 4;
inline bool Robot::has_base_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_frame_ != nullptr);
  return value;
}
inline void Robot::clear_base_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.base_frame_ != nullptr) _impl_.base_frame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::robot::Pose& Robot::_internal_base_frame() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::Pose* p = _impl_.base_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Pose&>(::abb::robot::_Pose_default_instance_);
}
inline const ::abb::robot::Pose& Robot::base_frame() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.base_frame)
  return _internal_base_frame();
}
inline void Robot::unsafe_arena_set_allocated_base_frame(::abb::robot::Pose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_frame_);
  }
  _impl_.base_frame_ = reinterpret_cast<::abb::robot::Pose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Robot.base_frame)
}
inline ::abb::robot::Pose* Robot::release_base_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::robot::Pose* released = _impl_.base_frame_;
  _impl_.base_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::Pose* Robot::unsafe_arena_release_base_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Robot.base_frame)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::robot::Pose* temp = _impl_.base_frame_;
  _impl_.base_frame_ = nullptr;
  return temp;
}
inline ::abb::robot::Pose* Robot::_internal_mutable_base_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.base_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Pose>(GetArena());
    _impl_.base_frame_ = reinterpret_cast<::abb::robot::Pose*>(p);
  }
  return _impl_.base_frame_;
}
inline ::abb::robot::Pose* Robot::mutable_base_frame() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::Pose* _msg = _internal_mutable_base_frame();
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.base_frame)
  return _msg;
}
inline void Robot::set_allocated_base_frame(::abb::robot::Pose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::Pose*>(_impl_.base_frame_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::Pose*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.base_frame_ = reinterpret_cast<::abb::robot::Pose*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Robot.base_frame)
}

// optional string base_frame_moved_by = 5;
inline bool Robot::has_base_frame_moved_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Robot::clear_base_frame_moved_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.base_frame_moved_by_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Robot::base_frame_moved_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.base_frame_moved_by)
  return _internal_base_frame_moved_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Robot::set_base_frame_moved_by(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.base_frame_moved_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.Robot.base_frame_moved_by)
}
inline std::string* Robot::mutable_base_frame_moved_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_base_frame_moved_by();
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.base_frame_moved_by)
  return _s;
}
inline const std::string& Robot::_internal_base_frame_moved_by() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.base_frame_moved_by_.Get();
}
inline void Robot::_internal_set_base_frame_moved_by(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.base_frame_moved_by_.Set(value, GetArena());
}
inline std::string* Robot::_internal_mutable_base_frame_moved_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.base_frame_moved_by_.Mutable( GetArena());
}
inline std::string* Robot::release_base_frame_moved_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.Robot.base_frame_moved_by)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.base_frame_moved_by_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_frame_moved_by_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Robot::set_allocated_base_frame_moved_by(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.base_frame_moved_by_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.base_frame_moved_by_.IsDefault()) {
          _impl_.base_frame_moved_by_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Robot.base_frame_moved_by)
}

// -------------------------------------------------------------------

// MechanicalUnit

// optional string name = 1;
inline bool MechanicalUnit::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MechanicalUnit::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MechanicalUnit::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MechanicalUnit::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.name)
}
inline std::string* MechanicalUnit::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.name)
  return _s;
}
inline const std::string& MechanicalUnit::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void MechanicalUnit::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* MechanicalUnit::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* MechanicalUnit::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MechanicalUnit::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.name)
}

// optional .abb.robot.Robot robot = 2;
inline bool MechanicalUnit::has_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ != nullptr);
  return value;
}
inline void MechanicalUnit::clear_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.robot_ != nullptr) _impl_.robot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::abb::robot::Robot& MechanicalUnit::_internal_robot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::Robot* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Robot&>(::abb::robot::_Robot_default_instance_);
}
inline const ::abb::robot::Robot& MechanicalUnit::robot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.robot)
  return _internal_robot();
}
inline void MechanicalUnit::unsafe_arena_set_allocated_robot(::abb::robot::Robot* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = reinterpret_cast<::abb::robot::Robot*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.MechanicalUnit.robot)
}
inline ::abb::robot::Robot* MechanicalUnit::release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::abb::robot::Robot* released = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::Robot* MechanicalUnit::unsafe_arena_release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.robot)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::abb::robot::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::abb::robot::Robot* MechanicalUnit::_internal_mutable_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Robot>(GetArena());
    _impl_.robot_ = reinterpret_cast<::abb::robot::Robot*>(p);
  }
  return _impl_.robot_;
}
inline ::abb::robot::Robot* MechanicalUnit::mutable_robot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.robot)
  return _msg;
}
inline void MechanicalUnit::set_allocated_robot(::abb::robot::Robot* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::Robot*>(_impl_.robot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::Robot*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.robot_ = reinterpret_cast<::abb::robot::Robot*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.robot)
}

// repeated .abb.robot.Single singles = 3;
inline int MechanicalUnit::_internal_singles_size() const {
  return _internal_singles().size();
}
inline int MechanicalUnit::singles_size() const {
  return _internal_singles_size();
}
inline void MechanicalUnit::clear_singles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.singles_.Clear();
}
inline ::abb::robot::Single* MechanicalUnit::mutable_singles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.singles)
  return _internal_mutable_singles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::Single>* MechanicalUnit::mutable_singles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.MechanicalUnit.singles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_singles();
}
inline const ::abb::robot::Single& MechanicalUnit::singles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.singles)
  return _internal_singles().Get(index);
}
inline ::abb::robot::Single* MechanicalUnit::add_singles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::abb::robot::Single* _add = _internal_mutable_singles()->Add();
  // @@protoc_insertion_point(field_add:abb.robot.MechanicalUnit.singles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::Single>& MechanicalUnit::singles() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.robot.MechanicalUnit.singles)
  return _internal_singles();
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::Single>&
MechanicalUnit::_internal_singles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.singles_;
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::Single>*
MechanicalUnit::_internal_mutable_singles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.singles_;
}

// optional .abb.robot.MechanicalUnit.Type type = 4 [default = UNDEFINED];
inline bool MechanicalUnit::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void MechanicalUnit::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::abb::robot::MechanicalUnit_Type MechanicalUnit::type() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.type)
  return _internal_type();
}
inline void MechanicalUnit::set_type(::abb::robot::MechanicalUnit_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.type)
}
inline ::abb::robot::MechanicalUnit_Type MechanicalUnit::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::robot::MechanicalUnit_Type>(_impl_.type_);
}
inline void MechanicalUnit::_internal_set_type(::abb::robot::MechanicalUnit_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::robot::MechanicalUnit_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.type_ = value;
}

// optional string task_name = 5;
inline bool MechanicalUnit::has_task_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MechanicalUnit::clear_task_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MechanicalUnit::task_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.task_name)
  return _internal_task_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MechanicalUnit::set_task_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.task_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.task_name)
}
inline std::string* MechanicalUnit::mutable_task_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.task_name)
  return _s;
}
inline const std::string& MechanicalUnit::_internal_task_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_name_.Get();
}
inline void MechanicalUnit::_internal_set_task_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.task_name_.Set(value, GetArena());
}
inline std::string* MechanicalUnit::_internal_mutable_task_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.task_name_.Mutable( GetArena());
}
inline std::string* MechanicalUnit::release_task_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.task_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.task_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.task_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MechanicalUnit::set_allocated_task_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.task_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.task_name_.IsDefault()) {
          _impl_.task_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.task_name)
}

// optional int32 axes = 6;
inline bool MechanicalUnit::has_axes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void MechanicalUnit::clear_axes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.axes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t MechanicalUnit::axes() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.axes)
  return _internal_axes();
}
inline void MechanicalUnit::set_axes(::int32_t value) {
  _internal_set_axes(value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.axes)
}
inline ::int32_t MechanicalUnit::_internal_axes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.axes_;
}
inline void MechanicalUnit::_internal_set_axes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.axes_ = value;
}

// optional int32 axes_total = 7;
inline bool MechanicalUnit::has_axes_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void MechanicalUnit::clear_axes_total() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.axes_total_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t MechanicalUnit::axes_total() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.axes_total)
  return _internal_axes_total();
}
inline void MechanicalUnit::set_axes_total(::int32_t value) {
  _internal_set_axes_total(value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.axes_total)
}
inline ::int32_t MechanicalUnit::_internal_axes_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.axes_total_;
}
inline void MechanicalUnit::_internal_set_axes_total(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.axes_total_ = value;
}

// optional string is_integrated_unit = 8;
inline bool MechanicalUnit::has_is_integrated_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MechanicalUnit::clear_is_integrated_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_integrated_unit_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MechanicalUnit::is_integrated_unit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.is_integrated_unit)
  return _internal_is_integrated_unit();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MechanicalUnit::set_is_integrated_unit(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_integrated_unit_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.is_integrated_unit)
}
inline std::string* MechanicalUnit::mutable_is_integrated_unit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_is_integrated_unit();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.is_integrated_unit)
  return _s;
}
inline const std::string& MechanicalUnit::_internal_is_integrated_unit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_integrated_unit_.Get();
}
inline void MechanicalUnit::_internal_set_is_integrated_unit(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_integrated_unit_.Set(value, GetArena());
}
inline std::string* MechanicalUnit::_internal_mutable_is_integrated_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.is_integrated_unit_.Mutable( GetArena());
}
inline std::string* MechanicalUnit::release_is_integrated_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.is_integrated_unit)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.is_integrated_unit_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.is_integrated_unit_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MechanicalUnit::set_allocated_is_integrated_unit(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.is_integrated_unit_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.is_integrated_unit_.IsDefault()) {
          _impl_.is_integrated_unit_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.is_integrated_unit)
}

// optional string has_integrated_unit = 9;
inline bool MechanicalUnit::has_has_integrated_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MechanicalUnit::clear_has_integrated_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.has_integrated_unit_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MechanicalUnit::has_integrated_unit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.has_integrated_unit)
  return _internal_has_integrated_unit();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MechanicalUnit::set_has_integrated_unit(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.has_integrated_unit_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.has_integrated_unit)
}
inline std::string* MechanicalUnit::mutable_has_integrated_unit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_has_integrated_unit();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.has_integrated_unit)
  return _s;
}
inline const std::string& MechanicalUnit::_internal_has_integrated_unit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.has_integrated_unit_.Get();
}
inline void MechanicalUnit::_internal_set_has_integrated_unit(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.has_integrated_unit_.Set(value, GetArena());
}
inline std::string* MechanicalUnit::_internal_mutable_has_integrated_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.has_integrated_unit_.Mutable( GetArena());
}
inline std::string* MechanicalUnit::release_has_integrated_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.has_integrated_unit)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.has_integrated_unit_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.has_integrated_unit_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MechanicalUnit::set_allocated_has_integrated_unit(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.has_integrated_unit_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.has_integrated_unit_.IsDefault()) {
          _impl_.has_integrated_unit_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.has_integrated_unit)
}

// optional string status = 10;
inline bool MechanicalUnit::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MechanicalUnit::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MechanicalUnit::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MechanicalUnit::set_status(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.status)
}
inline std::string* MechanicalUnit::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.status)
  return _s;
}
inline const std::string& MechanicalUnit::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_.Get();
}
inline void MechanicalUnit::_internal_set_status(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.status_.Set(value, GetArena());
}
inline std::string* MechanicalUnit::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* MechanicalUnit::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.status)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.status_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MechanicalUnit::set_allocated_status(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.status_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.status)
}

// optional .abb.robot.MechanicalUnit.Mode mode = 11 [default = DEACTIVATED];
inline bool MechanicalUnit::has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void MechanicalUnit::clear_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::abb::robot::MechanicalUnit_Mode MechanicalUnit::mode() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.mode)
  return _internal_mode();
}
inline void MechanicalUnit::set_mode(::abb::robot::MechanicalUnit_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.mode)
}
inline ::abb::robot::MechanicalUnit_Mode MechanicalUnit::_internal_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::robot::MechanicalUnit_Mode>(_impl_.mode_);
}
inline void MechanicalUnit::_internal_set_mode(::abb::robot::MechanicalUnit_Mode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::robot::MechanicalUnit_Mode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.mode_ = value;
}

// repeated .abb.robot.StandardizedJoint standardized_joints = 12;
inline int MechanicalUnit::_internal_standardized_joints_size() const {
  return _internal_standardized_joints().size();
}
inline int MechanicalUnit::standardized_joints_size() const {
  return _internal_standardized_joints_size();
}
inline void MechanicalUnit::clear_standardized_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.standardized_joints_.Clear();
}
inline ::abb::robot::StandardizedJoint* MechanicalUnit::mutable_standardized_joints(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.standardized_joints)
  return _internal_mutable_standardized_joints()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::StandardizedJoint>* MechanicalUnit::mutable_standardized_joints()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.MechanicalUnit.standardized_joints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_standardized_joints();
}
inline const ::abb::robot::StandardizedJoint& MechanicalUnit::standardized_joints(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.standardized_joints)
  return _internal_standardized_joints().Get(index);
}
inline ::abb::robot::StandardizedJoint* MechanicalUnit::add_standardized_joints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::abb::robot::StandardizedJoint* _add = _internal_mutable_standardized_joints()->Add();
  // @@protoc_insertion_point(field_add:abb.robot.MechanicalUnit.standardized_joints)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::StandardizedJoint>& MechanicalUnit::standardized_joints() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.robot.MechanicalUnit.standardized_joints)
  return _internal_standardized_joints();
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::StandardizedJoint>&
MechanicalUnit::_internal_standardized_joints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.standardized_joints_;
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::StandardizedJoint>*
MechanicalUnit::_internal_mutable_standardized_joints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.standardized_joints_;
}

// -------------------------------------------------------------------

// MechanicalUnitGroup

// optional string name = 1;
inline bool MechanicalUnitGroup::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MechanicalUnitGroup::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MechanicalUnitGroup::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnitGroup.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MechanicalUnitGroup::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnitGroup.name)
}
inline std::string* MechanicalUnitGroup::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnitGroup.name)
  return _s;
}
inline const std::string& MechanicalUnitGroup::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void MechanicalUnitGroup::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* MechanicalUnitGroup::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* MechanicalUnitGroup::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnitGroup.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MechanicalUnitGroup::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnitGroup.name)
}

// optional .abb.robot.MechanicalUnit robot = 2;
inline bool MechanicalUnitGroup::has_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ != nullptr);
  return value;
}
inline void MechanicalUnitGroup::clear_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.robot_ != nullptr) _impl_.robot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::robot::MechanicalUnit& MechanicalUnitGroup::_internal_robot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::robot::MechanicalUnit* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::MechanicalUnit&>(::abb::robot::_MechanicalUnit_default_instance_);
}
inline const ::abb::robot::MechanicalUnit& MechanicalUnitGroup::robot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnitGroup.robot)
  return _internal_robot();
}
inline void MechanicalUnitGroup::unsafe_arena_set_allocated_robot(::abb::robot::MechanicalUnit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = reinterpret_cast<::abb::robot::MechanicalUnit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.MechanicalUnitGroup.robot)
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::MechanicalUnit* released = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::unsafe_arena_release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnitGroup.robot)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::MechanicalUnit* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::_internal_mutable_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::MechanicalUnit>(GetArena());
    _impl_.robot_ = reinterpret_cast<::abb::robot::MechanicalUnit*>(p);
  }
  return _impl_.robot_;
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::mutable_robot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::robot::MechanicalUnit* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnitGroup.robot)
  return _msg;
}
inline void MechanicalUnitGroup::set_allocated_robot(::abb::robot::MechanicalUnit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::robot::MechanicalUnit*>(_impl_.robot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::robot::MechanicalUnit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.robot_ = reinterpret_cast<::abb::robot::MechanicalUnit*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnitGroup.robot)
}

// repeated .abb.robot.MechanicalUnit mechanical_units = 3;
inline int MechanicalUnitGroup::_internal_mechanical_units_size() const {
  return _internal_mechanical_units().size();
}
inline int MechanicalUnitGroup::mechanical_units_size() const {
  return _internal_mechanical_units_size();
}
inline void MechanicalUnitGroup::clear_mechanical_units() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mechanical_units_.Clear();
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::mutable_mechanical_units(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnitGroup.mechanical_units)
  return _internal_mutable_mechanical_units()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::MechanicalUnit>* MechanicalUnitGroup::mutable_mechanical_units()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.MechanicalUnitGroup.mechanical_units)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_mechanical_units();
}
inline const ::abb::robot::MechanicalUnit& MechanicalUnitGroup::mechanical_units(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnitGroup.mechanical_units)
  return _internal_mechanical_units().Get(index);
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::add_mechanical_units() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::abb::robot::MechanicalUnit* _add = _internal_mutable_mechanical_units()->Add();
  // @@protoc_insertion_point(field_add:abb.robot.MechanicalUnitGroup.mechanical_units)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::MechanicalUnit>& MechanicalUnitGroup::mechanical_units() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.robot.MechanicalUnitGroup.mechanical_units)
  return _internal_mechanical_units();
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::MechanicalUnit>&
MechanicalUnitGroup::_internal_mechanical_units() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mechanical_units_;
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::MechanicalUnit>*
MechanicalUnitGroup::_internal_mutable_mechanical_units() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.mechanical_units_;
}

// -------------------------------------------------------------------

// RAPIDModule

// optional string name = 1;
inline bool RAPIDModule::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RAPIDModule::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RAPIDModule::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDModule.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RAPIDModule::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDModule.name)
}
inline std::string* RAPIDModule::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.RAPIDModule.name)
  return _s;
}
inline const std::string& RAPIDModule::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void RAPIDModule::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* RAPIDModule::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* RAPIDModule::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.RAPIDModule.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RAPIDModule::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RAPIDModule.name)
}

// optional string type = 2;
inline bool RAPIDModule::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RAPIDModule::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RAPIDModule::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDModule.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RAPIDModule::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDModule.type)
}
inline std::string* RAPIDModule::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:abb.robot.RAPIDModule.type)
  return _s;
}
inline const std::string& RAPIDModule::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void RAPIDModule::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* RAPIDModule::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* RAPIDModule::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.RAPIDModule.type)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RAPIDModule::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RAPIDModule.type)
}

// -------------------------------------------------------------------

// RAPIDTask

// optional string name = 1;
inline bool RAPIDTask::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RAPIDTask::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RAPIDTask::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RAPIDTask::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDTask.name)
}
inline std::string* RAPIDTask::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.RAPIDTask.name)
  return _s;
}
inline const std::string& RAPIDTask::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void RAPIDTask::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* RAPIDTask::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* RAPIDTask::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.robot.RAPIDTask.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RAPIDTask::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RAPIDTask.name)
}

// optional bool is_motion_task = 2;
inline bool RAPIDTask::has_is_motion_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RAPIDTask::clear_is_motion_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_motion_task_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool RAPIDTask::is_motion_task() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.is_motion_task)
  return _internal_is_motion_task();
}
inline void RAPIDTask::set_is_motion_task(bool value) {
  _internal_set_is_motion_task(value);
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDTask.is_motion_task)
}
inline bool RAPIDTask::_internal_is_motion_task() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_motion_task_;
}
inline void RAPIDTask::_internal_set_is_motion_task(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.is_motion_task_ = value;
}

// optional bool is_active = 3;
inline bool RAPIDTask::has_is_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RAPIDTask::clear_is_active() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_active_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool RAPIDTask::is_active() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.is_active)
  return _internal_is_active();
}
inline void RAPIDTask::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDTask.is_active)
}
inline bool RAPIDTask::_internal_is_active() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_active_;
}
inline void RAPIDTask::_internal_set_is_active(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_active_ = value;
}

// optional .abb.robot.RAPIDTask.ExecutionState execution_state = 4 [default = UNKNOWN];
inline bool RAPIDTask::has_execution_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RAPIDTask::clear_execution_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.execution_state_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::abb::robot::RAPIDTask_ExecutionState RAPIDTask::execution_state() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.execution_state)
  return _internal_execution_state();
}
inline void RAPIDTask::set_execution_state(::abb::robot::RAPIDTask_ExecutionState value) {
  _internal_set_execution_state(value);
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDTask.execution_state)
}
inline ::abb::robot::RAPIDTask_ExecutionState RAPIDTask::_internal_execution_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::robot::RAPIDTask_ExecutionState>(_impl_.execution_state_);
}
inline void RAPIDTask::_internal_set_execution_state(::abb::robot::RAPIDTask_ExecutionState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::robot::RAPIDTask_ExecutionState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.execution_state_ = value;
}

// repeated .abb.robot.RAPIDModule modules = 5;
inline int RAPIDTask::_internal_modules_size() const {
  return _internal_modules().size();
}
inline int RAPIDTask::modules_size() const {
  return _internal_modules_size();
}
inline void RAPIDTask::clear_modules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.modules_.Clear();
}
inline ::abb::robot::RAPIDModule* RAPIDTask::mutable_modules(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:abb.robot.RAPIDTask.modules)
  return _internal_mutable_modules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::RAPIDModule>* RAPIDTask::mutable_modules()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.RAPIDTask.modules)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_modules();
}
inline const ::abb::robot::RAPIDModule& RAPIDTask::modules(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.modules)
  return _internal_modules().Get(index);
}
inline ::abb::robot::RAPIDModule* RAPIDTask::add_modules() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::abb::robot::RAPIDModule* _add = _internal_mutable_modules()->Add();
  // @@protoc_insertion_point(field_add:abb.robot.RAPIDTask.modules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::RAPIDModule>& RAPIDTask::modules() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.robot.RAPIDTask.modules)
  return _internal_modules();
}
inline const ::google::protobuf::RepeatedPtrField<::abb::robot::RAPIDModule>&
RAPIDTask::_internal_modules() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modules_;
}
inline ::google::protobuf::RepeatedPtrField<::abb::robot::RAPIDModule>*
RAPIDTask::_internal_mutable_modules() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.modules_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace robot
}  // namespace abb


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::abb::robot::MechanicalUnit_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::robot::MechanicalUnit_Type>() {
  return ::abb::robot::MechanicalUnit_Type_descriptor();
}
template <>
struct is_proto_enum<::abb::robot::MechanicalUnit_Mode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::robot::MechanicalUnit_Mode>() {
  return ::abb::robot::MechanicalUnit_Mode_descriptor();
}
template <>
struct is_proto_enum<::abb::robot::RAPIDTask_ExecutionState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::robot::RAPIDTask_ExecutionState>() {
  return ::abb::robot::RAPIDTask_ExecutionState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_robot_5fcontroller_5fdescription_2eproto_2epb_2eh
