// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_egm_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_egm_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_egm_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_egm_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_egm_2eproto;
namespace abb {
namespace egm {
class EgmCartesian;
struct EgmCartesianDefaultTypeInternal;
extern EgmCartesianDefaultTypeInternal _EgmCartesian_default_instance_;
class EgmCartesianSpeed;
struct EgmCartesianSpeedDefaultTypeInternal;
extern EgmCartesianSpeedDefaultTypeInternal _EgmCartesianSpeed_default_instance_;
class EgmClock;
struct EgmClockDefaultTypeInternal;
extern EgmClockDefaultTypeInternal _EgmClock_default_instance_;
class EgmEuler;
struct EgmEulerDefaultTypeInternal;
extern EgmEulerDefaultTypeInternal _EgmEuler_default_instance_;
class EgmExternalJoints;
struct EgmExternalJointsDefaultTypeInternal;
extern EgmExternalJointsDefaultTypeInternal _EgmExternalJoints_default_instance_;
class EgmFeedBack;
struct EgmFeedBackDefaultTypeInternal;
extern EgmFeedBackDefaultTypeInternal _EgmFeedBack_default_instance_;
class EgmHeader;
struct EgmHeaderDefaultTypeInternal;
extern EgmHeaderDefaultTypeInternal _EgmHeader_default_instance_;
class EgmJoints;
struct EgmJointsDefaultTypeInternal;
extern EgmJointsDefaultTypeInternal _EgmJoints_default_instance_;
class EgmMCIState;
struct EgmMCIStateDefaultTypeInternal;
extern EgmMCIStateDefaultTypeInternal _EgmMCIState_default_instance_;
class EgmMeasuredForce;
struct EgmMeasuredForceDefaultTypeInternal;
extern EgmMeasuredForceDefaultTypeInternal _EgmMeasuredForce_default_instance_;
class EgmMotorState;
struct EgmMotorStateDefaultTypeInternal;
extern EgmMotorStateDefaultTypeInternal _EgmMotorState_default_instance_;
class EgmPathCorr;
struct EgmPathCorrDefaultTypeInternal;
extern EgmPathCorrDefaultTypeInternal _EgmPathCorr_default_instance_;
class EgmPlanned;
struct EgmPlannedDefaultTypeInternal;
extern EgmPlannedDefaultTypeInternal _EgmPlanned_default_instance_;
class EgmPose;
struct EgmPoseDefaultTypeInternal;
extern EgmPoseDefaultTypeInternal _EgmPose_default_instance_;
class EgmQuaternion;
struct EgmQuaternionDefaultTypeInternal;
extern EgmQuaternionDefaultTypeInternal _EgmQuaternion_default_instance_;
class EgmRapidCtrlExecState;
struct EgmRapidCtrlExecStateDefaultTypeInternal;
extern EgmRapidCtrlExecStateDefaultTypeInternal _EgmRapidCtrlExecState_default_instance_;
class EgmRobot;
struct EgmRobotDefaultTypeInternal;
extern EgmRobotDefaultTypeInternal _EgmRobot_default_instance_;
class EgmSensor;
struct EgmSensorDefaultTypeInternal;
extern EgmSensorDefaultTypeInternal _EgmSensor_default_instance_;
class EgmSensorPathCorr;
struct EgmSensorPathCorrDefaultTypeInternal;
extern EgmSensorPathCorrDefaultTypeInternal _EgmSensorPathCorr_default_instance_;
class EgmSpeedRef;
struct EgmSpeedRefDefaultTypeInternal;
extern EgmSpeedRefDefaultTypeInternal _EgmSpeedRef_default_instance_;
class EgmTestSignals;
struct EgmTestSignalsDefaultTypeInternal;
extern EgmTestSignalsDefaultTypeInternal _EgmTestSignals_default_instance_;
}  // namespace egm
}  // namespace abb
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace abb {
namespace egm {
enum EgmHeader_MessageType : int {
  EgmHeader_MessageType_MSGTYPE_UNDEFINED = 0,
  EgmHeader_MessageType_MSGTYPE_COMMAND = 1,
  EgmHeader_MessageType_MSGTYPE_DATA = 2,
  EgmHeader_MessageType_MSGTYPE_CORRECTION = 3,
  EgmHeader_MessageType_MSGTYPE_PATH_CORRECTION = 4,
};

bool EgmHeader_MessageType_IsValid(int value);
extern const uint32_t EgmHeader_MessageType_internal_data_[];
constexpr EgmHeader_MessageType EgmHeader_MessageType_MessageType_MIN = static_cast<EgmHeader_MessageType>(0);
constexpr EgmHeader_MessageType EgmHeader_MessageType_MessageType_MAX = static_cast<EgmHeader_MessageType>(4);
constexpr int EgmHeader_MessageType_MessageType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
EgmHeader_MessageType_descriptor();
template <typename T>
const std::string& EgmHeader_MessageType_Name(T value) {
  static_assert(std::is_same<T, EgmHeader_MessageType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MessageType_Name().");
  return EgmHeader_MessageType_Name(static_cast<EgmHeader_MessageType>(value));
}
template <>
inline const std::string& EgmHeader_MessageType_Name(EgmHeader_MessageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EgmHeader_MessageType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool EgmHeader_MessageType_Parse(absl::string_view name, EgmHeader_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EgmHeader_MessageType>(
      EgmHeader_MessageType_descriptor(), name, value);
}
enum EgmMotorState_MotorStateType : int {
  EgmMotorState_MotorStateType_MOTORS_UNDEFINED = 0,
  EgmMotorState_MotorStateType_MOTORS_ON = 1,
  EgmMotorState_MotorStateType_MOTORS_OFF = 2,
};

bool EgmMotorState_MotorStateType_IsValid(int value);
extern const uint32_t EgmMotorState_MotorStateType_internal_data_[];
constexpr EgmMotorState_MotorStateType EgmMotorState_MotorStateType_MotorStateType_MIN = static_cast<EgmMotorState_MotorStateType>(0);
constexpr EgmMotorState_MotorStateType EgmMotorState_MotorStateType_MotorStateType_MAX = static_cast<EgmMotorState_MotorStateType>(2);
constexpr int EgmMotorState_MotorStateType_MotorStateType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
EgmMotorState_MotorStateType_descriptor();
template <typename T>
const std::string& EgmMotorState_MotorStateType_Name(T value) {
  static_assert(std::is_same<T, EgmMotorState_MotorStateType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MotorStateType_Name().");
  return EgmMotorState_MotorStateType_Name(static_cast<EgmMotorState_MotorStateType>(value));
}
template <>
inline const std::string& EgmMotorState_MotorStateType_Name(EgmMotorState_MotorStateType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EgmMotorState_MotorStateType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool EgmMotorState_MotorStateType_Parse(absl::string_view name, EgmMotorState_MotorStateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EgmMotorState_MotorStateType>(
      EgmMotorState_MotorStateType_descriptor(), name, value);
}
enum EgmMCIState_MCIStateType : int {
  EgmMCIState_MCIStateType_MCI_UNDEFINED = 0,
  EgmMCIState_MCIStateType_MCI_ERROR = 1,
  EgmMCIState_MCIStateType_MCI_STOPPED = 2,
  EgmMCIState_MCIStateType_MCI_RUNNING = 3,
};

bool EgmMCIState_MCIStateType_IsValid(int value);
extern const uint32_t EgmMCIState_MCIStateType_internal_data_[];
constexpr EgmMCIState_MCIStateType EgmMCIState_MCIStateType_MCIStateType_MIN = static_cast<EgmMCIState_MCIStateType>(0);
constexpr EgmMCIState_MCIStateType EgmMCIState_MCIStateType_MCIStateType_MAX = static_cast<EgmMCIState_MCIStateType>(3);
constexpr int EgmMCIState_MCIStateType_MCIStateType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
EgmMCIState_MCIStateType_descriptor();
template <typename T>
const std::string& EgmMCIState_MCIStateType_Name(T value) {
  static_assert(std::is_same<T, EgmMCIState_MCIStateType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MCIStateType_Name().");
  return EgmMCIState_MCIStateType_Name(static_cast<EgmMCIState_MCIStateType>(value));
}
template <>
inline const std::string& EgmMCIState_MCIStateType_Name(EgmMCIState_MCIStateType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EgmMCIState_MCIStateType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool EgmMCIState_MCIStateType_Parse(absl::string_view name, EgmMCIState_MCIStateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EgmMCIState_MCIStateType>(
      EgmMCIState_MCIStateType_descriptor(), name, value);
}
enum EgmRapidCtrlExecState_RapidCtrlExecStateType : int {
  EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_UNDEFINED = 0,
  EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_STOPPED = 1,
  EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_RUNNING = 2,
};

bool EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(int value);
extern const uint32_t EgmRapidCtrlExecState_RapidCtrlExecStateType_internal_data_[];
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MIN = static_cast<EgmRapidCtrlExecState_RapidCtrlExecStateType>(0);
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MAX = static_cast<EgmRapidCtrlExecState_RapidCtrlExecStateType>(2);
constexpr int EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor();
template <typename T>
const std::string& EgmRapidCtrlExecState_RapidCtrlExecStateType_Name(T value) {
  static_assert(std::is_same<T, EgmRapidCtrlExecState_RapidCtrlExecStateType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RapidCtrlExecStateType_Name().");
  return EgmRapidCtrlExecState_RapidCtrlExecStateType_Name(static_cast<EgmRapidCtrlExecState_RapidCtrlExecStateType>(value));
}
template <>
inline const std::string& EgmRapidCtrlExecState_RapidCtrlExecStateType_Name(EgmRapidCtrlExecState_RapidCtrlExecStateType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool EgmRapidCtrlExecState_RapidCtrlExecStateType_Parse(absl::string_view name, EgmRapidCtrlExecState_RapidCtrlExecStateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EgmRapidCtrlExecState_RapidCtrlExecStateType>(
      EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class EgmTestSignals final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmTestSignals) */ {
 public:
  inline EgmTestSignals() : EgmTestSignals(nullptr) {}
  ~EgmTestSignals() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmTestSignals(::google::protobuf::internal::ConstantInitialized);

  inline EgmTestSignals(const EgmTestSignals& from)
      : EgmTestSignals(nullptr, from) {}
  EgmTestSignals(EgmTestSignals&& from) noexcept
    : EgmTestSignals() {
    *this = ::std::move(from);
  }

  inline EgmTestSignals& operator=(const EgmTestSignals& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmTestSignals& operator=(EgmTestSignals&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmTestSignals& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmTestSignals* internal_default_instance() {
    return reinterpret_cast<const EgmTestSignals*>(
               &_EgmTestSignals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EgmTestSignals& a, EgmTestSignals& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmTestSignals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmTestSignals* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmTestSignals* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmTestSignals>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmTestSignals& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmTestSignals& from) {
    EgmTestSignals::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmTestSignals* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmTestSignals";
  }
  protected:
  explicit EgmTestSignals(::google::protobuf::Arena* arena);
  EgmTestSignals(::google::protobuf::Arena* arena, const EgmTestSignals& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalsFieldNumber = 1,
  };
  // repeated double signals = 1;
  int signals_size() const;
  private:
  int _internal_signals_size() const;

  public:
  void clear_signals() ;
  double signals(int index) const;
  void set_signals(int index, double value);
  void add_signals(double value);
  const ::google::protobuf::RepeatedField<double>& signals() const;
  ::google::protobuf::RepeatedField<double>* mutable_signals();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_signals() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_signals();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmTestSignals)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> signals_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmRapidCtrlExecState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmRapidCtrlExecState) */ {
 public:
  inline EgmRapidCtrlExecState() : EgmRapidCtrlExecState(nullptr) {}
  ~EgmRapidCtrlExecState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmRapidCtrlExecState(::google::protobuf::internal::ConstantInitialized);

  inline EgmRapidCtrlExecState(const EgmRapidCtrlExecState& from)
      : EgmRapidCtrlExecState(nullptr, from) {}
  EgmRapidCtrlExecState(EgmRapidCtrlExecState&& from) noexcept
    : EgmRapidCtrlExecState() {
    *this = ::std::move(from);
  }

  inline EgmRapidCtrlExecState& operator=(const EgmRapidCtrlExecState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmRapidCtrlExecState& operator=(EgmRapidCtrlExecState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmRapidCtrlExecState& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmRapidCtrlExecState* internal_default_instance() {
    return reinterpret_cast<const EgmRapidCtrlExecState*>(
               &_EgmRapidCtrlExecState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(EgmRapidCtrlExecState& a, EgmRapidCtrlExecState& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmRapidCtrlExecState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmRapidCtrlExecState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmRapidCtrlExecState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmRapidCtrlExecState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmRapidCtrlExecState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmRapidCtrlExecState& from) {
    EgmRapidCtrlExecState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmRapidCtrlExecState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmRapidCtrlExecState";
  }
  protected:
  explicit EgmRapidCtrlExecState(::google::protobuf::Arena* arena);
  EgmRapidCtrlExecState(::google::protobuf::Arena* arena, const EgmRapidCtrlExecState& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using RapidCtrlExecStateType = EgmRapidCtrlExecState_RapidCtrlExecStateType;
  static constexpr RapidCtrlExecStateType RAPID_UNDEFINED = EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_UNDEFINED;
  static constexpr RapidCtrlExecStateType RAPID_STOPPED = EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_STOPPED;
  static constexpr RapidCtrlExecStateType RAPID_RUNNING = EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_RUNNING;
  static inline bool RapidCtrlExecStateType_IsValid(int value) {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(value);
  }
  static constexpr RapidCtrlExecStateType RapidCtrlExecStateType_MIN = EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MIN;
  static constexpr RapidCtrlExecStateType RapidCtrlExecStateType_MAX = EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MAX;
  static constexpr int RapidCtrlExecStateType_ARRAYSIZE = EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RapidCtrlExecStateType_descriptor() {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor();
  }
  template <typename T>
  static inline const std::string& RapidCtrlExecStateType_Name(T value) {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_Name(value);
  }
  static inline bool RapidCtrlExecStateType_Parse(absl::string_view name, RapidCtrlExecStateType* value) {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
  bool has_state() const;
  void clear_state() ;
  ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType state() const;
  void set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value);

  private:
  ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType _internal_state() const;
  void _internal_set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmRapidCtrlExecState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmQuaternion final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmQuaternion) */ {
 public:
  inline EgmQuaternion() : EgmQuaternion(nullptr) {}
  ~EgmQuaternion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmQuaternion(::google::protobuf::internal::ConstantInitialized);

  inline EgmQuaternion(const EgmQuaternion& from)
      : EgmQuaternion(nullptr, from) {}
  EgmQuaternion(EgmQuaternion&& from) noexcept
    : EgmQuaternion() {
    *this = ::std::move(from);
  }

  inline EgmQuaternion& operator=(const EgmQuaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmQuaternion& operator=(EgmQuaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmQuaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmQuaternion* internal_default_instance() {
    return reinterpret_cast<const EgmQuaternion*>(
               &_EgmQuaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EgmQuaternion& a, EgmQuaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmQuaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmQuaternion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmQuaternion* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmQuaternion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmQuaternion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmQuaternion& from) {
    EgmQuaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmQuaternion* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmQuaternion";
  }
  protected:
  explicit EgmQuaternion(::google::protobuf::Arena* arena);
  EgmQuaternion(::google::protobuf::Arena* arena, const EgmQuaternion& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kU0FieldNumber = 1,
    kU1FieldNumber = 2,
    kU2FieldNumber = 3,
    kU3FieldNumber = 4,
  };
  // required double u0 = 1;
  bool has_u0() const;
  void clear_u0() ;
  double u0() const;
  void set_u0(double value);

  private:
  double _internal_u0() const;
  void _internal_set_u0(double value);

  public:
  // required double u1 = 2;
  bool has_u1() const;
  void clear_u1() ;
  double u1() const;
  void set_u1(double value);

  private:
  double _internal_u1() const;
  void _internal_set_u1(double value);

  public:
  // required double u2 = 3;
  bool has_u2() const;
  void clear_u2() ;
  double u2() const;
  void set_u2(double value);

  private:
  double _internal_u2() const;
  void _internal_set_u2(double value);

  public:
  // required double u3 = 4;
  bool has_u3() const;
  void clear_u3() ;
  double u3() const;
  void set_u3(double value);

  private:
  double _internal_u3() const;
  void _internal_set_u3(double value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmQuaternion)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double u0_;
    double u1_;
    double u2_;
    double u3_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmMotorState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmMotorState) */ {
 public:
  inline EgmMotorState() : EgmMotorState(nullptr) {}
  ~EgmMotorState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmMotorState(::google::protobuf::internal::ConstantInitialized);

  inline EgmMotorState(const EgmMotorState& from)
      : EgmMotorState(nullptr, from) {}
  EgmMotorState(EgmMotorState&& from) noexcept
    : EgmMotorState() {
    *this = ::std::move(from);
  }

  inline EgmMotorState& operator=(const EgmMotorState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmMotorState& operator=(EgmMotorState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmMotorState& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmMotorState* internal_default_instance() {
    return reinterpret_cast<const EgmMotorState*>(
               &_EgmMotorState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EgmMotorState& a, EgmMotorState& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmMotorState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmMotorState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmMotorState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmMotorState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmMotorState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmMotorState& from) {
    EgmMotorState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmMotorState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmMotorState";
  }
  protected:
  explicit EgmMotorState(::google::protobuf::Arena* arena);
  EgmMotorState(::google::protobuf::Arena* arena, const EgmMotorState& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using MotorStateType = EgmMotorState_MotorStateType;
  static constexpr MotorStateType MOTORS_UNDEFINED = EgmMotorState_MotorStateType_MOTORS_UNDEFINED;
  static constexpr MotorStateType MOTORS_ON = EgmMotorState_MotorStateType_MOTORS_ON;
  static constexpr MotorStateType MOTORS_OFF = EgmMotorState_MotorStateType_MOTORS_OFF;
  static inline bool MotorStateType_IsValid(int value) {
    return EgmMotorState_MotorStateType_IsValid(value);
  }
  static constexpr MotorStateType MotorStateType_MIN = EgmMotorState_MotorStateType_MotorStateType_MIN;
  static constexpr MotorStateType MotorStateType_MAX = EgmMotorState_MotorStateType_MotorStateType_MAX;
  static constexpr int MotorStateType_ARRAYSIZE = EgmMotorState_MotorStateType_MotorStateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MotorStateType_descriptor() {
    return EgmMotorState_MotorStateType_descriptor();
  }
  template <typename T>
  static inline const std::string& MotorStateType_Name(T value) {
    return EgmMotorState_MotorStateType_Name(value);
  }
  static inline bool MotorStateType_Parse(absl::string_view name, MotorStateType* value) {
    return EgmMotorState_MotorStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .abb.egm.EgmMotorState.MotorStateType state = 1;
  bool has_state() const;
  void clear_state() ;
  ::abb::egm::EgmMotorState_MotorStateType state() const;
  void set_state(::abb::egm::EgmMotorState_MotorStateType value);

  private:
  ::abb::egm::EgmMotorState_MotorStateType _internal_state() const;
  void _internal_set_state(::abb::egm::EgmMotorState_MotorStateType value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmMotorState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmMeasuredForce final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmMeasuredForce) */ {
 public:
  inline EgmMeasuredForce() : EgmMeasuredForce(nullptr) {}
  ~EgmMeasuredForce() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmMeasuredForce(::google::protobuf::internal::ConstantInitialized);

  inline EgmMeasuredForce(const EgmMeasuredForce& from)
      : EgmMeasuredForce(nullptr, from) {}
  EgmMeasuredForce(EgmMeasuredForce&& from) noexcept
    : EgmMeasuredForce() {
    *this = ::std::move(from);
  }

  inline EgmMeasuredForce& operator=(const EgmMeasuredForce& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmMeasuredForce& operator=(EgmMeasuredForce&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmMeasuredForce& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmMeasuredForce* internal_default_instance() {
    return reinterpret_cast<const EgmMeasuredForce*>(
               &_EgmMeasuredForce_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EgmMeasuredForce& a, EgmMeasuredForce& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmMeasuredForce* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmMeasuredForce* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmMeasuredForce* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmMeasuredForce>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmMeasuredForce& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmMeasuredForce& from) {
    EgmMeasuredForce::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmMeasuredForce* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmMeasuredForce";
  }
  protected:
  explicit EgmMeasuredForce(::google::protobuf::Arena* arena);
  EgmMeasuredForce(::google::protobuf::Arena* arena, const EgmMeasuredForce& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForceFieldNumber = 1,
  };
  // repeated double force = 1;
  int force_size() const;
  private:
  int _internal_force_size() const;

  public:
  void clear_force() ;
  double force(int index) const;
  void set_force(int index, double value);
  void add_force(double value);
  const ::google::protobuf::RepeatedField<double>& force() const;
  ::google::protobuf::RepeatedField<double>* mutable_force();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_force() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_force();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmMeasuredForce)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> force_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmMCIState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmMCIState) */ {
 public:
  inline EgmMCIState() : EgmMCIState(nullptr) {}
  ~EgmMCIState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmMCIState(::google::protobuf::internal::ConstantInitialized);

  inline EgmMCIState(const EgmMCIState& from)
      : EgmMCIState(nullptr, from) {}
  EgmMCIState(EgmMCIState&& from) noexcept
    : EgmMCIState() {
    *this = ::std::move(from);
  }

  inline EgmMCIState& operator=(const EgmMCIState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmMCIState& operator=(EgmMCIState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmMCIState& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmMCIState* internal_default_instance() {
    return reinterpret_cast<const EgmMCIState*>(
               &_EgmMCIState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(EgmMCIState& a, EgmMCIState& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmMCIState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmMCIState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmMCIState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmMCIState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmMCIState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmMCIState& from) {
    EgmMCIState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmMCIState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmMCIState";
  }
  protected:
  explicit EgmMCIState(::google::protobuf::Arena* arena);
  EgmMCIState(::google::protobuf::Arena* arena, const EgmMCIState& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using MCIStateType = EgmMCIState_MCIStateType;
  static constexpr MCIStateType MCI_UNDEFINED = EgmMCIState_MCIStateType_MCI_UNDEFINED;
  static constexpr MCIStateType MCI_ERROR = EgmMCIState_MCIStateType_MCI_ERROR;
  static constexpr MCIStateType MCI_STOPPED = EgmMCIState_MCIStateType_MCI_STOPPED;
  static constexpr MCIStateType MCI_RUNNING = EgmMCIState_MCIStateType_MCI_RUNNING;
  static inline bool MCIStateType_IsValid(int value) {
    return EgmMCIState_MCIStateType_IsValid(value);
  }
  static constexpr MCIStateType MCIStateType_MIN = EgmMCIState_MCIStateType_MCIStateType_MIN;
  static constexpr MCIStateType MCIStateType_MAX = EgmMCIState_MCIStateType_MCIStateType_MAX;
  static constexpr int MCIStateType_ARRAYSIZE = EgmMCIState_MCIStateType_MCIStateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MCIStateType_descriptor() {
    return EgmMCIState_MCIStateType_descriptor();
  }
  template <typename T>
  static inline const std::string& MCIStateType_Name(T value) {
    return EgmMCIState_MCIStateType_Name(value);
  }
  static inline bool MCIStateType_Parse(absl::string_view name, MCIStateType* value) {
    return EgmMCIState_MCIStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
  bool has_state() const;
  void clear_state() ;
  ::abb::egm::EgmMCIState_MCIStateType state() const;
  void set_state(::abb::egm::EgmMCIState_MCIStateType value);

  private:
  ::abb::egm::EgmMCIState_MCIStateType _internal_state() const;
  void _internal_set_state(::abb::egm::EgmMCIState_MCIStateType value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmMCIState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmJoints final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmJoints) */ {
 public:
  inline EgmJoints() : EgmJoints(nullptr) {}
  ~EgmJoints() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmJoints(::google::protobuf::internal::ConstantInitialized);

  inline EgmJoints(const EgmJoints& from)
      : EgmJoints(nullptr, from) {}
  EgmJoints(EgmJoints&& from) noexcept
    : EgmJoints() {
    *this = ::std::move(from);
  }

  inline EgmJoints& operator=(const EgmJoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmJoints& operator=(EgmJoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmJoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmJoints* internal_default_instance() {
    return reinterpret_cast<const EgmJoints*>(
               &_EgmJoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EgmJoints& a, EgmJoints& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmJoints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmJoints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmJoints* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmJoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmJoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmJoints& from) {
    EgmJoints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmJoints* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmJoints";
  }
  protected:
  explicit EgmJoints(::google::protobuf::Arena* arena);
  EgmJoints(::google::protobuf::Arena* arena, const EgmJoints& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
  };
  // repeated double joints = 1;
  int joints_size() const;
  private:
  int _internal_joints_size() const;

  public:
  void clear_joints() ;
  double joints(int index) const;
  void set_joints(int index, double value);
  void add_joints(double value);
  const ::google::protobuf::RepeatedField<double>& joints() const;
  ::google::protobuf::RepeatedField<double>* mutable_joints();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_joints() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_joints();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmJoints)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> joints_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmHeader final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmHeader) */ {
 public:
  inline EgmHeader() : EgmHeader(nullptr) {}
  ~EgmHeader() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmHeader(::google::protobuf::internal::ConstantInitialized);

  inline EgmHeader(const EgmHeader& from)
      : EgmHeader(nullptr, from) {}
  EgmHeader(EgmHeader&& from) noexcept
    : EgmHeader() {
    *this = ::std::move(from);
  }

  inline EgmHeader& operator=(const EgmHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmHeader& operator=(EgmHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmHeader* internal_default_instance() {
    return reinterpret_cast<const EgmHeader*>(
               &_EgmHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EgmHeader& a, EgmHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmHeader* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmHeader& from) {
    EgmHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmHeader* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmHeader";
  }
  protected:
  explicit EgmHeader(::google::protobuf::Arena* arena);
  EgmHeader(::google::protobuf::Arena* arena, const EgmHeader& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using MessageType = EgmHeader_MessageType;
  static constexpr MessageType MSGTYPE_UNDEFINED = EgmHeader_MessageType_MSGTYPE_UNDEFINED;
  static constexpr MessageType MSGTYPE_COMMAND = EgmHeader_MessageType_MSGTYPE_COMMAND;
  static constexpr MessageType MSGTYPE_DATA = EgmHeader_MessageType_MSGTYPE_DATA;
  static constexpr MessageType MSGTYPE_CORRECTION = EgmHeader_MessageType_MSGTYPE_CORRECTION;
  static constexpr MessageType MSGTYPE_PATH_CORRECTION = EgmHeader_MessageType_MSGTYPE_PATH_CORRECTION;
  static inline bool MessageType_IsValid(int value) {
    return EgmHeader_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN = EgmHeader_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX = EgmHeader_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE = EgmHeader_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MessageType_descriptor() {
    return EgmHeader_MessageType_descriptor();
  }
  template <typename T>
  static inline const std::string& MessageType_Name(T value) {
    return EgmHeader_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(absl::string_view name, MessageType* value) {
    return EgmHeader_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSeqnoFieldNumber = 1,
    kTmFieldNumber = 2,
    kMtypeFieldNumber = 3,
  };
  // optional uint32 seqno = 1;
  bool has_seqno() const;
  void clear_seqno() ;
  ::uint32_t seqno() const;
  void set_seqno(::uint32_t value);

  private:
  ::uint32_t _internal_seqno() const;
  void _internal_set_seqno(::uint32_t value);

  public:
  // optional uint32 tm = 2;
  bool has_tm() const;
  void clear_tm() ;
  ::uint32_t tm() const;
  void set_tm(::uint32_t value);

  private:
  ::uint32_t _internal_tm() const;
  void _internal_set_tm(::uint32_t value);

  public:
  // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
  bool has_mtype() const;
  void clear_mtype() ;
  ::abb::egm::EgmHeader_MessageType mtype() const;
  void set_mtype(::abb::egm::EgmHeader_MessageType value);

  private:
  ::abb::egm::EgmHeader_MessageType _internal_mtype() const;
  void _internal_set_mtype(::abb::egm::EgmHeader_MessageType value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmHeader)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t seqno_;
    ::uint32_t tm_;
    int mtype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmExternalJoints final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmExternalJoints) */ {
 public:
  inline EgmExternalJoints() : EgmExternalJoints(nullptr) {}
  ~EgmExternalJoints() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmExternalJoints(::google::protobuf::internal::ConstantInitialized);

  inline EgmExternalJoints(const EgmExternalJoints& from)
      : EgmExternalJoints(nullptr, from) {}
  EgmExternalJoints(EgmExternalJoints&& from) noexcept
    : EgmExternalJoints() {
    *this = ::std::move(from);
  }

  inline EgmExternalJoints& operator=(const EgmExternalJoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmExternalJoints& operator=(EgmExternalJoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmExternalJoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmExternalJoints* internal_default_instance() {
    return reinterpret_cast<const EgmExternalJoints*>(
               &_EgmExternalJoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EgmExternalJoints& a, EgmExternalJoints& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmExternalJoints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmExternalJoints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmExternalJoints* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmExternalJoints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmExternalJoints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmExternalJoints& from) {
    EgmExternalJoints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmExternalJoints* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmExternalJoints";
  }
  protected:
  explicit EgmExternalJoints(::google::protobuf::Arena* arena);
  EgmExternalJoints(::google::protobuf::Arena* arena, const EgmExternalJoints& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
  };
  // repeated double joints = 1;
  int joints_size() const;
  private:
  int _internal_joints_size() const;

  public:
  void clear_joints() ;
  double joints(int index) const;
  void set_joints(int index, double value);
  void add_joints(double value);
  const ::google::protobuf::RepeatedField<double>& joints() const;
  ::google::protobuf::RepeatedField<double>* mutable_joints();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_joints() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_joints();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmExternalJoints)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> joints_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmEuler final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmEuler) */ {
 public:
  inline EgmEuler() : EgmEuler(nullptr) {}
  ~EgmEuler() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmEuler(::google::protobuf::internal::ConstantInitialized);

  inline EgmEuler(const EgmEuler& from)
      : EgmEuler(nullptr, from) {}
  EgmEuler(EgmEuler&& from) noexcept
    : EgmEuler() {
    *this = ::std::move(from);
  }

  inline EgmEuler& operator=(const EgmEuler& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmEuler& operator=(EgmEuler&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmEuler& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmEuler* internal_default_instance() {
    return reinterpret_cast<const EgmEuler*>(
               &_EgmEuler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EgmEuler& a, EgmEuler& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmEuler* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmEuler* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmEuler* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmEuler>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmEuler& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmEuler& from) {
    EgmEuler::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmEuler* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmEuler";
  }
  protected:
  explicit EgmEuler(::google::protobuf::Arena* arena);
  EgmEuler(::google::protobuf::Arena* arena, const EgmEuler& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required double x = 1;
  bool has_x() const;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // required double y = 2;
  bool has_y() const;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // required double z = 3;
  bool has_z() const;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmEuler)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmClock final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmClock) */ {
 public:
  inline EgmClock() : EgmClock(nullptr) {}
  ~EgmClock() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmClock(::google::protobuf::internal::ConstantInitialized);

  inline EgmClock(const EgmClock& from)
      : EgmClock(nullptr, from) {}
  EgmClock(EgmClock&& from) noexcept
    : EgmClock() {
    *this = ::std::move(from);
  }

  inline EgmClock& operator=(const EgmClock& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmClock& operator=(EgmClock&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmClock& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmClock* internal_default_instance() {
    return reinterpret_cast<const EgmClock*>(
               &_EgmClock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EgmClock& a, EgmClock& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmClock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmClock* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmClock* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmClock>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmClock& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmClock& from) {
    EgmClock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmClock* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmClock";
  }
  protected:
  explicit EgmClock(::google::protobuf::Arena* arena);
  EgmClock(::google::protobuf::Arena* arena, const EgmClock& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecFieldNumber = 1,
    kUsecFieldNumber = 2,
  };
  // required uint64 sec = 1;
  bool has_sec() const;
  void clear_sec() ;
  ::uint64_t sec() const;
  void set_sec(::uint64_t value);

  private:
  ::uint64_t _internal_sec() const;
  void _internal_set_sec(::uint64_t value);

  public:
  // required uint64 usec = 2;
  bool has_usec() const;
  void clear_usec() ;
  ::uint64_t usec() const;
  void set_usec(::uint64_t value);

  private:
  ::uint64_t _internal_usec() const;
  void _internal_set_usec(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmClock)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t sec_;
    ::uint64_t usec_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmCartesianSpeed final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmCartesianSpeed) */ {
 public:
  inline EgmCartesianSpeed() : EgmCartesianSpeed(nullptr) {}
  ~EgmCartesianSpeed() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmCartesianSpeed(::google::protobuf::internal::ConstantInitialized);

  inline EgmCartesianSpeed(const EgmCartesianSpeed& from)
      : EgmCartesianSpeed(nullptr, from) {}
  EgmCartesianSpeed(EgmCartesianSpeed&& from) noexcept
    : EgmCartesianSpeed() {
    *this = ::std::move(from);
  }

  inline EgmCartesianSpeed& operator=(const EgmCartesianSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmCartesianSpeed& operator=(EgmCartesianSpeed&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmCartesianSpeed& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmCartesianSpeed* internal_default_instance() {
    return reinterpret_cast<const EgmCartesianSpeed*>(
               &_EgmCartesianSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EgmCartesianSpeed& a, EgmCartesianSpeed& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmCartesianSpeed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmCartesianSpeed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmCartesianSpeed* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmCartesianSpeed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmCartesianSpeed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmCartesianSpeed& from) {
    EgmCartesianSpeed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmCartesianSpeed* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmCartesianSpeed";
  }
  protected:
  explicit EgmCartesianSpeed(::google::protobuf::Arena* arena);
  EgmCartesianSpeed(::google::protobuf::Arena* arena, const EgmCartesianSpeed& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated double value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  double value(int index) const;
  void set_value(int index, double value);
  void add_value(double value);
  const ::google::protobuf::RepeatedField<double>& value() const;
  ::google::protobuf::RepeatedField<double>* mutable_value();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_value() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmCartesianSpeed)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmCartesian final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmCartesian) */ {
 public:
  inline EgmCartesian() : EgmCartesian(nullptr) {}
  ~EgmCartesian() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmCartesian(::google::protobuf::internal::ConstantInitialized);

  inline EgmCartesian(const EgmCartesian& from)
      : EgmCartesian(nullptr, from) {}
  EgmCartesian(EgmCartesian&& from) noexcept
    : EgmCartesian() {
    *this = ::std::move(from);
  }

  inline EgmCartesian& operator=(const EgmCartesian& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmCartesian& operator=(EgmCartesian&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmCartesian& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmCartesian* internal_default_instance() {
    return reinterpret_cast<const EgmCartesian*>(
               &_EgmCartesian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EgmCartesian& a, EgmCartesian& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmCartesian* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmCartesian* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmCartesian* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmCartesian>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmCartesian& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmCartesian& from) {
    EgmCartesian::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmCartesian* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmCartesian";
  }
  protected:
  explicit EgmCartesian(::google::protobuf::Arena* arena);
  EgmCartesian(::google::protobuf::Arena* arena, const EgmCartesian& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required double x = 1;
  bool has_x() const;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // required double y = 2;
  bool has_y() const;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // required double z = 3;
  bool has_z() const;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmCartesian)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmSpeedRef final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmSpeedRef) */ {
 public:
  inline EgmSpeedRef() : EgmSpeedRef(nullptr) {}
  ~EgmSpeedRef() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmSpeedRef(::google::protobuf::internal::ConstantInitialized);

  inline EgmSpeedRef(const EgmSpeedRef& from)
      : EgmSpeedRef(nullptr, from) {}
  EgmSpeedRef(EgmSpeedRef&& from) noexcept
    : EgmSpeedRef() {
    *this = ::std::move(from);
  }

  inline EgmSpeedRef& operator=(const EgmSpeedRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmSpeedRef& operator=(EgmSpeedRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmSpeedRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmSpeedRef* internal_default_instance() {
    return reinterpret_cast<const EgmSpeedRef*>(
               &_EgmSpeedRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EgmSpeedRef& a, EgmSpeedRef& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmSpeedRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmSpeedRef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmSpeedRef* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmSpeedRef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmSpeedRef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmSpeedRef& from) {
    EgmSpeedRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmSpeedRef* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmSpeedRef";
  }
  protected:
  explicit EgmSpeedRef(::google::protobuf::Arena* arena);
  EgmSpeedRef(::google::protobuf::Arena* arena, const EgmSpeedRef& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesiansFieldNumber = 2,
    kExternalJointsFieldNumber = 3,
  };
  // optional .abb.egm.EgmJoints joints = 1;
  bool has_joints() const;
  void clear_joints() ;
  const ::abb::egm::EgmJoints& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmJoints* release_joints();
  ::abb::egm::EgmJoints* mutable_joints();
  void set_allocated_joints(::abb::egm::EgmJoints* value);
  void unsafe_arena_set_allocated_joints(::abb::egm::EgmJoints* value);
  ::abb::egm::EgmJoints* unsafe_arena_release_joints();

  private:
  const ::abb::egm::EgmJoints& _internal_joints() const;
  ::abb::egm::EgmJoints* _internal_mutable_joints();

  public:
  // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
  bool has_cartesians() const;
  void clear_cartesians() ;
  const ::abb::egm::EgmCartesianSpeed& cartesians() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmCartesianSpeed* release_cartesians();
  ::abb::egm::EgmCartesianSpeed* mutable_cartesians();
  void set_allocated_cartesians(::abb::egm::EgmCartesianSpeed* value);
  void unsafe_arena_set_allocated_cartesians(::abb::egm::EgmCartesianSpeed* value);
  ::abb::egm::EgmCartesianSpeed* unsafe_arena_release_cartesians();

  private:
  const ::abb::egm::EgmCartesianSpeed& _internal_cartesians() const;
  ::abb::egm::EgmCartesianSpeed* _internal_mutable_cartesians();

  public:
  // optional .abb.egm.EgmJoints externalJoints = 3;
  bool has_externaljoints() const;
  void clear_externaljoints() ;
  const ::abb::egm::EgmJoints& externaljoints() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmJoints* release_externaljoints();
  ::abb::egm::EgmJoints* mutable_externaljoints();
  void set_allocated_externaljoints(::abb::egm::EgmJoints* value);
  void unsafe_arena_set_allocated_externaljoints(::abb::egm::EgmJoints* value);
  ::abb::egm::EgmJoints* unsafe_arena_release_externaljoints();

  private:
  const ::abb::egm::EgmJoints& _internal_externaljoints() const;
  ::abb::egm::EgmJoints* _internal_mutable_externaljoints();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmSpeedRef)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::EgmJoints* joints_;
    ::abb::egm::EgmCartesianSpeed* cartesians_;
    ::abb::egm::EgmJoints* externaljoints_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmPose final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmPose) */ {
 public:
  inline EgmPose() : EgmPose(nullptr) {}
  ~EgmPose() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmPose(::google::protobuf::internal::ConstantInitialized);

  inline EgmPose(const EgmPose& from)
      : EgmPose(nullptr, from) {}
  EgmPose(EgmPose&& from) noexcept
    : EgmPose() {
    *this = ::std::move(from);
  }

  inline EgmPose& operator=(const EgmPose& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmPose& operator=(EgmPose&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmPose& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmPose* internal_default_instance() {
    return reinterpret_cast<const EgmPose*>(
               &_EgmPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EgmPose& a, EgmPose& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmPose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmPose* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmPose* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmPose>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmPose& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmPose& from) {
    EgmPose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmPose* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmPose";
  }
  protected:
  explicit EgmPose(::google::protobuf::Arena* arena);
  EgmPose(::google::protobuf::Arena* arena, const EgmPose& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kOrientFieldNumber = 2,
    kEulerFieldNumber = 3,
  };
  // optional .abb.egm.EgmCartesian pos = 1;
  bool has_pos() const;
  void clear_pos() ;
  const ::abb::egm::EgmCartesian& pos() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmCartesian* release_pos();
  ::abb::egm::EgmCartesian* mutable_pos();
  void set_allocated_pos(::abb::egm::EgmCartesian* value);
  void unsafe_arena_set_allocated_pos(::abb::egm::EgmCartesian* value);
  ::abb::egm::EgmCartesian* unsafe_arena_release_pos();

  private:
  const ::abb::egm::EgmCartesian& _internal_pos() const;
  ::abb::egm::EgmCartesian* _internal_mutable_pos();

  public:
  // optional .abb.egm.EgmQuaternion orient = 2;
  bool has_orient() const;
  void clear_orient() ;
  const ::abb::egm::EgmQuaternion& orient() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmQuaternion* release_orient();
  ::abb::egm::EgmQuaternion* mutable_orient();
  void set_allocated_orient(::abb::egm::EgmQuaternion* value);
  void unsafe_arena_set_allocated_orient(::abb::egm::EgmQuaternion* value);
  ::abb::egm::EgmQuaternion* unsafe_arena_release_orient();

  private:
  const ::abb::egm::EgmQuaternion& _internal_orient() const;
  ::abb::egm::EgmQuaternion* _internal_mutable_orient();

  public:
  // optional .abb.egm.EgmEuler euler = 3;
  bool has_euler() const;
  void clear_euler() ;
  const ::abb::egm::EgmEuler& euler() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmEuler* release_euler();
  ::abb::egm::EgmEuler* mutable_euler();
  void set_allocated_euler(::abb::egm::EgmEuler* value);
  void unsafe_arena_set_allocated_euler(::abb::egm::EgmEuler* value);
  ::abb::egm::EgmEuler* unsafe_arena_release_euler();

  private:
  const ::abb::egm::EgmEuler& _internal_euler() const;
  ::abb::egm::EgmEuler* _internal_mutable_euler();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmPose)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::EgmCartesian* pos_;
    ::abb::egm::EgmQuaternion* orient_;
    ::abb::egm::EgmEuler* euler_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmPathCorr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmPathCorr) */ {
 public:
  inline EgmPathCorr() : EgmPathCorr(nullptr) {}
  ~EgmPathCorr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmPathCorr(::google::protobuf::internal::ConstantInitialized);

  inline EgmPathCorr(const EgmPathCorr& from)
      : EgmPathCorr(nullptr, from) {}
  EgmPathCorr(EgmPathCorr&& from) noexcept
    : EgmPathCorr() {
    *this = ::std::move(from);
  }

  inline EgmPathCorr& operator=(const EgmPathCorr& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmPathCorr& operator=(EgmPathCorr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmPathCorr& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmPathCorr* internal_default_instance() {
    return reinterpret_cast<const EgmPathCorr*>(
               &_EgmPathCorr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EgmPathCorr& a, EgmPathCorr& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmPathCorr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmPathCorr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmPathCorr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmPathCorr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmPathCorr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmPathCorr& from) {
    EgmPathCorr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmPathCorr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmPathCorr";
  }
  protected:
  explicit EgmPathCorr(::google::protobuf::Arena* arena);
  EgmPathCorr(::google::protobuf::Arena* arena, const EgmPathCorr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kAgeFieldNumber = 2,
  };
  // required .abb.egm.EgmCartesian pos = 1;
  bool has_pos() const;
  void clear_pos() ;
  const ::abb::egm::EgmCartesian& pos() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmCartesian* release_pos();
  ::abb::egm::EgmCartesian* mutable_pos();
  void set_allocated_pos(::abb::egm::EgmCartesian* value);
  void unsafe_arena_set_allocated_pos(::abb::egm::EgmCartesian* value);
  ::abb::egm::EgmCartesian* unsafe_arena_release_pos();

  private:
  const ::abb::egm::EgmCartesian& _internal_pos() const;
  ::abb::egm::EgmCartesian* _internal_mutable_pos();

  public:
  // required uint32 age = 2;
  bool has_age() const;
  void clear_age() ;
  ::uint32_t age() const;
  void set_age(::uint32_t value);

  private:
  ::uint32_t _internal_age() const;
  void _internal_set_age(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmPathCorr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::EgmCartesian* pos_;
    ::uint32_t age_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmSensorPathCorr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmSensorPathCorr) */ {
 public:
  inline EgmSensorPathCorr() : EgmSensorPathCorr(nullptr) {}
  ~EgmSensorPathCorr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmSensorPathCorr(::google::protobuf::internal::ConstantInitialized);

  inline EgmSensorPathCorr(const EgmSensorPathCorr& from)
      : EgmSensorPathCorr(nullptr, from) {}
  EgmSensorPathCorr(EgmSensorPathCorr&& from) noexcept
    : EgmSensorPathCorr() {
    *this = ::std::move(from);
  }

  inline EgmSensorPathCorr& operator=(const EgmSensorPathCorr& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmSensorPathCorr& operator=(EgmSensorPathCorr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmSensorPathCorr& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmSensorPathCorr* internal_default_instance() {
    return reinterpret_cast<const EgmSensorPathCorr*>(
               &_EgmSensorPathCorr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(EgmSensorPathCorr& a, EgmSensorPathCorr& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmSensorPathCorr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmSensorPathCorr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmSensorPathCorr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmSensorPathCorr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmSensorPathCorr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmSensorPathCorr& from) {
    EgmSensorPathCorr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmSensorPathCorr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmSensorPathCorr";
  }
  protected:
  explicit EgmSensorPathCorr(::google::protobuf::Arena* arena);
  EgmSensorPathCorr(::google::protobuf::Arena* arena, const EgmSensorPathCorr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPathCorrFieldNumber = 2,
  };
  // optional .abb.egm.EgmHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::abb::egm::EgmHeader& header() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmHeader* release_header();
  ::abb::egm::EgmHeader* mutable_header();
  void set_allocated_header(::abb::egm::EgmHeader* value);
  void unsafe_arena_set_allocated_header(::abb::egm::EgmHeader* value);
  ::abb::egm::EgmHeader* unsafe_arena_release_header();

  private:
  const ::abb::egm::EgmHeader& _internal_header() const;
  ::abb::egm::EgmHeader* _internal_mutable_header();

  public:
  // optional .abb.egm.EgmPathCorr pathCorr = 2;
  bool has_pathcorr() const;
  void clear_pathcorr() ;
  const ::abb::egm::EgmPathCorr& pathcorr() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmPathCorr* release_pathcorr();
  ::abb::egm::EgmPathCorr* mutable_pathcorr();
  void set_allocated_pathcorr(::abb::egm::EgmPathCorr* value);
  void unsafe_arena_set_allocated_pathcorr(::abb::egm::EgmPathCorr* value);
  ::abb::egm::EgmPathCorr* unsafe_arena_release_pathcorr();

  private:
  const ::abb::egm::EgmPathCorr& _internal_pathcorr() const;
  ::abb::egm::EgmPathCorr* _internal_mutable_pathcorr();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmSensorPathCorr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::EgmHeader* header_;
    ::abb::egm::EgmPathCorr* pathcorr_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmPlanned final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmPlanned) */ {
 public:
  inline EgmPlanned() : EgmPlanned(nullptr) {}
  ~EgmPlanned() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmPlanned(::google::protobuf::internal::ConstantInitialized);

  inline EgmPlanned(const EgmPlanned& from)
      : EgmPlanned(nullptr, from) {}
  EgmPlanned(EgmPlanned&& from) noexcept
    : EgmPlanned() {
    *this = ::std::move(from);
  }

  inline EgmPlanned& operator=(const EgmPlanned& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmPlanned& operator=(EgmPlanned&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmPlanned& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmPlanned* internal_default_instance() {
    return reinterpret_cast<const EgmPlanned*>(
               &_EgmPlanned_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EgmPlanned& a, EgmPlanned& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmPlanned* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmPlanned* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmPlanned* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmPlanned>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmPlanned& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmPlanned& from) {
    EgmPlanned::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmPlanned* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmPlanned";
  }
  protected:
  explicit EgmPlanned(::google::protobuf::Arena* arena);
  EgmPlanned(::google::protobuf::Arena* arena, const EgmPlanned& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesianFieldNumber = 2,
    kExternalJointsFieldNumber = 3,
    kTimeFieldNumber = 4,
  };
  // optional .abb.egm.EgmJoints joints = 1;
  bool has_joints() const;
  void clear_joints() ;
  const ::abb::egm::EgmJoints& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmJoints* release_joints();
  ::abb::egm::EgmJoints* mutable_joints();
  void set_allocated_joints(::abb::egm::EgmJoints* value);
  void unsafe_arena_set_allocated_joints(::abb::egm::EgmJoints* value);
  ::abb::egm::EgmJoints* unsafe_arena_release_joints();

  private:
  const ::abb::egm::EgmJoints& _internal_joints() const;
  ::abb::egm::EgmJoints* _internal_mutable_joints();

  public:
  // optional .abb.egm.EgmPose cartesian = 2;
  bool has_cartesian() const;
  void clear_cartesian() ;
  const ::abb::egm::EgmPose& cartesian() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmPose* release_cartesian();
  ::abb::egm::EgmPose* mutable_cartesian();
  void set_allocated_cartesian(::abb::egm::EgmPose* value);
  void unsafe_arena_set_allocated_cartesian(::abb::egm::EgmPose* value);
  ::abb::egm::EgmPose* unsafe_arena_release_cartesian();

  private:
  const ::abb::egm::EgmPose& _internal_cartesian() const;
  ::abb::egm::EgmPose* _internal_mutable_cartesian();

  public:
  // optional .abb.egm.EgmJoints externalJoints = 3;
  bool has_externaljoints() const;
  void clear_externaljoints() ;
  const ::abb::egm::EgmJoints& externaljoints() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmJoints* release_externaljoints();
  ::abb::egm::EgmJoints* mutable_externaljoints();
  void set_allocated_externaljoints(::abb::egm::EgmJoints* value);
  void unsafe_arena_set_allocated_externaljoints(::abb::egm::EgmJoints* value);
  ::abb::egm::EgmJoints* unsafe_arena_release_externaljoints();

  private:
  const ::abb::egm::EgmJoints& _internal_externaljoints() const;
  ::abb::egm::EgmJoints* _internal_mutable_externaljoints();

  public:
  // optional .abb.egm.EgmClock time = 4;
  bool has_time() const;
  void clear_time() ;
  const ::abb::egm::EgmClock& time() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmClock* release_time();
  ::abb::egm::EgmClock* mutable_time();
  void set_allocated_time(::abb::egm::EgmClock* value);
  void unsafe_arena_set_allocated_time(::abb::egm::EgmClock* value);
  ::abb::egm::EgmClock* unsafe_arena_release_time();

  private:
  const ::abb::egm::EgmClock& _internal_time() const;
  ::abb::egm::EgmClock* _internal_mutable_time();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmPlanned)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::EgmJoints* joints_;
    ::abb::egm::EgmPose* cartesian_;
    ::abb::egm::EgmJoints* externaljoints_;
    ::abb::egm::EgmClock* time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmFeedBack final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmFeedBack) */ {
 public:
  inline EgmFeedBack() : EgmFeedBack(nullptr) {}
  ~EgmFeedBack() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmFeedBack(::google::protobuf::internal::ConstantInitialized);

  inline EgmFeedBack(const EgmFeedBack& from)
      : EgmFeedBack(nullptr, from) {}
  EgmFeedBack(EgmFeedBack&& from) noexcept
    : EgmFeedBack() {
    *this = ::std::move(from);
  }

  inline EgmFeedBack& operator=(const EgmFeedBack& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmFeedBack& operator=(EgmFeedBack&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmFeedBack& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmFeedBack* internal_default_instance() {
    return reinterpret_cast<const EgmFeedBack*>(
               &_EgmFeedBack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EgmFeedBack& a, EgmFeedBack& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmFeedBack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmFeedBack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmFeedBack* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmFeedBack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmFeedBack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmFeedBack& from) {
    EgmFeedBack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmFeedBack* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmFeedBack";
  }
  protected:
  explicit EgmFeedBack(::google::protobuf::Arena* arena);
  EgmFeedBack(::google::protobuf::Arena* arena, const EgmFeedBack& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesianFieldNumber = 2,
    kExternalJointsFieldNumber = 3,
    kTimeFieldNumber = 4,
  };
  // optional .abb.egm.EgmJoints joints = 1;
  bool has_joints() const;
  void clear_joints() ;
  const ::abb::egm::EgmJoints& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmJoints* release_joints();
  ::abb::egm::EgmJoints* mutable_joints();
  void set_allocated_joints(::abb::egm::EgmJoints* value);
  void unsafe_arena_set_allocated_joints(::abb::egm::EgmJoints* value);
  ::abb::egm::EgmJoints* unsafe_arena_release_joints();

  private:
  const ::abb::egm::EgmJoints& _internal_joints() const;
  ::abb::egm::EgmJoints* _internal_mutable_joints();

  public:
  // optional .abb.egm.EgmPose cartesian = 2;
  bool has_cartesian() const;
  void clear_cartesian() ;
  const ::abb::egm::EgmPose& cartesian() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmPose* release_cartesian();
  ::abb::egm::EgmPose* mutable_cartesian();
  void set_allocated_cartesian(::abb::egm::EgmPose* value);
  void unsafe_arena_set_allocated_cartesian(::abb::egm::EgmPose* value);
  ::abb::egm::EgmPose* unsafe_arena_release_cartesian();

  private:
  const ::abb::egm::EgmPose& _internal_cartesian() const;
  ::abb::egm::EgmPose* _internal_mutable_cartesian();

  public:
  // optional .abb.egm.EgmJoints externalJoints = 3;
  bool has_externaljoints() const;
  void clear_externaljoints() ;
  const ::abb::egm::EgmJoints& externaljoints() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmJoints* release_externaljoints();
  ::abb::egm::EgmJoints* mutable_externaljoints();
  void set_allocated_externaljoints(::abb::egm::EgmJoints* value);
  void unsafe_arena_set_allocated_externaljoints(::abb::egm::EgmJoints* value);
  ::abb::egm::EgmJoints* unsafe_arena_release_externaljoints();

  private:
  const ::abb::egm::EgmJoints& _internal_externaljoints() const;
  ::abb::egm::EgmJoints* _internal_mutable_externaljoints();

  public:
  // optional .abb.egm.EgmClock time = 4;
  bool has_time() const;
  void clear_time() ;
  const ::abb::egm::EgmClock& time() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmClock* release_time();
  ::abb::egm::EgmClock* mutable_time();
  void set_allocated_time(::abb::egm::EgmClock* value);
  void unsafe_arena_set_allocated_time(::abb::egm::EgmClock* value);
  ::abb::egm::EgmClock* unsafe_arena_release_time();

  private:
  const ::abb::egm::EgmClock& _internal_time() const;
  ::abb::egm::EgmClock* _internal_mutable_time();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmFeedBack)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::EgmJoints* joints_;
    ::abb::egm::EgmPose* cartesian_;
    ::abb::egm::EgmJoints* externaljoints_;
    ::abb::egm::EgmClock* time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmSensor final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmSensor) */ {
 public:
  inline EgmSensor() : EgmSensor(nullptr) {}
  ~EgmSensor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmSensor(::google::protobuf::internal::ConstantInitialized);

  inline EgmSensor(const EgmSensor& from)
      : EgmSensor(nullptr, from) {}
  EgmSensor(EgmSensor&& from) noexcept
    : EgmSensor() {
    *this = ::std::move(from);
  }

  inline EgmSensor& operator=(const EgmSensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmSensor& operator=(EgmSensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmSensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmSensor* internal_default_instance() {
    return reinterpret_cast<const EgmSensor*>(
               &_EgmSensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(EgmSensor& a, EgmSensor& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmSensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmSensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmSensor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmSensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmSensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmSensor& from) {
    EgmSensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmSensor* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmSensor";
  }
  protected:
  explicit EgmSensor(::google::protobuf::Arena* arena);
  EgmSensor(::google::protobuf::Arena* arena, const EgmSensor& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPlannedFieldNumber = 2,
    kSpeedRefFieldNumber = 3,
  };
  // optional .abb.egm.EgmHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::abb::egm::EgmHeader& header() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmHeader* release_header();
  ::abb::egm::EgmHeader* mutable_header();
  void set_allocated_header(::abb::egm::EgmHeader* value);
  void unsafe_arena_set_allocated_header(::abb::egm::EgmHeader* value);
  ::abb::egm::EgmHeader* unsafe_arena_release_header();

  private:
  const ::abb::egm::EgmHeader& _internal_header() const;
  ::abb::egm::EgmHeader* _internal_mutable_header();

  public:
  // optional .abb.egm.EgmPlanned planned = 2;
  bool has_planned() const;
  void clear_planned() ;
  const ::abb::egm::EgmPlanned& planned() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmPlanned* release_planned();
  ::abb::egm::EgmPlanned* mutable_planned();
  void set_allocated_planned(::abb::egm::EgmPlanned* value);
  void unsafe_arena_set_allocated_planned(::abb::egm::EgmPlanned* value);
  ::abb::egm::EgmPlanned* unsafe_arena_release_planned();

  private:
  const ::abb::egm::EgmPlanned& _internal_planned() const;
  ::abb::egm::EgmPlanned* _internal_mutable_planned();

  public:
  // optional .abb.egm.EgmSpeedRef speedRef = 3;
  bool has_speedref() const;
  void clear_speedref() ;
  const ::abb::egm::EgmSpeedRef& speedref() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmSpeedRef* release_speedref();
  ::abb::egm::EgmSpeedRef* mutable_speedref();
  void set_allocated_speedref(::abb::egm::EgmSpeedRef* value);
  void unsafe_arena_set_allocated_speedref(::abb::egm::EgmSpeedRef* value);
  ::abb::egm::EgmSpeedRef* unsafe_arena_release_speedref();

  private:
  const ::abb::egm::EgmSpeedRef& _internal_speedref() const;
  ::abb::egm::EgmSpeedRef* _internal_mutable_speedref();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmSensor)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::EgmHeader* header_;
    ::abb::egm::EgmPlanned* planned_;
    ::abb::egm::EgmSpeedRef* speedref_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};// -------------------------------------------------------------------

class EgmRobot final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmRobot) */ {
 public:
  inline EgmRobot() : EgmRobot(nullptr) {}
  ~EgmRobot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EgmRobot(::google::protobuf::internal::ConstantInitialized);

  inline EgmRobot(const EgmRobot& from)
      : EgmRobot(nullptr, from) {}
  EgmRobot(EgmRobot&& from) noexcept
    : EgmRobot() {
    *this = ::std::move(from);
  }

  inline EgmRobot& operator=(const EgmRobot& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmRobot& operator=(EgmRobot&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmRobot& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmRobot* internal_default_instance() {
    return reinterpret_cast<const EgmRobot*>(
               &_EgmRobot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EgmRobot& a, EgmRobot& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmRobot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmRobot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmRobot* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmRobot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgmRobot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EgmRobot& from) {
    EgmRobot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EgmRobot* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.EgmRobot";
  }
  protected:
  explicit EgmRobot(::google::protobuf::Arena* arena);
  EgmRobot(::google::protobuf::Arena* arena, const EgmRobot& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFeedBackFieldNumber = 2,
    kPlannedFieldNumber = 3,
    kMotorStateFieldNumber = 4,
    kMciStateFieldNumber = 5,
    kTestSignalsFieldNumber = 7,
    kRapidExecStateFieldNumber = 8,
    kMeasuredForceFieldNumber = 9,
    kUtilizationRateFieldNumber = 10,
    kMciConvergenceMetFieldNumber = 6,
  };
  // optional .abb.egm.EgmHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::abb::egm::EgmHeader& header() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmHeader* release_header();
  ::abb::egm::EgmHeader* mutable_header();
  void set_allocated_header(::abb::egm::EgmHeader* value);
  void unsafe_arena_set_allocated_header(::abb::egm::EgmHeader* value);
  ::abb::egm::EgmHeader* unsafe_arena_release_header();

  private:
  const ::abb::egm::EgmHeader& _internal_header() const;
  ::abb::egm::EgmHeader* _internal_mutable_header();

  public:
  // optional .abb.egm.EgmFeedBack feedBack = 2;
  bool has_feedback() const;
  void clear_feedback() ;
  const ::abb::egm::EgmFeedBack& feedback() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmFeedBack* release_feedback();
  ::abb::egm::EgmFeedBack* mutable_feedback();
  void set_allocated_feedback(::abb::egm::EgmFeedBack* value);
  void unsafe_arena_set_allocated_feedback(::abb::egm::EgmFeedBack* value);
  ::abb::egm::EgmFeedBack* unsafe_arena_release_feedback();

  private:
  const ::abb::egm::EgmFeedBack& _internal_feedback() const;
  ::abb::egm::EgmFeedBack* _internal_mutable_feedback();

  public:
  // optional .abb.egm.EgmPlanned planned = 3;
  bool has_planned() const;
  void clear_planned() ;
  const ::abb::egm::EgmPlanned& planned() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmPlanned* release_planned();
  ::abb::egm::EgmPlanned* mutable_planned();
  void set_allocated_planned(::abb::egm::EgmPlanned* value);
  void unsafe_arena_set_allocated_planned(::abb::egm::EgmPlanned* value);
  ::abb::egm::EgmPlanned* unsafe_arena_release_planned();

  private:
  const ::abb::egm::EgmPlanned& _internal_planned() const;
  ::abb::egm::EgmPlanned* _internal_mutable_planned();

  public:
  // optional .abb.egm.EgmMotorState motorState = 4;
  bool has_motorstate() const;
  void clear_motorstate() ;
  const ::abb::egm::EgmMotorState& motorstate() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmMotorState* release_motorstate();
  ::abb::egm::EgmMotorState* mutable_motorstate();
  void set_allocated_motorstate(::abb::egm::EgmMotorState* value);
  void unsafe_arena_set_allocated_motorstate(::abb::egm::EgmMotorState* value);
  ::abb::egm::EgmMotorState* unsafe_arena_release_motorstate();

  private:
  const ::abb::egm::EgmMotorState& _internal_motorstate() const;
  ::abb::egm::EgmMotorState* _internal_mutable_motorstate();

  public:
  // optional .abb.egm.EgmMCIState mciState = 5;
  bool has_mcistate() const;
  void clear_mcistate() ;
  const ::abb::egm::EgmMCIState& mcistate() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmMCIState* release_mcistate();
  ::abb::egm::EgmMCIState* mutable_mcistate();
  void set_allocated_mcistate(::abb::egm::EgmMCIState* value);
  void unsafe_arena_set_allocated_mcistate(::abb::egm::EgmMCIState* value);
  ::abb::egm::EgmMCIState* unsafe_arena_release_mcistate();

  private:
  const ::abb::egm::EgmMCIState& _internal_mcistate() const;
  ::abb::egm::EgmMCIState* _internal_mutable_mcistate();

  public:
  // optional .abb.egm.EgmTestSignals testSignals = 7;
  bool has_testsignals() const;
  void clear_testsignals() ;
  const ::abb::egm::EgmTestSignals& testsignals() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmTestSignals* release_testsignals();
  ::abb::egm::EgmTestSignals* mutable_testsignals();
  void set_allocated_testsignals(::abb::egm::EgmTestSignals* value);
  void unsafe_arena_set_allocated_testsignals(::abb::egm::EgmTestSignals* value);
  ::abb::egm::EgmTestSignals* unsafe_arena_release_testsignals();

  private:
  const ::abb::egm::EgmTestSignals& _internal_testsignals() const;
  ::abb::egm::EgmTestSignals* _internal_mutable_testsignals();

  public:
  // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
  bool has_rapidexecstate() const;
  void clear_rapidexecstate() ;
  const ::abb::egm::EgmRapidCtrlExecState& rapidexecstate() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmRapidCtrlExecState* release_rapidexecstate();
  ::abb::egm::EgmRapidCtrlExecState* mutable_rapidexecstate();
  void set_allocated_rapidexecstate(::abb::egm::EgmRapidCtrlExecState* value);
  void unsafe_arena_set_allocated_rapidexecstate(::abb::egm::EgmRapidCtrlExecState* value);
  ::abb::egm::EgmRapidCtrlExecState* unsafe_arena_release_rapidexecstate();

  private:
  const ::abb::egm::EgmRapidCtrlExecState& _internal_rapidexecstate() const;
  ::abb::egm::EgmRapidCtrlExecState* _internal_mutable_rapidexecstate();

  public:
  // optional .abb.egm.EgmMeasuredForce measuredForce = 9;
  bool has_measuredforce() const;
  void clear_measuredforce() ;
  const ::abb::egm::EgmMeasuredForce& measuredforce() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmMeasuredForce* release_measuredforce();
  ::abb::egm::EgmMeasuredForce* mutable_measuredforce();
  void set_allocated_measuredforce(::abb::egm::EgmMeasuredForce* value);
  void unsafe_arena_set_allocated_measuredforce(::abb::egm::EgmMeasuredForce* value);
  ::abb::egm::EgmMeasuredForce* unsafe_arena_release_measuredforce();

  private:
  const ::abb::egm::EgmMeasuredForce& _internal_measuredforce() const;
  ::abb::egm::EgmMeasuredForce* _internal_mutable_measuredforce();

  public:
  // optional double utilizationRate = 10;
  bool has_utilizationrate() const;
  void clear_utilizationrate() ;
  double utilizationrate() const;
  void set_utilizationrate(double value);

  private:
  double _internal_utilizationrate() const;
  void _internal_set_utilizationrate(double value);

  public:
  // optional bool mciConvergenceMet = 6;
  bool has_mciconvergencemet() const;
  void clear_mciconvergencemet() ;
  bool mciconvergencemet() const;
  void set_mciconvergencemet(bool value);

  private:
  bool _internal_mciconvergencemet() const;
  void _internal_set_mciconvergencemet(bool value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.EgmRobot)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 8,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::EgmHeader* header_;
    ::abb::egm::EgmFeedBack* feedback_;
    ::abb::egm::EgmPlanned* planned_;
    ::abb::egm::EgmMotorState* motorstate_;
    ::abb::egm::EgmMCIState* mcistate_;
    ::abb::egm::EgmTestSignals* testsignals_;
    ::abb::egm::EgmRapidCtrlExecState* rapidexecstate_;
    ::abb::egm::EgmMeasuredForce* measuredforce_;
    double utilizationrate_;
    bool mciconvergencemet_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EgmHeader

// optional uint32 seqno = 1;
inline bool EgmHeader::has_seqno() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EgmHeader::clear_seqno() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seqno_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t EgmHeader::seqno() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmHeader.seqno)
  return _internal_seqno();
}
inline void EgmHeader::set_seqno(::uint32_t value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmHeader.seqno)
}
inline ::uint32_t EgmHeader::_internal_seqno() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seqno_;
}
inline void EgmHeader::_internal_set_seqno(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.seqno_ = value;
}

// optional uint32 tm = 2;
inline bool EgmHeader::has_tm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EgmHeader::clear_tm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tm_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t EgmHeader::tm() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmHeader.tm)
  return _internal_tm();
}
inline void EgmHeader::set_tm(::uint32_t value) {
  _internal_set_tm(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmHeader.tm)
}
inline ::uint32_t EgmHeader::_internal_tm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tm_;
}
inline void EgmHeader::_internal_set_tm(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tm_ = value;
}

// optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
inline bool EgmHeader::has_mtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void EgmHeader::clear_mtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::abb::egm::EgmHeader_MessageType EgmHeader::mtype() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmHeader.mtype)
  return _internal_mtype();
}
inline void EgmHeader::set_mtype(::abb::egm::EgmHeader_MessageType value) {
  _internal_set_mtype(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmHeader.mtype)
}
inline ::abb::egm::EgmHeader_MessageType EgmHeader::_internal_mtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::egm::EgmHeader_MessageType>(_impl_.mtype_);
}
inline void EgmHeader::_internal_set_mtype(::abb::egm::EgmHeader_MessageType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::egm::EgmHeader_MessageType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mtype_ = value;
}

// -------------------------------------------------------------------

// EgmCartesian

// required double x = 1;
inline bool EgmCartesian::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EgmCartesian::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double EgmCartesian::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesian.x)
  return _internal_x();
}
inline void EgmCartesian::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesian.x)
}
inline double EgmCartesian::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void EgmCartesian::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// required double y = 2;
inline bool EgmCartesian::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EgmCartesian::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double EgmCartesian::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesian.y)
  return _internal_y();
}
inline void EgmCartesian::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesian.y)
}
inline double EgmCartesian::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void EgmCartesian::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// required double z = 3;
inline bool EgmCartesian::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void EgmCartesian::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double EgmCartesian::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesian.z)
  return _internal_z();
}
inline void EgmCartesian::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesian.z)
}
inline double EgmCartesian::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void EgmCartesian::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// EgmQuaternion

// required double u0 = 1;
inline bool EgmQuaternion::has_u0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EgmQuaternion::clear_u0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.u0_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double EgmQuaternion::u0() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u0)
  return _internal_u0();
}
inline void EgmQuaternion::set_u0(double value) {
  _internal_set_u0(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u0)
}
inline double EgmQuaternion::_internal_u0() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.u0_;
}
inline void EgmQuaternion::_internal_set_u0(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.u0_ = value;
}

// required double u1 = 2;
inline bool EgmQuaternion::has_u1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EgmQuaternion::clear_u1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.u1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double EgmQuaternion::u1() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u1)
  return _internal_u1();
}
inline void EgmQuaternion::set_u1(double value) {
  _internal_set_u1(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u1)
}
inline double EgmQuaternion::_internal_u1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.u1_;
}
inline void EgmQuaternion::_internal_set_u1(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.u1_ = value;
}

// required double u2 = 3;
inline bool EgmQuaternion::has_u2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void EgmQuaternion::clear_u2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.u2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double EgmQuaternion::u2() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u2)
  return _internal_u2();
}
inline void EgmQuaternion::set_u2(double value) {
  _internal_set_u2(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u2)
}
inline double EgmQuaternion::_internal_u2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.u2_;
}
inline void EgmQuaternion::_internal_set_u2(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.u2_ = value;
}

// required double u3 = 4;
inline bool EgmQuaternion::has_u3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void EgmQuaternion::clear_u3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.u3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double EgmQuaternion::u3() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u3)
  return _internal_u3();
}
inline void EgmQuaternion::set_u3(double value) {
  _internal_set_u3(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u3)
}
inline double EgmQuaternion::_internal_u3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.u3_;
}
inline void EgmQuaternion::_internal_set_u3(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.u3_ = value;
}

// -------------------------------------------------------------------

// EgmEuler

// required double x = 1;
inline bool EgmEuler::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EgmEuler::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double EgmEuler::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmEuler.x)
  return _internal_x();
}
inline void EgmEuler::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmEuler.x)
}
inline double EgmEuler::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void EgmEuler::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// required double y = 2;
inline bool EgmEuler::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EgmEuler::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double EgmEuler::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmEuler.y)
  return _internal_y();
}
inline void EgmEuler::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmEuler.y)
}
inline double EgmEuler::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void EgmEuler::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// required double z = 3;
inline bool EgmEuler::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void EgmEuler::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double EgmEuler::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmEuler.z)
  return _internal_z();
}
inline void EgmEuler::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmEuler.z)
}
inline double EgmEuler::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void EgmEuler::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// EgmClock

// required uint64 sec = 1;
inline bool EgmClock::has_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EgmClock::clear_sec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sec_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t EgmClock::sec() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmClock.sec)
  return _internal_sec();
}
inline void EgmClock::set_sec(::uint64_t value) {
  _internal_set_sec(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmClock.sec)
}
inline ::uint64_t EgmClock::_internal_sec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sec_;
}
inline void EgmClock::_internal_set_sec(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sec_ = value;
}

// required uint64 usec = 2;
inline bool EgmClock::has_usec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EgmClock::clear_usec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.usec_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t EgmClock::usec() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmClock.usec)
  return _internal_usec();
}
inline void EgmClock::set_usec(::uint64_t value) {
  _internal_set_usec(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmClock.usec)
}
inline ::uint64_t EgmClock::_internal_usec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usec_;
}
inline void EgmClock::_internal_set_usec(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.usec_ = value;
}

// -------------------------------------------------------------------

// EgmPose

// optional .abb.egm.EgmCartesian pos = 1;
inline bool EgmPose::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void EgmPose::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmCartesian& EgmPose::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmCartesian* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmCartesian&>(::abb::egm::_EgmCartesian_default_instance_);
}
inline const ::abb::egm::EgmCartesian& EgmPose::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPose.pos)
  return _internal_pos();
}
inline void EgmPose::unsafe_arena_set_allocated_pos(::abb::egm::EgmCartesian* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::abb::egm::EgmCartesian*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPose.pos)
}
inline ::abb::egm::EgmCartesian* EgmPose::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmCartesian* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmCartesian* EgmPose::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmPose.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmCartesian* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmCartesian* EgmPose::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmCartesian>(GetArena());
    _impl_.pos_ = reinterpret_cast<::abb::egm::EgmCartesian*>(p);
  }
  return _impl_.pos_;
}
inline ::abb::egm::EgmCartesian* EgmPose::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmCartesian* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPose.pos)
  return _msg;
}
inline void EgmPose::set_allocated_pos(::abb::egm::EgmCartesian* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmCartesian*>(_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmCartesian*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::abb::egm::EgmCartesian*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPose.pos)
}

// optional .abb.egm.EgmQuaternion orient = 2;
inline bool EgmPose::has_orient() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orient_ != nullptr);
  return value;
}
inline void EgmPose::clear_orient() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.orient_ != nullptr) _impl_.orient_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmQuaternion& EgmPose::_internal_orient() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmQuaternion* p = _impl_.orient_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmQuaternion&>(::abb::egm::_EgmQuaternion_default_instance_);
}
inline const ::abb::egm::EgmQuaternion& EgmPose::orient() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPose.orient)
  return _internal_orient();
}
inline void EgmPose::unsafe_arena_set_allocated_orient(::abb::egm::EgmQuaternion* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orient_);
  }
  _impl_.orient_ = reinterpret_cast<::abb::egm::EgmQuaternion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPose.orient)
}
inline ::abb::egm::EgmQuaternion* EgmPose::release_orient() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmQuaternion* released = _impl_.orient_;
  _impl_.orient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmQuaternion* EgmPose::unsafe_arena_release_orient() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmPose.orient)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmQuaternion* temp = _impl_.orient_;
  _impl_.orient_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmQuaternion* EgmPose::_internal_mutable_orient() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.orient_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmQuaternion>(GetArena());
    _impl_.orient_ = reinterpret_cast<::abb::egm::EgmQuaternion*>(p);
  }
  return _impl_.orient_;
}
inline ::abb::egm::EgmQuaternion* EgmPose::mutable_orient() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmQuaternion* _msg = _internal_mutable_orient();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPose.orient)
  return _msg;
}
inline void EgmPose::set_allocated_orient(::abb::egm::EgmQuaternion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmQuaternion*>(_impl_.orient_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmQuaternion*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.orient_ = reinterpret_cast<::abb::egm::EgmQuaternion*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPose.orient)
}

// optional .abb.egm.EgmEuler euler = 3;
inline bool EgmPose::has_euler() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.euler_ != nullptr);
  return value;
}
inline void EgmPose::clear_euler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.euler_ != nullptr) _impl_.euler_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmEuler& EgmPose::_internal_euler() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmEuler* p = _impl_.euler_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmEuler&>(::abb::egm::_EgmEuler_default_instance_);
}
inline const ::abb::egm::EgmEuler& EgmPose::euler() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPose.euler)
  return _internal_euler();
}
inline void EgmPose::unsafe_arena_set_allocated_euler(::abb::egm::EgmEuler* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.euler_);
  }
  _impl_.euler_ = reinterpret_cast<::abb::egm::EgmEuler*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPose.euler)
}
inline ::abb::egm::EgmEuler* EgmPose::release_euler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmEuler* released = _impl_.euler_;
  _impl_.euler_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmEuler* EgmPose::unsafe_arena_release_euler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmPose.euler)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmEuler* temp = _impl_.euler_;
  _impl_.euler_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmEuler* EgmPose::_internal_mutable_euler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.euler_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmEuler>(GetArena());
    _impl_.euler_ = reinterpret_cast<::abb::egm::EgmEuler*>(p);
  }
  return _impl_.euler_;
}
inline ::abb::egm::EgmEuler* EgmPose::mutable_euler() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmEuler* _msg = _internal_mutable_euler();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPose.euler)
  return _msg;
}
inline void EgmPose::set_allocated_euler(::abb::egm::EgmEuler* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmEuler*>(_impl_.euler_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmEuler*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.euler_ = reinterpret_cast<::abb::egm::EgmEuler*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPose.euler)
}

// -------------------------------------------------------------------

// EgmCartesianSpeed

// repeated double value = 1;
inline int EgmCartesianSpeed::_internal_value_size() const {
  return _internal_value().size();
}
inline int EgmCartesianSpeed::value_size() const {
  return _internal_value_size();
}
inline void EgmCartesianSpeed::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.Clear();
}
inline double EgmCartesianSpeed::value(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesianSpeed.value)
  return _internal_value().Get(index);
}
inline void EgmCartesianSpeed::set_value(int index, double value) {
  _internal_mutable_value()->Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesianSpeed.value)
}
inline void EgmCartesianSpeed::add_value(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_value()->Add(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmCartesianSpeed.value)
}
inline const ::google::protobuf::RepeatedField<double>& EgmCartesianSpeed::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.egm.EgmCartesianSpeed.value)
  return _internal_value();
}
inline ::google::protobuf::RepeatedField<double>* EgmCartesianSpeed::mutable_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmCartesianSpeed.value)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_value();
}
inline const ::google::protobuf::RepeatedField<double>& EgmCartesianSpeed::_internal_value()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedField<double>* EgmCartesianSpeed::_internal_mutable_value() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// EgmJoints

// repeated double joints = 1;
inline int EgmJoints::_internal_joints_size() const {
  return _internal_joints().size();
}
inline int EgmJoints::joints_size() const {
  return _internal_joints_size();
}
inline void EgmJoints::clear_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.joints_.Clear();
}
inline double EgmJoints::joints(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmJoints.joints)
  return _internal_joints().Get(index);
}
inline void EgmJoints::set_joints(int index, double value) {
  _internal_mutable_joints()->Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmJoints.joints)
}
inline void EgmJoints::add_joints(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_joints()->Add(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmJoints.joints)
}
inline const ::google::protobuf::RepeatedField<double>& EgmJoints::joints() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.egm.EgmJoints.joints)
  return _internal_joints();
}
inline ::google::protobuf::RepeatedField<double>* EgmJoints::mutable_joints()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmJoints.joints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_joints();
}
inline const ::google::protobuf::RepeatedField<double>& EgmJoints::_internal_joints()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.joints_;
}
inline ::google::protobuf::RepeatedField<double>* EgmJoints::_internal_mutable_joints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.joints_;
}

// -------------------------------------------------------------------

// EgmExternalJoints

// repeated double joints = 1;
inline int EgmExternalJoints::_internal_joints_size() const {
  return _internal_joints().size();
}
inline int EgmExternalJoints::joints_size() const {
  return _internal_joints_size();
}
inline void EgmExternalJoints::clear_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.joints_.Clear();
}
inline double EgmExternalJoints::joints(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmExternalJoints.joints)
  return _internal_joints().Get(index);
}
inline void EgmExternalJoints::set_joints(int index, double value) {
  _internal_mutable_joints()->Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmExternalJoints.joints)
}
inline void EgmExternalJoints::add_joints(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_joints()->Add(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmExternalJoints.joints)
}
inline const ::google::protobuf::RepeatedField<double>& EgmExternalJoints::joints() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.egm.EgmExternalJoints.joints)
  return _internal_joints();
}
inline ::google::protobuf::RepeatedField<double>* EgmExternalJoints::mutable_joints()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmExternalJoints.joints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_joints();
}
inline const ::google::protobuf::RepeatedField<double>& EgmExternalJoints::_internal_joints()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.joints_;
}
inline ::google::protobuf::RepeatedField<double>* EgmExternalJoints::_internal_mutable_joints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.joints_;
}

// -------------------------------------------------------------------

// EgmPlanned

// optional .abb.egm.EgmJoints joints = 1;
inline bool EgmPlanned::has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline void EgmPlanned::clear_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.joints_ != nullptr) _impl_.joints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmJoints& EgmPlanned::_internal_joints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmJoints* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmPlanned::joints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.joints)
  return _internal_joints();
}
inline void EgmPlanned::unsafe_arena_set_allocated_joints(::abb::egm::EgmJoints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = reinterpret_cast<::abb::egm::EgmJoints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPlanned.joints)
}
inline ::abb::egm::EgmJoints* EgmPlanned::release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* released = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmJoints* EgmPlanned::unsafe_arena_release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.joints)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmPlanned::_internal_mutable_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArena());
    _impl_.joints_ = reinterpret_cast<::abb::egm::EgmJoints*>(p);
  }
  return _impl_.joints_;
}
inline ::abb::egm::EgmJoints* EgmPlanned::mutable_joints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmJoints* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.joints)
  return _msg;
}
inline void EgmPlanned::set_allocated_joints(::abb::egm::EgmJoints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmJoints*>(_impl_.joints_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmJoints*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.joints_ = reinterpret_cast<::abb::egm::EgmJoints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.joints)
}

// optional .abb.egm.EgmPose cartesian = 2;
inline bool EgmPlanned::has_cartesian() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cartesian_ != nullptr);
  return value;
}
inline void EgmPlanned::clear_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.cartesian_ != nullptr) _impl_.cartesian_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmPose& EgmPlanned::_internal_cartesian() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmPose* p = _impl_.cartesian_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPose&>(::abb::egm::_EgmPose_default_instance_);
}
inline const ::abb::egm::EgmPose& EgmPlanned::cartesian() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.cartesian)
  return _internal_cartesian();
}
inline void EgmPlanned::unsafe_arena_set_allocated_cartesian(::abb::egm::EgmPose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cartesian_);
  }
  _impl_.cartesian_ = reinterpret_cast<::abb::egm::EgmPose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPlanned.cartesian)
}
inline ::abb::egm::EgmPose* EgmPlanned::release_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPose* released = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmPose* EgmPlanned::unsafe_arena_release_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.cartesian)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPose* temp = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPose* EgmPlanned::_internal_mutable_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cartesian_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPose>(GetArena());
    _impl_.cartesian_ = reinterpret_cast<::abb::egm::EgmPose*>(p);
  }
  return _impl_.cartesian_;
}
inline ::abb::egm::EgmPose* EgmPlanned::mutable_cartesian() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmPose* _msg = _internal_mutable_cartesian();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.cartesian)
  return _msg;
}
inline void EgmPlanned::set_allocated_cartesian(::abb::egm::EgmPose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmPose*>(_impl_.cartesian_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmPose*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.cartesian_ = reinterpret_cast<::abb::egm::EgmPose*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.cartesian)
}

// optional .abb.egm.EgmJoints externalJoints = 3;
inline bool EgmPlanned::has_externaljoints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.externaljoints_ != nullptr);
  return value;
}
inline void EgmPlanned::clear_externaljoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.externaljoints_ != nullptr) _impl_.externaljoints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmJoints& EgmPlanned::_internal_externaljoints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmJoints* p = _impl_.externaljoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmPlanned::externaljoints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.externalJoints)
  return _internal_externaljoints();
}
inline void EgmPlanned::unsafe_arena_set_allocated_externaljoints(::abb::egm::EgmJoints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.externaljoints_);
  }
  _impl_.externaljoints_ = reinterpret_cast<::abb::egm::EgmJoints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPlanned.externalJoints)
}
inline ::abb::egm::EgmJoints* EgmPlanned::release_externaljoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* released = _impl_.externaljoints_;
  _impl_.externaljoints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmJoints* EgmPlanned::unsafe_arena_release_externaljoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.externalJoints)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = _impl_.externaljoints_;
  _impl_.externaljoints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmPlanned::_internal_mutable_externaljoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.externaljoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArena());
    _impl_.externaljoints_ = reinterpret_cast<::abb::egm::EgmJoints*>(p);
  }
  return _impl_.externaljoints_;
}
inline ::abb::egm::EgmJoints* EgmPlanned::mutable_externaljoints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmJoints* _msg = _internal_mutable_externaljoints();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.externalJoints)
  return _msg;
}
inline void EgmPlanned::set_allocated_externaljoints(::abb::egm::EgmJoints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmJoints*>(_impl_.externaljoints_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmJoints*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.externaljoints_ = reinterpret_cast<::abb::egm::EgmJoints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.externalJoints)
}

// optional .abb.egm.EgmClock time = 4;
inline bool EgmPlanned::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline void EgmPlanned::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::EgmClock& EgmPlanned::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmClock* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmClock&>(::abb::egm::_EgmClock_default_instance_);
}
inline const ::abb::egm::EgmClock& EgmPlanned::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.time)
  return _internal_time();
}
inline void EgmPlanned::unsafe_arena_set_allocated_time(::abb::egm::EgmClock* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::abb::egm::EgmClock*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPlanned.time)
}
inline ::abb::egm::EgmClock* EgmPlanned::release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmClock* released = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmClock* EgmPlanned::unsafe_arena_release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.time)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmClock* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmClock* EgmPlanned::_internal_mutable_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmClock>(GetArena());
    _impl_.time_ = reinterpret_cast<::abb::egm::EgmClock*>(p);
  }
  return _impl_.time_;
}
inline ::abb::egm::EgmClock* EgmPlanned::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmClock* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.time)
  return _msg;
}
inline void EgmPlanned::set_allocated_time(::abb::egm::EgmClock* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmClock*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmClock*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.time_ = reinterpret_cast<::abb::egm::EgmClock*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.time)
}

// -------------------------------------------------------------------

// EgmSpeedRef

// optional .abb.egm.EgmJoints joints = 1;
inline bool EgmSpeedRef::has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline void EgmSpeedRef::clear_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.joints_ != nullptr) _impl_.joints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::_internal_joints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmJoints* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::joints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSpeedRef.joints)
  return _internal_joints();
}
inline void EgmSpeedRef::unsafe_arena_set_allocated_joints(::abb::egm::EgmJoints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = reinterpret_cast<::abb::egm::EgmJoints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSpeedRef.joints)
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* released = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::unsafe_arena_release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmSpeedRef.joints)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::_internal_mutable_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArena());
    _impl_.joints_ = reinterpret_cast<::abb::egm::EgmJoints*>(p);
  }
  return _impl_.joints_;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::mutable_joints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmJoints* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSpeedRef.joints)
  return _msg;
}
inline void EgmSpeedRef::set_allocated_joints(::abb::egm::EgmJoints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmJoints*>(_impl_.joints_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmJoints*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.joints_ = reinterpret_cast<::abb::egm::EgmJoints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSpeedRef.joints)
}

// optional .abb.egm.EgmCartesianSpeed cartesians = 2;
inline bool EgmSpeedRef::has_cartesians() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cartesians_ != nullptr);
  return value;
}
inline void EgmSpeedRef::clear_cartesians() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.cartesians_ != nullptr) _impl_.cartesians_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmCartesianSpeed& EgmSpeedRef::_internal_cartesians() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmCartesianSpeed* p = _impl_.cartesians_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmCartesianSpeed&>(::abb::egm::_EgmCartesianSpeed_default_instance_);
}
inline const ::abb::egm::EgmCartesianSpeed& EgmSpeedRef::cartesians() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSpeedRef.cartesians)
  return _internal_cartesians();
}
inline void EgmSpeedRef::unsafe_arena_set_allocated_cartesians(::abb::egm::EgmCartesianSpeed* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cartesians_);
  }
  _impl_.cartesians_ = reinterpret_cast<::abb::egm::EgmCartesianSpeed*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSpeedRef.cartesians)
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::release_cartesians() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmCartesianSpeed* released = _impl_.cartesians_;
  _impl_.cartesians_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::unsafe_arena_release_cartesians() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmSpeedRef.cartesians)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmCartesianSpeed* temp = _impl_.cartesians_;
  _impl_.cartesians_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::_internal_mutable_cartesians() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cartesians_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmCartesianSpeed>(GetArena());
    _impl_.cartesians_ = reinterpret_cast<::abb::egm::EgmCartesianSpeed*>(p);
  }
  return _impl_.cartesians_;
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::mutable_cartesians() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmCartesianSpeed* _msg = _internal_mutable_cartesians();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSpeedRef.cartesians)
  return _msg;
}
inline void EgmSpeedRef::set_allocated_cartesians(::abb::egm::EgmCartesianSpeed* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmCartesianSpeed*>(_impl_.cartesians_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmCartesianSpeed*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.cartesians_ = reinterpret_cast<::abb::egm::EgmCartesianSpeed*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSpeedRef.cartesians)
}

// optional .abb.egm.EgmJoints externalJoints = 3;
inline bool EgmSpeedRef::has_externaljoints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.externaljoints_ != nullptr);
  return value;
}
inline void EgmSpeedRef::clear_externaljoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.externaljoints_ != nullptr) _impl_.externaljoints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::_internal_externaljoints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmJoints* p = _impl_.externaljoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::externaljoints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSpeedRef.externalJoints)
  return _internal_externaljoints();
}
inline void EgmSpeedRef::unsafe_arena_set_allocated_externaljoints(::abb::egm::EgmJoints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.externaljoints_);
  }
  _impl_.externaljoints_ = reinterpret_cast<::abb::egm::EgmJoints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSpeedRef.externalJoints)
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::release_externaljoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* released = _impl_.externaljoints_;
  _impl_.externaljoints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::unsafe_arena_release_externaljoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmSpeedRef.externalJoints)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = _impl_.externaljoints_;
  _impl_.externaljoints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::_internal_mutable_externaljoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.externaljoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArena());
    _impl_.externaljoints_ = reinterpret_cast<::abb::egm::EgmJoints*>(p);
  }
  return _impl_.externaljoints_;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::mutable_externaljoints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmJoints* _msg = _internal_mutable_externaljoints();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSpeedRef.externalJoints)
  return _msg;
}
inline void EgmSpeedRef::set_allocated_externaljoints(::abb::egm::EgmJoints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmJoints*>(_impl_.externaljoints_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmJoints*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.externaljoints_ = reinterpret_cast<::abb::egm::EgmJoints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSpeedRef.externalJoints)
}

// -------------------------------------------------------------------

// EgmPathCorr

// required .abb.egm.EgmCartesian pos = 1;
inline bool EgmPathCorr::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void EgmPathCorr::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmCartesian& EgmPathCorr::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmCartesian* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmCartesian&>(::abb::egm::_EgmCartesian_default_instance_);
}
inline const ::abb::egm::EgmCartesian& EgmPathCorr::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPathCorr.pos)
  return _internal_pos();
}
inline void EgmPathCorr::unsafe_arena_set_allocated_pos(::abb::egm::EgmCartesian* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::abb::egm::EgmCartesian*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPathCorr.pos)
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmCartesian* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmPathCorr.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmCartesian* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmCartesian>(GetArena());
    _impl_.pos_ = reinterpret_cast<::abb::egm::EgmCartesian*>(p);
  }
  return _impl_.pos_;
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmCartesian* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPathCorr.pos)
  return _msg;
}
inline void EgmPathCorr::set_allocated_pos(::abb::egm::EgmCartesian* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmCartesian*>(_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmCartesian*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::abb::egm::EgmCartesian*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPathCorr.pos)
}

// required uint32 age = 2;
inline bool EgmPathCorr::has_age() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EgmPathCorr::clear_age() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.age_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t EgmPathCorr::age() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPathCorr.age)
  return _internal_age();
}
inline void EgmPathCorr::set_age(::uint32_t value) {
  _internal_set_age(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmPathCorr.age)
}
inline ::uint32_t EgmPathCorr::_internal_age() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.age_;
}
inline void EgmPathCorr::_internal_set_age(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.age_ = value;
}

// -------------------------------------------------------------------

// EgmFeedBack

// optional .abb.egm.EgmJoints joints = 1;
inline bool EgmFeedBack::has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline void EgmFeedBack::clear_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.joints_ != nullptr) _impl_.joints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::_internal_joints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmJoints* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::joints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.joints)
  return _internal_joints();
}
inline void EgmFeedBack::unsafe_arena_set_allocated_joints(::abb::egm::EgmJoints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = reinterpret_cast<::abb::egm::EgmJoints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmFeedBack.joints)
}
inline ::abb::egm::EgmJoints* EgmFeedBack::release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* released = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::unsafe_arena_release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.joints)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::_internal_mutable_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArena());
    _impl_.joints_ = reinterpret_cast<::abb::egm::EgmJoints*>(p);
  }
  return _impl_.joints_;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::mutable_joints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmJoints* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.joints)
  return _msg;
}
inline void EgmFeedBack::set_allocated_joints(::abb::egm::EgmJoints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmJoints*>(_impl_.joints_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmJoints*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.joints_ = reinterpret_cast<::abb::egm::EgmJoints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.joints)
}

// optional .abb.egm.EgmPose cartesian = 2;
inline bool EgmFeedBack::has_cartesian() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cartesian_ != nullptr);
  return value;
}
inline void EgmFeedBack::clear_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.cartesian_ != nullptr) _impl_.cartesian_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmPose& EgmFeedBack::_internal_cartesian() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmPose* p = _impl_.cartesian_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPose&>(::abb::egm::_EgmPose_default_instance_);
}
inline const ::abb::egm::EgmPose& EgmFeedBack::cartesian() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.cartesian)
  return _internal_cartesian();
}
inline void EgmFeedBack::unsafe_arena_set_allocated_cartesian(::abb::egm::EgmPose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cartesian_);
  }
  _impl_.cartesian_ = reinterpret_cast<::abb::egm::EgmPose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmFeedBack.cartesian)
}
inline ::abb::egm::EgmPose* EgmFeedBack::release_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPose* released = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmPose* EgmFeedBack::unsafe_arena_release_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.cartesian)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPose* temp = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPose* EgmFeedBack::_internal_mutable_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cartesian_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPose>(GetArena());
    _impl_.cartesian_ = reinterpret_cast<::abb::egm::EgmPose*>(p);
  }
  return _impl_.cartesian_;
}
inline ::abb::egm::EgmPose* EgmFeedBack::mutable_cartesian() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmPose* _msg = _internal_mutable_cartesian();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.cartesian)
  return _msg;
}
inline void EgmFeedBack::set_allocated_cartesian(::abb::egm::EgmPose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmPose*>(_impl_.cartesian_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmPose*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.cartesian_ = reinterpret_cast<::abb::egm::EgmPose*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.cartesian)
}

// optional .abb.egm.EgmJoints externalJoints = 3;
inline bool EgmFeedBack::has_externaljoints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.externaljoints_ != nullptr);
  return value;
}
inline void EgmFeedBack::clear_externaljoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.externaljoints_ != nullptr) _impl_.externaljoints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::_internal_externaljoints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmJoints* p = _impl_.externaljoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::externaljoints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.externalJoints)
  return _internal_externaljoints();
}
inline void EgmFeedBack::unsafe_arena_set_allocated_externaljoints(::abb::egm::EgmJoints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.externaljoints_);
  }
  _impl_.externaljoints_ = reinterpret_cast<::abb::egm::EgmJoints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmFeedBack.externalJoints)
}
inline ::abb::egm::EgmJoints* EgmFeedBack::release_externaljoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* released = _impl_.externaljoints_;
  _impl_.externaljoints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::unsafe_arena_release_externaljoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.externalJoints)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = _impl_.externaljoints_;
  _impl_.externaljoints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::_internal_mutable_externaljoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.externaljoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArena());
    _impl_.externaljoints_ = reinterpret_cast<::abb::egm::EgmJoints*>(p);
  }
  return _impl_.externaljoints_;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::mutable_externaljoints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmJoints* _msg = _internal_mutable_externaljoints();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.externalJoints)
  return _msg;
}
inline void EgmFeedBack::set_allocated_externaljoints(::abb::egm::EgmJoints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmJoints*>(_impl_.externaljoints_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmJoints*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.externaljoints_ = reinterpret_cast<::abb::egm::EgmJoints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.externalJoints)
}

// optional .abb.egm.EgmClock time = 4;
inline bool EgmFeedBack::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline void EgmFeedBack::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::EgmClock& EgmFeedBack::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmClock* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmClock&>(::abb::egm::_EgmClock_default_instance_);
}
inline const ::abb::egm::EgmClock& EgmFeedBack::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.time)
  return _internal_time();
}
inline void EgmFeedBack::unsafe_arena_set_allocated_time(::abb::egm::EgmClock* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::abb::egm::EgmClock*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmFeedBack.time)
}
inline ::abb::egm::EgmClock* EgmFeedBack::release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmClock* released = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmClock* EgmFeedBack::unsafe_arena_release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.time)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmClock* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmClock* EgmFeedBack::_internal_mutable_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmClock>(GetArena());
    _impl_.time_ = reinterpret_cast<::abb::egm::EgmClock*>(p);
  }
  return _impl_.time_;
}
inline ::abb::egm::EgmClock* EgmFeedBack::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmClock* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.time)
  return _msg;
}
inline void EgmFeedBack::set_allocated_time(::abb::egm::EgmClock* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmClock*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmClock*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.time_ = reinterpret_cast<::abb::egm::EgmClock*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.time)
}

// -------------------------------------------------------------------

// EgmMotorState

// required .abb.egm.EgmMotorState.MotorStateType state = 1;
inline bool EgmMotorState::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EgmMotorState::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::abb::egm::EgmMotorState_MotorStateType EgmMotorState::state() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmMotorState.state)
  return _internal_state();
}
inline void EgmMotorState::set_state(::abb::egm::EgmMotorState_MotorStateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmMotorState.state)
}
inline ::abb::egm::EgmMotorState_MotorStateType EgmMotorState::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::egm::EgmMotorState_MotorStateType>(_impl_.state_);
}
inline void EgmMotorState::_internal_set_state(::abb::egm::EgmMotorState_MotorStateType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::egm::EgmMotorState_MotorStateType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// EgmMCIState

// required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
inline bool EgmMCIState::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EgmMCIState::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::abb::egm::EgmMCIState_MCIStateType EgmMCIState::state() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmMCIState.state)
  return _internal_state();
}
inline void EgmMCIState::set_state(::abb::egm::EgmMCIState_MCIStateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmMCIState.state)
}
inline ::abb::egm::EgmMCIState_MCIStateType EgmMCIState::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::egm::EgmMCIState_MCIStateType>(_impl_.state_);
}
inline void EgmMCIState::_internal_set_state(::abb::egm::EgmMCIState_MCIStateType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::egm::EgmMCIState_MCIStateType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// EgmRapidCtrlExecState

// required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
inline bool EgmRapidCtrlExecState::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EgmRapidCtrlExecState::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::state() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRapidCtrlExecState.state)
  return _internal_state();
}
inline void EgmRapidCtrlExecState::set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmRapidCtrlExecState.state)
}
inline ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType>(_impl_.state_);
}
inline void EgmRapidCtrlExecState::_internal_set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// EgmTestSignals

// repeated double signals = 1;
inline int EgmTestSignals::_internal_signals_size() const {
  return _internal_signals().size();
}
inline int EgmTestSignals::signals_size() const {
  return _internal_signals_size();
}
inline void EgmTestSignals::clear_signals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signals_.Clear();
}
inline double EgmTestSignals::signals(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmTestSignals.signals)
  return _internal_signals().Get(index);
}
inline void EgmTestSignals::set_signals(int index, double value) {
  _internal_mutable_signals()->Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmTestSignals.signals)
}
inline void EgmTestSignals::add_signals(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_signals()->Add(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmTestSignals.signals)
}
inline const ::google::protobuf::RepeatedField<double>& EgmTestSignals::signals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.egm.EgmTestSignals.signals)
  return _internal_signals();
}
inline ::google::protobuf::RepeatedField<double>* EgmTestSignals::mutable_signals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmTestSignals.signals)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_signals();
}
inline const ::google::protobuf::RepeatedField<double>& EgmTestSignals::_internal_signals()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.signals_;
}
inline ::google::protobuf::RepeatedField<double>* EgmTestSignals::_internal_mutable_signals() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.signals_;
}

// -------------------------------------------------------------------

// EgmMeasuredForce

// repeated double force = 1;
inline int EgmMeasuredForce::_internal_force_size() const {
  return _internal_force().size();
}
inline int EgmMeasuredForce::force_size() const {
  return _internal_force_size();
}
inline void EgmMeasuredForce::clear_force() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.force_.Clear();
}
inline double EgmMeasuredForce::force(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmMeasuredForce.force)
  return _internal_force().Get(index);
}
inline void EgmMeasuredForce::set_force(int index, double value) {
  _internal_mutable_force()->Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmMeasuredForce.force)
}
inline void EgmMeasuredForce::add_force(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_force()->Add(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmMeasuredForce.force)
}
inline const ::google::protobuf::RepeatedField<double>& EgmMeasuredForce::force() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.egm.EgmMeasuredForce.force)
  return _internal_force();
}
inline ::google::protobuf::RepeatedField<double>* EgmMeasuredForce::mutable_force()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmMeasuredForce.force)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_force();
}
inline const ::google::protobuf::RepeatedField<double>& EgmMeasuredForce::_internal_force()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.force_;
}
inline ::google::protobuf::RepeatedField<double>* EgmMeasuredForce::_internal_mutable_force() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.force_;
}

// -------------------------------------------------------------------

// EgmRobot

// optional .abb.egm.EgmHeader header = 1;
inline bool EgmRobot::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void EgmRobot::clear_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmHeader& EgmRobot::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmHeader&>(::abb::egm::_EgmHeader_default_instance_);
}
inline const ::abb::egm::EgmHeader& EgmRobot::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.header)
  return _internal_header();
}
inline void EgmRobot::unsafe_arena_set_allocated_header(::abb::egm::EgmHeader* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::abb::egm::EgmHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.header)
}
inline ::abb::egm::EgmHeader* EgmRobot::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmHeader* EgmRobot::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmHeader* EgmRobot::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::abb::egm::EgmHeader*>(p);
  }
  return _impl_.header_;
}
inline ::abb::egm::EgmHeader* EgmRobot::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.header)
  return _msg;
}
inline void EgmRobot::set_allocated_header(::abb::egm::EgmHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmHeader*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmHeader*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::abb::egm::EgmHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.header)
}

// optional .abb.egm.EgmFeedBack feedBack = 2;
inline bool EgmRobot::has_feedback() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.feedback_ != nullptr);
  return value;
}
inline void EgmRobot::clear_feedback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.feedback_ != nullptr) _impl_.feedback_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmFeedBack& EgmRobot::_internal_feedback() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmFeedBack* p = _impl_.feedback_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmFeedBack&>(::abb::egm::_EgmFeedBack_default_instance_);
}
inline const ::abb::egm::EgmFeedBack& EgmRobot::feedback() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.feedBack)
  return _internal_feedback();
}
inline void EgmRobot::unsafe_arena_set_allocated_feedback(::abb::egm::EgmFeedBack* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.feedback_);
  }
  _impl_.feedback_ = reinterpret_cast<::abb::egm::EgmFeedBack*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.feedBack)
}
inline ::abb::egm::EgmFeedBack* EgmRobot::release_feedback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmFeedBack* released = _impl_.feedback_;
  _impl_.feedback_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmFeedBack* EgmRobot::unsafe_arena_release_feedback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.feedBack)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmFeedBack* temp = _impl_.feedback_;
  _impl_.feedback_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmFeedBack* EgmRobot::_internal_mutable_feedback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmFeedBack>(GetArena());
    _impl_.feedback_ = reinterpret_cast<::abb::egm::EgmFeedBack*>(p);
  }
  return _impl_.feedback_;
}
inline ::abb::egm::EgmFeedBack* EgmRobot::mutable_feedback() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmFeedBack* _msg = _internal_mutable_feedback();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.feedBack)
  return _msg;
}
inline void EgmRobot::set_allocated_feedback(::abb::egm::EgmFeedBack* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmFeedBack*>(_impl_.feedback_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmFeedBack*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.feedback_ = reinterpret_cast<::abb::egm::EgmFeedBack*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.feedBack)
}

// optional .abb.egm.EgmPlanned planned = 3;
inline bool EgmRobot::has_planned() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.planned_ != nullptr);
  return value;
}
inline void EgmRobot::clear_planned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.planned_ != nullptr) _impl_.planned_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmPlanned& EgmRobot::_internal_planned() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmPlanned* p = _impl_.planned_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPlanned&>(::abb::egm::_EgmPlanned_default_instance_);
}
inline const ::abb::egm::EgmPlanned& EgmRobot::planned() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.planned)
  return _internal_planned();
}
inline void EgmRobot::unsafe_arena_set_allocated_planned(::abb::egm::EgmPlanned* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.planned_);
  }
  _impl_.planned_ = reinterpret_cast<::abb::egm::EgmPlanned*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.planned)
}
inline ::abb::egm::EgmPlanned* EgmRobot::release_planned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmPlanned* released = _impl_.planned_;
  _impl_.planned_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmPlanned* EgmRobot::unsafe_arena_release_planned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.planned)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmPlanned* temp = _impl_.planned_;
  _impl_.planned_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPlanned* EgmRobot::_internal_mutable_planned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.planned_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPlanned>(GetArena());
    _impl_.planned_ = reinterpret_cast<::abb::egm::EgmPlanned*>(p);
  }
  return _impl_.planned_;
}
inline ::abb::egm::EgmPlanned* EgmRobot::mutable_planned() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmPlanned* _msg = _internal_mutable_planned();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.planned)
  return _msg;
}
inline void EgmRobot::set_allocated_planned(::abb::egm::EgmPlanned* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmPlanned*>(_impl_.planned_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmPlanned*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.planned_ = reinterpret_cast<::abb::egm::EgmPlanned*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.planned)
}

// optional .abb.egm.EgmMotorState motorState = 4;
inline bool EgmRobot::has_motorstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.motorstate_ != nullptr);
  return value;
}
inline void EgmRobot::clear_motorstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.motorstate_ != nullptr) _impl_.motorstate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::EgmMotorState& EgmRobot::_internal_motorstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmMotorState* p = _impl_.motorstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmMotorState&>(::abb::egm::_EgmMotorState_default_instance_);
}
inline const ::abb::egm::EgmMotorState& EgmRobot::motorstate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.motorState)
  return _internal_motorstate();
}
inline void EgmRobot::unsafe_arena_set_allocated_motorstate(::abb::egm::EgmMotorState* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.motorstate_);
  }
  _impl_.motorstate_ = reinterpret_cast<::abb::egm::EgmMotorState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.motorState)
}
inline ::abb::egm::EgmMotorState* EgmRobot::release_motorstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmMotorState* released = _impl_.motorstate_;
  _impl_.motorstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmMotorState* EgmRobot::unsafe_arena_release_motorstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.motorState)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmMotorState* temp = _impl_.motorstate_;
  _impl_.motorstate_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmMotorState* EgmRobot::_internal_mutable_motorstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.motorstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmMotorState>(GetArena());
    _impl_.motorstate_ = reinterpret_cast<::abb::egm::EgmMotorState*>(p);
  }
  return _impl_.motorstate_;
}
inline ::abb::egm::EgmMotorState* EgmRobot::mutable_motorstate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmMotorState* _msg = _internal_mutable_motorstate();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.motorState)
  return _msg;
}
inline void EgmRobot::set_allocated_motorstate(::abb::egm::EgmMotorState* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmMotorState*>(_impl_.motorstate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmMotorState*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.motorstate_ = reinterpret_cast<::abb::egm::EgmMotorState*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.motorState)
}

// optional .abb.egm.EgmMCIState mciState = 5;
inline bool EgmRobot::has_mcistate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mcistate_ != nullptr);
  return value;
}
inline void EgmRobot::clear_mcistate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.mcistate_ != nullptr) _impl_.mcistate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::abb::egm::EgmMCIState& EgmRobot::_internal_mcistate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmMCIState* p = _impl_.mcistate_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmMCIState&>(::abb::egm::_EgmMCIState_default_instance_);
}
inline const ::abb::egm::EgmMCIState& EgmRobot::mcistate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.mciState)
  return _internal_mcistate();
}
inline void EgmRobot::unsafe_arena_set_allocated_mcistate(::abb::egm::EgmMCIState* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mcistate_);
  }
  _impl_.mcistate_ = reinterpret_cast<::abb::egm::EgmMCIState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.mciState)
}
inline ::abb::egm::EgmMCIState* EgmRobot::release_mcistate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::abb::egm::EgmMCIState* released = _impl_.mcistate_;
  _impl_.mcistate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmMCIState* EgmRobot::unsafe_arena_release_mcistate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.mciState)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::abb::egm::EgmMCIState* temp = _impl_.mcistate_;
  _impl_.mcistate_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmMCIState* EgmRobot::_internal_mutable_mcistate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.mcistate_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmMCIState>(GetArena());
    _impl_.mcistate_ = reinterpret_cast<::abb::egm::EgmMCIState*>(p);
  }
  return _impl_.mcistate_;
}
inline ::abb::egm::EgmMCIState* EgmRobot::mutable_mcistate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmMCIState* _msg = _internal_mutable_mcistate();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.mciState)
  return _msg;
}
inline void EgmRobot::set_allocated_mcistate(::abb::egm::EgmMCIState* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmMCIState*>(_impl_.mcistate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmMCIState*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.mcistate_ = reinterpret_cast<::abb::egm::EgmMCIState*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.mciState)
}

// optional bool mciConvergenceMet = 6;
inline bool EgmRobot::has_mciconvergencemet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void EgmRobot::clear_mciconvergencemet() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mciconvergencemet_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool EgmRobot::mciconvergencemet() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.mciConvergenceMet)
  return _internal_mciconvergencemet();
}
inline void EgmRobot::set_mciconvergencemet(bool value) {
  _internal_set_mciconvergencemet(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmRobot.mciConvergenceMet)
}
inline bool EgmRobot::_internal_mciconvergencemet() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mciconvergencemet_;
}
inline void EgmRobot::_internal_set_mciconvergencemet(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.mciconvergencemet_ = value;
}

// optional .abb.egm.EgmTestSignals testSignals = 7;
inline bool EgmRobot::has_testsignals() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.testsignals_ != nullptr);
  return value;
}
inline void EgmRobot::clear_testsignals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.testsignals_ != nullptr) _impl_.testsignals_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::abb::egm::EgmTestSignals& EgmRobot::_internal_testsignals() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmTestSignals* p = _impl_.testsignals_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmTestSignals&>(::abb::egm::_EgmTestSignals_default_instance_);
}
inline const ::abb::egm::EgmTestSignals& EgmRobot::testsignals() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.testSignals)
  return _internal_testsignals();
}
inline void EgmRobot::unsafe_arena_set_allocated_testsignals(::abb::egm::EgmTestSignals* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.testsignals_);
  }
  _impl_.testsignals_ = reinterpret_cast<::abb::egm::EgmTestSignals*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.testSignals)
}
inline ::abb::egm::EgmTestSignals* EgmRobot::release_testsignals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::abb::egm::EgmTestSignals* released = _impl_.testsignals_;
  _impl_.testsignals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmTestSignals* EgmRobot::unsafe_arena_release_testsignals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.testSignals)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::abb::egm::EgmTestSignals* temp = _impl_.testsignals_;
  _impl_.testsignals_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmTestSignals* EgmRobot::_internal_mutable_testsignals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.testsignals_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmTestSignals>(GetArena());
    _impl_.testsignals_ = reinterpret_cast<::abb::egm::EgmTestSignals*>(p);
  }
  return _impl_.testsignals_;
}
inline ::abb::egm::EgmTestSignals* EgmRobot::mutable_testsignals() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmTestSignals* _msg = _internal_mutable_testsignals();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.testSignals)
  return _msg;
}
inline void EgmRobot::set_allocated_testsignals(::abb::egm::EgmTestSignals* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmTestSignals*>(_impl_.testsignals_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmTestSignals*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.testsignals_ = reinterpret_cast<::abb::egm::EgmTestSignals*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.testSignals)
}

// optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
inline bool EgmRobot::has_rapidexecstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rapidexecstate_ != nullptr);
  return value;
}
inline void EgmRobot::clear_rapidexecstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rapidexecstate_ != nullptr) _impl_.rapidexecstate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::abb::egm::EgmRapidCtrlExecState& EgmRobot::_internal_rapidexecstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmRapidCtrlExecState* p = _impl_.rapidexecstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmRapidCtrlExecState&>(::abb::egm::_EgmRapidCtrlExecState_default_instance_);
}
inline const ::abb::egm::EgmRapidCtrlExecState& EgmRobot::rapidexecstate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.rapidExecState)
  return _internal_rapidexecstate();
}
inline void EgmRobot::unsafe_arena_set_allocated_rapidexecstate(::abb::egm::EgmRapidCtrlExecState* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rapidexecstate_);
  }
  _impl_.rapidexecstate_ = reinterpret_cast<::abb::egm::EgmRapidCtrlExecState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.rapidExecState)
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::release_rapidexecstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::abb::egm::EgmRapidCtrlExecState* released = _impl_.rapidexecstate_;
  _impl_.rapidexecstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::unsafe_arena_release_rapidexecstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.rapidExecState)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::abb::egm::EgmRapidCtrlExecState* temp = _impl_.rapidexecstate_;
  _impl_.rapidexecstate_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::_internal_mutable_rapidexecstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.rapidexecstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmRapidCtrlExecState>(GetArena());
    _impl_.rapidexecstate_ = reinterpret_cast<::abb::egm::EgmRapidCtrlExecState*>(p);
  }
  return _impl_.rapidexecstate_;
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::mutable_rapidexecstate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmRapidCtrlExecState* _msg = _internal_mutable_rapidexecstate();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.rapidExecState)
  return _msg;
}
inline void EgmRobot::set_allocated_rapidexecstate(::abb::egm::EgmRapidCtrlExecState* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmRapidCtrlExecState*>(_impl_.rapidexecstate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmRapidCtrlExecState*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.rapidexecstate_ = reinterpret_cast<::abb::egm::EgmRapidCtrlExecState*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.rapidExecState)
}

// optional .abb.egm.EgmMeasuredForce measuredForce = 9;
inline bool EgmRobot::has_measuredforce() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.measuredforce_ != nullptr);
  return value;
}
inline void EgmRobot::clear_measuredforce() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.measuredforce_ != nullptr) _impl_.measuredforce_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::abb::egm::EgmMeasuredForce& EgmRobot::_internal_measuredforce() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmMeasuredForce* p = _impl_.measuredforce_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmMeasuredForce&>(::abb::egm::_EgmMeasuredForce_default_instance_);
}
inline const ::abb::egm::EgmMeasuredForce& EgmRobot::measuredforce() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.measuredForce)
  return _internal_measuredforce();
}
inline void EgmRobot::unsafe_arena_set_allocated_measuredforce(::abb::egm::EgmMeasuredForce* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.measuredforce_);
  }
  _impl_.measuredforce_ = reinterpret_cast<::abb::egm::EgmMeasuredForce*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.measuredForce)
}
inline ::abb::egm::EgmMeasuredForce* EgmRobot::release_measuredforce() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::abb::egm::EgmMeasuredForce* released = _impl_.measuredforce_;
  _impl_.measuredforce_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmMeasuredForce* EgmRobot::unsafe_arena_release_measuredforce() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.measuredForce)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::abb::egm::EgmMeasuredForce* temp = _impl_.measuredforce_;
  _impl_.measuredforce_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmMeasuredForce* EgmRobot::_internal_mutable_measuredforce() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.measuredforce_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmMeasuredForce>(GetArena());
    _impl_.measuredforce_ = reinterpret_cast<::abb::egm::EgmMeasuredForce*>(p);
  }
  return _impl_.measuredforce_;
}
inline ::abb::egm::EgmMeasuredForce* EgmRobot::mutable_measuredforce() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmMeasuredForce* _msg = _internal_mutable_measuredforce();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.measuredForce)
  return _msg;
}
inline void EgmRobot::set_allocated_measuredforce(::abb::egm::EgmMeasuredForce* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmMeasuredForce*>(_impl_.measuredforce_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmMeasuredForce*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.measuredforce_ = reinterpret_cast<::abb::egm::EgmMeasuredForce*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.measuredForce)
}

// optional double utilizationRate = 10;
inline bool EgmRobot::has_utilizationrate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void EgmRobot::clear_utilizationrate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.utilizationrate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double EgmRobot::utilizationrate() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.utilizationRate)
  return _internal_utilizationrate();
}
inline void EgmRobot::set_utilizationrate(double value) {
  _internal_set_utilizationrate(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmRobot.utilizationRate)
}
inline double EgmRobot::_internal_utilizationrate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.utilizationrate_;
}
inline void EgmRobot::_internal_set_utilizationrate(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.utilizationrate_ = value;
}

// -------------------------------------------------------------------

// EgmSensor

// optional .abb.egm.EgmHeader header = 1;
inline bool EgmSensor::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void EgmSensor::clear_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmHeader& EgmSensor::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmHeader&>(::abb::egm::_EgmHeader_default_instance_);
}
inline const ::abb::egm::EgmHeader& EgmSensor::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensor.header)
  return _internal_header();
}
inline void EgmSensor::unsafe_arena_set_allocated_header(::abb::egm::EgmHeader* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::abb::egm::EgmHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensor.header)
}
inline ::abb::egm::EgmHeader* EgmSensor::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmHeader* EgmSensor::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensor.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmHeader* EgmSensor::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::abb::egm::EgmHeader*>(p);
  }
  return _impl_.header_;
}
inline ::abb::egm::EgmHeader* EgmSensor::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensor.header)
  return _msg;
}
inline void EgmSensor::set_allocated_header(::abb::egm::EgmHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmHeader*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmHeader*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::abb::egm::EgmHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensor.header)
}

// optional .abb.egm.EgmPlanned planned = 2;
inline bool EgmSensor::has_planned() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.planned_ != nullptr);
  return value;
}
inline void EgmSensor::clear_planned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.planned_ != nullptr) _impl_.planned_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmPlanned& EgmSensor::_internal_planned() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmPlanned* p = _impl_.planned_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPlanned&>(::abb::egm::_EgmPlanned_default_instance_);
}
inline const ::abb::egm::EgmPlanned& EgmSensor::planned() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensor.planned)
  return _internal_planned();
}
inline void EgmSensor::unsafe_arena_set_allocated_planned(::abb::egm::EgmPlanned* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.planned_);
  }
  _impl_.planned_ = reinterpret_cast<::abb::egm::EgmPlanned*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensor.planned)
}
inline ::abb::egm::EgmPlanned* EgmSensor::release_planned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPlanned* released = _impl_.planned_;
  _impl_.planned_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmPlanned* EgmSensor::unsafe_arena_release_planned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensor.planned)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPlanned* temp = _impl_.planned_;
  _impl_.planned_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPlanned* EgmSensor::_internal_mutable_planned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.planned_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPlanned>(GetArena());
    _impl_.planned_ = reinterpret_cast<::abb::egm::EgmPlanned*>(p);
  }
  return _impl_.planned_;
}
inline ::abb::egm::EgmPlanned* EgmSensor::mutable_planned() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmPlanned* _msg = _internal_mutable_planned();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensor.planned)
  return _msg;
}
inline void EgmSensor::set_allocated_planned(::abb::egm::EgmPlanned* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmPlanned*>(_impl_.planned_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmPlanned*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.planned_ = reinterpret_cast<::abb::egm::EgmPlanned*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensor.planned)
}

// optional .abb.egm.EgmSpeedRef speedRef = 3;
inline bool EgmSensor::has_speedref() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.speedref_ != nullptr);
  return value;
}
inline void EgmSensor::clear_speedref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.speedref_ != nullptr) _impl_.speedref_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmSpeedRef& EgmSensor::_internal_speedref() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmSpeedRef* p = _impl_.speedref_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmSpeedRef&>(::abb::egm::_EgmSpeedRef_default_instance_);
}
inline const ::abb::egm::EgmSpeedRef& EgmSensor::speedref() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensor.speedRef)
  return _internal_speedref();
}
inline void EgmSensor::unsafe_arena_set_allocated_speedref(::abb::egm::EgmSpeedRef* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speedref_);
  }
  _impl_.speedref_ = reinterpret_cast<::abb::egm::EgmSpeedRef*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensor.speedRef)
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::release_speedref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmSpeedRef* released = _impl_.speedref_;
  _impl_.speedref_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::unsafe_arena_release_speedref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensor.speedRef)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmSpeedRef* temp = _impl_.speedref_;
  _impl_.speedref_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::_internal_mutable_speedref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.speedref_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmSpeedRef>(GetArena());
    _impl_.speedref_ = reinterpret_cast<::abb::egm::EgmSpeedRef*>(p);
  }
  return _impl_.speedref_;
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::mutable_speedref() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmSpeedRef* _msg = _internal_mutable_speedref();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensor.speedRef)
  return _msg;
}
inline void EgmSensor::set_allocated_speedref(::abb::egm::EgmSpeedRef* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmSpeedRef*>(_impl_.speedref_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmSpeedRef*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.speedref_ = reinterpret_cast<::abb::egm::EgmSpeedRef*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensor.speedRef)
}

// -------------------------------------------------------------------

// EgmSensorPathCorr

// optional .abb.egm.EgmHeader header = 1;
inline bool EgmSensorPathCorr::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void EgmSensorPathCorr::clear_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmHeader& EgmSensorPathCorr::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmHeader&>(::abb::egm::_EgmHeader_default_instance_);
}
inline const ::abb::egm::EgmHeader& EgmSensorPathCorr::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensorPathCorr.header)
  return _internal_header();
}
inline void EgmSensorPathCorr::unsafe_arena_set_allocated_header(::abb::egm::EgmHeader* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::abb::egm::EgmHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensorPathCorr.header)
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensorPathCorr.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::abb::egm::EgmHeader*>(p);
  }
  return _impl_.header_;
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensorPathCorr.header)
  return _msg;
}
inline void EgmSensorPathCorr::set_allocated_header(::abb::egm::EgmHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmHeader*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmHeader*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::abb::egm::EgmHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensorPathCorr.header)
}

// optional .abb.egm.EgmPathCorr pathCorr = 2;
inline bool EgmSensorPathCorr::has_pathcorr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pathcorr_ != nullptr);
  return value;
}
inline void EgmSensorPathCorr::clear_pathcorr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pathcorr_ != nullptr) _impl_.pathcorr_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmPathCorr& EgmSensorPathCorr::_internal_pathcorr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::EgmPathCorr* p = _impl_.pathcorr_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPathCorr&>(::abb::egm::_EgmPathCorr_default_instance_);
}
inline const ::abb::egm::EgmPathCorr& EgmSensorPathCorr::pathcorr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensorPathCorr.pathCorr)
  return _internal_pathcorr();
}
inline void EgmSensorPathCorr::unsafe_arena_set_allocated_pathcorr(::abb::egm::EgmPathCorr* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pathcorr_);
  }
  _impl_.pathcorr_ = reinterpret_cast<::abb::egm::EgmPathCorr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensorPathCorr.pathCorr)
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::release_pathcorr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPathCorr* released = _impl_.pathcorr_;
  _impl_.pathcorr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::unsafe_arena_release_pathcorr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensorPathCorr.pathCorr)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPathCorr* temp = _impl_.pathcorr_;
  _impl_.pathcorr_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::_internal_mutable_pathcorr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pathcorr_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPathCorr>(GetArena());
    _impl_.pathcorr_ = reinterpret_cast<::abb::egm::EgmPathCorr*>(p);
  }
  return _impl_.pathcorr_;
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::mutable_pathcorr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::EgmPathCorr* _msg = _internal_mutable_pathcorr();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensorPathCorr.pathCorr)
  return _msg;
}
inline void EgmSensorPathCorr::set_allocated_pathcorr(::abb::egm::EgmPathCorr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::EgmPathCorr*>(_impl_.pathcorr_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::EgmPathCorr*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pathcorr_ = reinterpret_cast<::abb::egm::EgmPathCorr*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensorPathCorr.pathCorr)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace egm
}  // namespace abb


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::abb::egm::EgmHeader_MessageType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::egm::EgmHeader_MessageType>() {
  return ::abb::egm::EgmHeader_MessageType_descriptor();
}
template <>
struct is_proto_enum<::abb::egm::EgmMotorState_MotorStateType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::egm::EgmMotorState_MotorStateType>() {
  return ::abb::egm::EgmMotorState_MotorStateType_descriptor();
}
template <>
struct is_proto_enum<::abb::egm::EgmMCIState_MCIStateType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::egm::EgmMCIState_MCIStateType>() {
  return ::abb::egm::EgmMCIState_MCIStateType_descriptor();
}
template <>
struct is_proto_enum<::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType>() {
  return ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_egm_2eproto_2epb_2eh
