// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm_wrapper.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_egm_5fwrapper_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_egm_5fwrapper_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_egm_5fwrapper_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_egm_5fwrapper_2eproto;
namespace abb {
namespace egm {
namespace wrapper {
class Cartesian;
struct CartesianDefaultTypeInternal;
extern CartesianDefaultTypeInternal _Cartesian_default_instance_;
class CartesianPose;
struct CartesianPoseDefaultTypeInternal;
extern CartesianPoseDefaultTypeInternal _CartesianPose_default_instance_;
class CartesianSpace;
struct CartesianSpaceDefaultTypeInternal;
extern CartesianSpaceDefaultTypeInternal _CartesianSpace_default_instance_;
class CartesianVelocity;
struct CartesianVelocityDefaultTypeInternal;
extern CartesianVelocityDefaultTypeInternal _CartesianVelocity_default_instance_;
class Clock;
struct ClockDefaultTypeInternal;
extern ClockDefaultTypeInternal _Clock_default_instance_;
class Euler;
struct EulerDefaultTypeInternal;
extern EulerDefaultTypeInternal _Euler_default_instance_;
class External;
struct ExternalDefaultTypeInternal;
extern ExternalDefaultTypeInternal _External_default_instance_;
class Feedback;
struct FeedbackDefaultTypeInternal;
extern FeedbackDefaultTypeInternal _Feedback_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Input;
struct InputDefaultTypeInternal;
extern InputDefaultTypeInternal _Input_default_instance_;
class JointSpace;
struct JointSpaceDefaultTypeInternal;
extern JointSpaceDefaultTypeInternal _JointSpace_default_instance_;
class Joints;
struct JointsDefaultTypeInternal;
extern JointsDefaultTypeInternal _Joints_default_instance_;
class Output;
struct OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Planned;
struct PlannedDefaultTypeInternal;
extern PlannedDefaultTypeInternal _Planned_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Robot;
struct RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
}  // namespace wrapper
}  // namespace egm
}  // namespace abb
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace abb {
namespace egm {
namespace wrapper {
enum Header_MessageType : int {
  Header_MessageType_UNDEFINED = 0,
  Header_MessageType_DATA = 1,
};

bool Header_MessageType_IsValid(int value);
extern const uint32_t Header_MessageType_internal_data_[];
constexpr Header_MessageType Header_MessageType_MessageType_MIN = static_cast<Header_MessageType>(0);
constexpr Header_MessageType Header_MessageType_MessageType_MAX = static_cast<Header_MessageType>(1);
constexpr int Header_MessageType_MessageType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Header_MessageType_descriptor();
template <typename T>
const std::string& Header_MessageType_Name(T value) {
  static_assert(std::is_same<T, Header_MessageType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MessageType_Name().");
  return Header_MessageType_Name(static_cast<Header_MessageType>(value));
}
template <>
inline const std::string& Header_MessageType_Name(Header_MessageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Header_MessageType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Header_MessageType_Parse(absl::string_view name, Header_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_MessageType>(
      Header_MessageType_descriptor(), name, value);
}
enum Header_RWVersion : int {
  Header_RWVersion_RW_UNKNOWN = 0,
  Header_RWVersion_RW_6_10_AND_NEWER = 1,
  Header_RWVersion_RW_BETWEEN_6_AND_6_06_03 = 2,
  Header_RWVersion_RW_BETWEEN_6_07_AND_6_09_02 = 3,
};

bool Header_RWVersion_IsValid(int value);
extern const uint32_t Header_RWVersion_internal_data_[];
constexpr Header_RWVersion Header_RWVersion_RWVersion_MIN = static_cast<Header_RWVersion>(0);
constexpr Header_RWVersion Header_RWVersion_RWVersion_MAX = static_cast<Header_RWVersion>(3);
constexpr int Header_RWVersion_RWVersion_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Header_RWVersion_descriptor();
template <typename T>
const std::string& Header_RWVersion_Name(T value) {
  static_assert(std::is_same<T, Header_RWVersion>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RWVersion_Name().");
  return Header_RWVersion_Name(static_cast<Header_RWVersion>(value));
}
template <>
inline const std::string& Header_RWVersion_Name(Header_RWVersion value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Header_RWVersion_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Header_RWVersion_Parse(absl::string_view name, Header_RWVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_RWVersion>(
      Header_RWVersion_descriptor(), name, value);
}
enum Header_EGMVersion : int {
  Header_EGMVersion_EGM_UNKNOWN = 0,
  Header_EGMVersion_EGM_1_0 = 1,
  Header_EGMVersion_EGM_1_1 = 2,
};

bool Header_EGMVersion_IsValid(int value);
extern const uint32_t Header_EGMVersion_internal_data_[];
constexpr Header_EGMVersion Header_EGMVersion_EGMVersion_MIN = static_cast<Header_EGMVersion>(0);
constexpr Header_EGMVersion Header_EGMVersion_EGMVersion_MAX = static_cast<Header_EGMVersion>(2);
constexpr int Header_EGMVersion_EGMVersion_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Header_EGMVersion_descriptor();
template <typename T>
const std::string& Header_EGMVersion_Name(T value) {
  static_assert(std::is_same<T, Header_EGMVersion>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EGMVersion_Name().");
  return Header_EGMVersion_Name(static_cast<Header_EGMVersion>(value));
}
template <>
inline const std::string& Header_EGMVersion_Name(Header_EGMVersion value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Header_EGMVersion_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Header_EGMVersion_Parse(absl::string_view name, Header_EGMVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_EGMVersion>(
      Header_EGMVersion_descriptor(), name, value);
}
enum Status_EGMState : int {
  Status_EGMState_EGM_UNDEFINED = 0,
  Status_EGMState_EGM_ERROR = 1,
  Status_EGMState_EGM_STOPPED = 2,
  Status_EGMState_EGM_RUNNING = 3,
};

bool Status_EGMState_IsValid(int value);
extern const uint32_t Status_EGMState_internal_data_[];
constexpr Status_EGMState Status_EGMState_EGMState_MIN = static_cast<Status_EGMState>(0);
constexpr Status_EGMState Status_EGMState_EGMState_MAX = static_cast<Status_EGMState>(3);
constexpr int Status_EGMState_EGMState_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Status_EGMState_descriptor();
template <typename T>
const std::string& Status_EGMState_Name(T value) {
  static_assert(std::is_same<T, Status_EGMState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EGMState_Name().");
  return Status_EGMState_Name(static_cast<Status_EGMState>(value));
}
template <>
inline const std::string& Status_EGMState_Name(Status_EGMState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Status_EGMState_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Status_EGMState_Parse(absl::string_view name, Status_EGMState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_EGMState>(
      Status_EGMState_descriptor(), name, value);
}
enum Status_MotorState : int {
  Status_MotorState_MOTORS_UNDEFINED = 0,
  Status_MotorState_MOTORS_ON = 1,
  Status_MotorState_MOTORS_OFF = 2,
};

bool Status_MotorState_IsValid(int value);
extern const uint32_t Status_MotorState_internal_data_[];
constexpr Status_MotorState Status_MotorState_MotorState_MIN = static_cast<Status_MotorState>(0);
constexpr Status_MotorState Status_MotorState_MotorState_MAX = static_cast<Status_MotorState>(2);
constexpr int Status_MotorState_MotorState_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Status_MotorState_descriptor();
template <typename T>
const std::string& Status_MotorState_Name(T value) {
  static_assert(std::is_same<T, Status_MotorState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MotorState_Name().");
  return Status_MotorState_Name(static_cast<Status_MotorState>(value));
}
template <>
inline const std::string& Status_MotorState_Name(Status_MotorState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Status_MotorState_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Status_MotorState_Parse(absl::string_view name, Status_MotorState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_MotorState>(
      Status_MotorState_descriptor(), name, value);
}
enum Status_RAPIDExecutionState : int {
  Status_RAPIDExecutionState_RAPID_UNDEFINED = 0,
  Status_RAPIDExecutionState_RAPID_STOPPED = 1,
  Status_RAPIDExecutionState_RAPID_RUNNING = 2,
};

bool Status_RAPIDExecutionState_IsValid(int value);
extern const uint32_t Status_RAPIDExecutionState_internal_data_[];
constexpr Status_RAPIDExecutionState Status_RAPIDExecutionState_RAPIDExecutionState_MIN = static_cast<Status_RAPIDExecutionState>(0);
constexpr Status_RAPIDExecutionState Status_RAPIDExecutionState_RAPIDExecutionState_MAX = static_cast<Status_RAPIDExecutionState>(2);
constexpr int Status_RAPIDExecutionState_RAPIDExecutionState_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Status_RAPIDExecutionState_descriptor();
template <typename T>
const std::string& Status_RAPIDExecutionState_Name(T value) {
  static_assert(std::is_same<T, Status_RAPIDExecutionState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RAPIDExecutionState_Name().");
  return Status_RAPIDExecutionState_Name(static_cast<Status_RAPIDExecutionState>(value));
}
template <>
inline const std::string& Status_RAPIDExecutionState_Name(Status_RAPIDExecutionState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Status_RAPIDExecutionState_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Status_RAPIDExecutionState_Parse(absl::string_view name, Status_RAPIDExecutionState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_RAPIDExecutionState>(
      Status_RAPIDExecutionState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Status final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Status(::google::protobuf::internal::ConstantInitialized);

  inline Status(const Status& from)
      : Status(nullptr, from) {}
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Status* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.Status";
  }
  protected:
  explicit Status(::google::protobuf::Arena* arena);
  Status(::google::protobuf::Arena* arena, const Status& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using EGMState = Status_EGMState;
  static constexpr EGMState EGM_UNDEFINED = Status_EGMState_EGM_UNDEFINED;
  static constexpr EGMState EGM_ERROR = Status_EGMState_EGM_ERROR;
  static constexpr EGMState EGM_STOPPED = Status_EGMState_EGM_STOPPED;
  static constexpr EGMState EGM_RUNNING = Status_EGMState_EGM_RUNNING;
  static inline bool EGMState_IsValid(int value) {
    return Status_EGMState_IsValid(value);
  }
  static constexpr EGMState EGMState_MIN = Status_EGMState_EGMState_MIN;
  static constexpr EGMState EGMState_MAX = Status_EGMState_EGMState_MAX;
  static constexpr int EGMState_ARRAYSIZE = Status_EGMState_EGMState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* EGMState_descriptor() {
    return Status_EGMState_descriptor();
  }
  template <typename T>
  static inline const std::string& EGMState_Name(T value) {
    return Status_EGMState_Name(value);
  }
  static inline bool EGMState_Parse(absl::string_view name, EGMState* value) {
    return Status_EGMState_Parse(name, value);
  }

  using MotorState = Status_MotorState;
  static constexpr MotorState MOTORS_UNDEFINED = Status_MotorState_MOTORS_UNDEFINED;
  static constexpr MotorState MOTORS_ON = Status_MotorState_MOTORS_ON;
  static constexpr MotorState MOTORS_OFF = Status_MotorState_MOTORS_OFF;
  static inline bool MotorState_IsValid(int value) {
    return Status_MotorState_IsValid(value);
  }
  static constexpr MotorState MotorState_MIN = Status_MotorState_MotorState_MIN;
  static constexpr MotorState MotorState_MAX = Status_MotorState_MotorState_MAX;
  static constexpr int MotorState_ARRAYSIZE = Status_MotorState_MotorState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MotorState_descriptor() {
    return Status_MotorState_descriptor();
  }
  template <typename T>
  static inline const std::string& MotorState_Name(T value) {
    return Status_MotorState_Name(value);
  }
  static inline bool MotorState_Parse(absl::string_view name, MotorState* value) {
    return Status_MotorState_Parse(name, value);
  }

  using RAPIDExecutionState = Status_RAPIDExecutionState;
  static constexpr RAPIDExecutionState RAPID_UNDEFINED = Status_RAPIDExecutionState_RAPID_UNDEFINED;
  static constexpr RAPIDExecutionState RAPID_STOPPED = Status_RAPIDExecutionState_RAPID_STOPPED;
  static constexpr RAPIDExecutionState RAPID_RUNNING = Status_RAPIDExecutionState_RAPID_RUNNING;
  static inline bool RAPIDExecutionState_IsValid(int value) {
    return Status_RAPIDExecutionState_IsValid(value);
  }
  static constexpr RAPIDExecutionState RAPIDExecutionState_MIN = Status_RAPIDExecutionState_RAPIDExecutionState_MIN;
  static constexpr RAPIDExecutionState RAPIDExecutionState_MAX = Status_RAPIDExecutionState_RAPIDExecutionState_MAX;
  static constexpr int RAPIDExecutionState_ARRAYSIZE = Status_RAPIDExecutionState_RAPIDExecutionState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RAPIDExecutionState_descriptor() {
    return Status_RAPIDExecutionState_descriptor();
  }
  template <typename T>
  static inline const std::string& RAPIDExecutionState_Name(T value) {
    return Status_RAPIDExecutionState_Name(value);
  }
  static inline bool RAPIDExecutionState_Parse(absl::string_view name, RAPIDExecutionState* value) {
    return Status_RAPIDExecutionState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEgmConvergenceMetFieldNumber = 1,
    kEgmStateFieldNumber = 2,
    kMotorStateFieldNumber = 3,
    kRapidExecutionStateFieldNumber = 4,
    kUtilizationRateFieldNumber = 5,
  };
  // optional bool egm_convergence_met = 1;
  bool has_egm_convergence_met() const;
  void clear_egm_convergence_met() ;
  bool egm_convergence_met() const;
  void set_egm_convergence_met(bool value);

  private:
  bool _internal_egm_convergence_met() const;
  void _internal_set_egm_convergence_met(bool value);

  public:
  // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
  bool has_egm_state() const;
  void clear_egm_state() ;
  ::abb::egm::wrapper::Status_EGMState egm_state() const;
  void set_egm_state(::abb::egm::wrapper::Status_EGMState value);

  private:
  ::abb::egm::wrapper::Status_EGMState _internal_egm_state() const;
  void _internal_set_egm_state(::abb::egm::wrapper::Status_EGMState value);

  public:
  // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
  bool has_motor_state() const;
  void clear_motor_state() ;
  ::abb::egm::wrapper::Status_MotorState motor_state() const;
  void set_motor_state(::abb::egm::wrapper::Status_MotorState value);

  private:
  ::abb::egm::wrapper::Status_MotorState _internal_motor_state() const;
  void _internal_set_motor_state(::abb::egm::wrapper::Status_MotorState value);

  public:
  // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
  bool has_rapid_execution_state() const;
  void clear_rapid_execution_state() ;
  ::abb::egm::wrapper::Status_RAPIDExecutionState rapid_execution_state() const;
  void set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value);

  private:
  ::abb::egm::wrapper::Status_RAPIDExecutionState _internal_rapid_execution_state() const;
  void _internal_set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value);

  public:
  // optional double utilization_rate = 5;
  bool has_utilization_rate() const;
  void clear_utilization_rate() ;
  double utilization_rate() const;
  void set_utilization_rate(double value);

  private:
  double _internal_utilization_rate() const;
  void _internal_set_utilization_rate(double value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Status)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool egm_convergence_met_;
    int egm_state_;
    int motor_state_;
    int rapid_execution_state_;
    double utilization_rate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class Quaternion final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Quaternion(::google::protobuf::internal::ConstantInitialized);

  inline Quaternion(const Quaternion& from)
      : Quaternion(nullptr, from) {}
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Quaternion& from) {
    Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Quaternion* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.Quaternion";
  }
  protected:
  explicit Quaternion(::google::protobuf::Arena* arena);
  Quaternion(::google::protobuf::Arena* arena, const Quaternion& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kU0FieldNumber = 1,
    kU1FieldNumber = 2,
    kU2FieldNumber = 3,
    kU3FieldNumber = 4,
  };
  // optional double u0 = 1;
  bool has_u0() const;
  void clear_u0() ;
  double u0() const;
  void set_u0(double value);

  private:
  double _internal_u0() const;
  void _internal_set_u0(double value);

  public:
  // optional double u1 = 2;
  bool has_u1() const;
  void clear_u1() ;
  double u1() const;
  void set_u1(double value);

  private:
  double _internal_u1() const;
  void _internal_set_u1(double value);

  public:
  // optional double u2 = 3;
  bool has_u2() const;
  void clear_u2() ;
  double u2() const;
  void set_u2(double value);

  private:
  double _internal_u2() const;
  void _internal_set_u2(double value);

  public:
  // optional double u3 = 4;
  bool has_u3() const;
  void clear_u3() ;
  double u3() const;
  void set_u3(double value);

  private:
  double _internal_u3() const;
  void _internal_set_u3(double value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Quaternion)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double u0_;
    double u1_;
    double u2_;
    double u3_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class Joints final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Joints) */ {
 public:
  inline Joints() : Joints(nullptr) {}
  ~Joints() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Joints(::google::protobuf::internal::ConstantInitialized);

  inline Joints(const Joints& from)
      : Joints(nullptr, from) {}
  Joints(Joints&& from) noexcept
    : Joints() {
    *this = ::std::move(from);
  }

  inline Joints& operator=(const Joints& from) {
    CopyFrom(from);
    return *this;
  }
  inline Joints& operator=(Joints&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Joints& default_instance() {
    return *internal_default_instance();
  }
  static inline const Joints* internal_default_instance() {
    return reinterpret_cast<const Joints*>(
               &_Joints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Joints& a, Joints& b) {
    a.Swap(&b);
  }
  inline void Swap(Joints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Joints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Joints* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Joints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Joints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Joints& from) {
    Joints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Joints* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.Joints";
  }
  protected:
  explicit Joints(::google::protobuf::Arena* arena);
  Joints(::google::protobuf::Arena* arena, const Joints& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated double values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::google::protobuf::RepeatedField<double>& values() const;
  ::google::protobuf::RepeatedField<double>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_values() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Joints)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class Header final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Header(::google::protobuf::internal::ConstantInitialized);

  inline Header(const Header& from)
      : Header(nullptr, from) {}
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Header* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.Header";
  }
  protected:
  explicit Header(::google::protobuf::Arena* arena);
  Header(::google::protobuf::Arena* arena, const Header& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using MessageType = Header_MessageType;
  static constexpr MessageType UNDEFINED = Header_MessageType_UNDEFINED;
  static constexpr MessageType DATA = Header_MessageType_DATA;
  static inline bool MessageType_IsValid(int value) {
    return Header_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN = Header_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX = Header_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE = Header_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MessageType_descriptor() {
    return Header_MessageType_descriptor();
  }
  template <typename T>
  static inline const std::string& MessageType_Name(T value) {
    return Header_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(absl::string_view name, MessageType* value) {
    return Header_MessageType_Parse(name, value);
  }

  using RWVersion = Header_RWVersion;
  static constexpr RWVersion RW_UNKNOWN = Header_RWVersion_RW_UNKNOWN;
  static constexpr RWVersion RW_6_10_AND_NEWER = Header_RWVersion_RW_6_10_AND_NEWER;
  static constexpr RWVersion RW_BETWEEN_6_AND_6_06_03 = Header_RWVersion_RW_BETWEEN_6_AND_6_06_03;
  static constexpr RWVersion RW_BETWEEN_6_07_AND_6_09_02 = Header_RWVersion_RW_BETWEEN_6_07_AND_6_09_02;
  static inline bool RWVersion_IsValid(int value) {
    return Header_RWVersion_IsValid(value);
  }
  static constexpr RWVersion RWVersion_MIN = Header_RWVersion_RWVersion_MIN;
  static constexpr RWVersion RWVersion_MAX = Header_RWVersion_RWVersion_MAX;
  static constexpr int RWVersion_ARRAYSIZE = Header_RWVersion_RWVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RWVersion_descriptor() {
    return Header_RWVersion_descriptor();
  }
  template <typename T>
  static inline const std::string& RWVersion_Name(T value) {
    return Header_RWVersion_Name(value);
  }
  static inline bool RWVersion_Parse(absl::string_view name, RWVersion* value) {
    return Header_RWVersion_Parse(name, value);
  }

  using EGMVersion = Header_EGMVersion;
  static constexpr EGMVersion EGM_UNKNOWN = Header_EGMVersion_EGM_UNKNOWN;
  static constexpr EGMVersion EGM_1_0 = Header_EGMVersion_EGM_1_0;
  static constexpr EGMVersion EGM_1_1 = Header_EGMVersion_EGM_1_1;
  static inline bool EGMVersion_IsValid(int value) {
    return Header_EGMVersion_IsValid(value);
  }
  static constexpr EGMVersion EGMVersion_MIN = Header_EGMVersion_EGMVersion_MIN;
  static constexpr EGMVersion EGMVersion_MAX = Header_EGMVersion_EGMVersion_MAX;
  static constexpr int EGMVersion_ARRAYSIZE = Header_EGMVersion_EGMVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* EGMVersion_descriptor() {
    return Header_EGMVersion_descriptor();
  }
  template <typename T>
  static inline const std::string& EGMVersion_Name(T value) {
    return Header_EGMVersion_Name(value);
  }
  static inline bool EGMVersion_Parse(absl::string_view name, EGMVersion* value) {
    return Header_EGMVersion_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceNumberFieldNumber = 1,
    kTimeStampFieldNumber = 2,
    kMessageTypeFieldNumber = 3,
    kRwVersionFieldNumber = 4,
    kEgmVersionFieldNumber = 5,
  };
  // optional uint32 sequence_number = 1;
  bool has_sequence_number() const;
  void clear_sequence_number() ;
  ::uint32_t sequence_number() const;
  void set_sequence_number(::uint32_t value);

  private:
  ::uint32_t _internal_sequence_number() const;
  void _internal_set_sequence_number(::uint32_t value);

  public:
  // optional uint32 time_stamp = 2;
  bool has_time_stamp() const;
  void clear_time_stamp() ;
  ::uint32_t time_stamp() const;
  void set_time_stamp(::uint32_t value);

  private:
  ::uint32_t _internal_time_stamp() const;
  void _internal_set_time_stamp(::uint32_t value);

  public:
  // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
  bool has_message_type() const;
  void clear_message_type() ;
  ::abb::egm::wrapper::Header_MessageType message_type() const;
  void set_message_type(::abb::egm::wrapper::Header_MessageType value);

  private:
  ::abb::egm::wrapper::Header_MessageType _internal_message_type() const;
  void _internal_set_message_type(::abb::egm::wrapper::Header_MessageType value);

  public:
  // optional .abb.egm.wrapper.Header.RWVersion rw_version = 4 [default = RW_UNKNOWN];
  bool has_rw_version() const;
  void clear_rw_version() ;
  ::abb::egm::wrapper::Header_RWVersion rw_version() const;
  void set_rw_version(::abb::egm::wrapper::Header_RWVersion value);

  private:
  ::abb::egm::wrapper::Header_RWVersion _internal_rw_version() const;
  void _internal_set_rw_version(::abb::egm::wrapper::Header_RWVersion value);

  public:
  // optional .abb.egm.wrapper.Header.EGMVersion egm_version = 5 [default = EGM_UNKNOWN];
  bool has_egm_version() const;
  void clear_egm_version() ;
  ::abb::egm::wrapper::Header_EGMVersion egm_version() const;
  void set_egm_version(::abb::egm::wrapper::Header_EGMVersion value);

  private:
  ::abb::egm::wrapper::Header_EGMVersion _internal_egm_version() const;
  void _internal_set_egm_version(::abb::egm::wrapper::Header_EGMVersion value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Header)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t sequence_number_;
    ::uint32_t time_stamp_;
    int message_type_;
    int rw_version_;
    int egm_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class Euler final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Euler) */ {
 public:
  inline Euler() : Euler(nullptr) {}
  ~Euler() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Euler(::google::protobuf::internal::ConstantInitialized);

  inline Euler(const Euler& from)
      : Euler(nullptr, from) {}
  Euler(Euler&& from) noexcept
    : Euler() {
    *this = ::std::move(from);
  }

  inline Euler& operator=(const Euler& from) {
    CopyFrom(from);
    return *this;
  }
  inline Euler& operator=(Euler&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Euler& default_instance() {
    return *internal_default_instance();
  }
  static inline const Euler* internal_default_instance() {
    return reinterpret_cast<const Euler*>(
               &_Euler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Euler& a, Euler& b) {
    a.Swap(&b);
  }
  inline void Swap(Euler* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Euler* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Euler* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Euler>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Euler& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Euler& from) {
    Euler::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Euler* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.Euler";
  }
  protected:
  explicit Euler(::google::protobuf::Arena* arena);
  Euler(::google::protobuf::Arena* arena, const Euler& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional double x = 1;
  bool has_x() const;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // optional double y = 2;
  bool has_y() const;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // optional double z = 3;
  bool has_z() const;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Euler)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class Clock final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Clock) */ {
 public:
  inline Clock() : Clock(nullptr) {}
  ~Clock() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Clock(::google::protobuf::internal::ConstantInitialized);

  inline Clock(const Clock& from)
      : Clock(nullptr, from) {}
  Clock(Clock&& from) noexcept
    : Clock() {
    *this = ::std::move(from);
  }

  inline Clock& operator=(const Clock& from) {
    CopyFrom(from);
    return *this;
  }
  inline Clock& operator=(Clock&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Clock& default_instance() {
    return *internal_default_instance();
  }
  static inline const Clock* internal_default_instance() {
    return reinterpret_cast<const Clock*>(
               &_Clock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Clock& a, Clock& b) {
    a.Swap(&b);
  }
  inline void Swap(Clock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Clock* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Clock* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Clock>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Clock& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Clock& from) {
    Clock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Clock* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.Clock";
  }
  protected:
  explicit Clock(::google::protobuf::Arena* arena);
  Clock(::google::protobuf::Arena* arena, const Clock& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecFieldNumber = 1,
    kUsecFieldNumber = 2,
  };
  // optional uint64 sec = 1;
  bool has_sec() const;
  void clear_sec() ;
  ::uint64_t sec() const;
  void set_sec(::uint64_t value);

  private:
  ::uint64_t _internal_sec() const;
  void _internal_set_sec(::uint64_t value);

  public:
  // optional uint64 usec = 2;
  bool has_usec() const;
  void clear_usec() ;
  ::uint64_t usec() const;
  void set_usec(::uint64_t value);

  private:
  ::uint64_t _internal_usec() const;
  void _internal_set_usec(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Clock)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t sec_;
    ::uint64_t usec_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class Cartesian final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Cartesian) */ {
 public:
  inline Cartesian() : Cartesian(nullptr) {}
  ~Cartesian() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Cartesian(::google::protobuf::internal::ConstantInitialized);

  inline Cartesian(const Cartesian& from)
      : Cartesian(nullptr, from) {}
  Cartesian(Cartesian&& from) noexcept
    : Cartesian() {
    *this = ::std::move(from);
  }

  inline Cartesian& operator=(const Cartesian& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cartesian& operator=(Cartesian&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cartesian& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cartesian* internal_default_instance() {
    return reinterpret_cast<const Cartesian*>(
               &_Cartesian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Cartesian& a, Cartesian& b) {
    a.Swap(&b);
  }
  inline void Swap(Cartesian* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cartesian* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cartesian* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cartesian>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Cartesian& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Cartesian& from) {
    Cartesian::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Cartesian* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.Cartesian";
  }
  protected:
  explicit Cartesian(::google::protobuf::Arena* arena);
  Cartesian(::google::protobuf::Arena* arena, const Cartesian& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional double x = 1;
  bool has_x() const;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // optional double y = 2;
  bool has_y() const;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // optional double z = 3;
  bool has_z() const;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Cartesian)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class JointSpace final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.JointSpace) */ {
 public:
  inline JointSpace() : JointSpace(nullptr) {}
  ~JointSpace() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JointSpace(::google::protobuf::internal::ConstantInitialized);

  inline JointSpace(const JointSpace& from)
      : JointSpace(nullptr, from) {}
  JointSpace(JointSpace&& from) noexcept
    : JointSpace() {
    *this = ::std::move(from);
  }

  inline JointSpace& operator=(const JointSpace& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointSpace& operator=(JointSpace&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JointSpace& default_instance() {
    return *internal_default_instance();
  }
  static inline const JointSpace* internal_default_instance() {
    return reinterpret_cast<const JointSpace*>(
               &_JointSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JointSpace& a, JointSpace& b) {
    a.Swap(&b);
  }
  inline void Swap(JointSpace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointSpace* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JointSpace* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JointSpace>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JointSpace& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const JointSpace& from) {
    JointSpace::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JointSpace* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.JointSpace";
  }
  protected:
  explicit JointSpace(::google::protobuf::Arena* arena);
  JointSpace(::google::protobuf::Arena* arena, const JointSpace& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kVelocityFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.Joints position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::abb::egm::wrapper::Joints& position() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Joints* release_position();
  ::abb::egm::wrapper::Joints* mutable_position();
  void set_allocated_position(::abb::egm::wrapper::Joints* value);
  void unsafe_arena_set_allocated_position(::abb::egm::wrapper::Joints* value);
  ::abb::egm::wrapper::Joints* unsafe_arena_release_position();

  private:
  const ::abb::egm::wrapper::Joints& _internal_position() const;
  ::abb::egm::wrapper::Joints* _internal_mutable_position();

  public:
  // optional .abb.egm.wrapper.Joints velocity = 2;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::abb::egm::wrapper::Joints& velocity() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Joints* release_velocity();
  ::abb::egm::wrapper::Joints* mutable_velocity();
  void set_allocated_velocity(::abb::egm::wrapper::Joints* value);
  void unsafe_arena_set_allocated_velocity(::abb::egm::wrapper::Joints* value);
  ::abb::egm::wrapper::Joints* unsafe_arena_release_velocity();

  private:
  const ::abb::egm::wrapper::Joints& _internal_velocity() const;
  ::abb::egm::wrapper::Joints* _internal_mutable_velocity();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.JointSpace)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Joints* position_;
    ::abb::egm::wrapper::Joints* velocity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class CartesianVelocity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.CartesianVelocity) */ {
 public:
  inline CartesianVelocity() : CartesianVelocity(nullptr) {}
  ~CartesianVelocity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CartesianVelocity(::google::protobuf::internal::ConstantInitialized);

  inline CartesianVelocity(const CartesianVelocity& from)
      : CartesianVelocity(nullptr, from) {}
  CartesianVelocity(CartesianVelocity&& from) noexcept
    : CartesianVelocity() {
    *this = ::std::move(from);
  }

  inline CartesianVelocity& operator=(const CartesianVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline CartesianVelocity& operator=(CartesianVelocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CartesianVelocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const CartesianVelocity* internal_default_instance() {
    return reinterpret_cast<const CartesianVelocity*>(
               &_CartesianVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CartesianVelocity& a, CartesianVelocity& b) {
    a.Swap(&b);
  }
  inline void Swap(CartesianVelocity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CartesianVelocity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CartesianVelocity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CartesianVelocity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CartesianVelocity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CartesianVelocity& from) {
    CartesianVelocity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CartesianVelocity* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.CartesianVelocity";
  }
  protected:
  explicit CartesianVelocity(::google::protobuf::Arena* arena);
  CartesianVelocity(::google::protobuf::Arena* arena, const CartesianVelocity& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.Cartesian linear = 1;
  bool has_linear() const;
  void clear_linear() ;
  const ::abb::egm::wrapper::Cartesian& linear() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Cartesian* release_linear();
  ::abb::egm::wrapper::Cartesian* mutable_linear();
  void set_allocated_linear(::abb::egm::wrapper::Cartesian* value);
  void unsafe_arena_set_allocated_linear(::abb::egm::wrapper::Cartesian* value);
  ::abb::egm::wrapper::Cartesian* unsafe_arena_release_linear();

  private:
  const ::abb::egm::wrapper::Cartesian& _internal_linear() const;
  ::abb::egm::wrapper::Cartesian* _internal_mutable_linear();

  public:
  // optional .abb.egm.wrapper.Euler angular = 2;
  bool has_angular() const;
  void clear_angular() ;
  const ::abb::egm::wrapper::Euler& angular() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Euler* release_angular();
  ::abb::egm::wrapper::Euler* mutable_angular();
  void set_allocated_angular(::abb::egm::wrapper::Euler* value);
  void unsafe_arena_set_allocated_angular(::abb::egm::wrapper::Euler* value);
  ::abb::egm::wrapper::Euler* unsafe_arena_release_angular();

  private:
  const ::abb::egm::wrapper::Euler& _internal_angular() const;
  ::abb::egm::wrapper::Euler* _internal_mutable_angular();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianVelocity)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Cartesian* linear_;
    ::abb::egm::wrapper::Euler* angular_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class CartesianPose final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.CartesianPose) */ {
 public:
  inline CartesianPose() : CartesianPose(nullptr) {}
  ~CartesianPose() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CartesianPose(::google::protobuf::internal::ConstantInitialized);

  inline CartesianPose(const CartesianPose& from)
      : CartesianPose(nullptr, from) {}
  CartesianPose(CartesianPose&& from) noexcept
    : CartesianPose() {
    *this = ::std::move(from);
  }

  inline CartesianPose& operator=(const CartesianPose& from) {
    CopyFrom(from);
    return *this;
  }
  inline CartesianPose& operator=(CartesianPose&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CartesianPose& default_instance() {
    return *internal_default_instance();
  }
  static inline const CartesianPose* internal_default_instance() {
    return reinterpret_cast<const CartesianPose*>(
               &_CartesianPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CartesianPose& a, CartesianPose& b) {
    a.Swap(&b);
  }
  inline void Swap(CartesianPose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CartesianPose* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CartesianPose* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CartesianPose>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CartesianPose& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CartesianPose& from) {
    CartesianPose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CartesianPose* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.CartesianPose";
  }
  protected:
  explicit CartesianPose(::google::protobuf::Arena* arena);
  CartesianPose(::google::protobuf::Arena* arena, const CartesianPose& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kEulerFieldNumber = 2,
    kQuaternionFieldNumber = 3,
  };
  // optional .abb.egm.wrapper.Cartesian position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::abb::egm::wrapper::Cartesian& position() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Cartesian* release_position();
  ::abb::egm::wrapper::Cartesian* mutable_position();
  void set_allocated_position(::abb::egm::wrapper::Cartesian* value);
  void unsafe_arena_set_allocated_position(::abb::egm::wrapper::Cartesian* value);
  ::abb::egm::wrapper::Cartesian* unsafe_arena_release_position();

  private:
  const ::abb::egm::wrapper::Cartesian& _internal_position() const;
  ::abb::egm::wrapper::Cartesian* _internal_mutable_position();

  public:
  // optional .abb.egm.wrapper.Euler euler = 2;
  bool has_euler() const;
  void clear_euler() ;
  const ::abb::egm::wrapper::Euler& euler() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Euler* release_euler();
  ::abb::egm::wrapper::Euler* mutable_euler();
  void set_allocated_euler(::abb::egm::wrapper::Euler* value);
  void unsafe_arena_set_allocated_euler(::abb::egm::wrapper::Euler* value);
  ::abb::egm::wrapper::Euler* unsafe_arena_release_euler();

  private:
  const ::abb::egm::wrapper::Euler& _internal_euler() const;
  ::abb::egm::wrapper::Euler* _internal_mutable_euler();

  public:
  // optional .abb.egm.wrapper.Quaternion quaternion = 3;
  bool has_quaternion() const;
  void clear_quaternion() ;
  const ::abb::egm::wrapper::Quaternion& quaternion() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Quaternion* release_quaternion();
  ::abb::egm::wrapper::Quaternion* mutable_quaternion();
  void set_allocated_quaternion(::abb::egm::wrapper::Quaternion* value);
  void unsafe_arena_set_allocated_quaternion(::abb::egm::wrapper::Quaternion* value);
  ::abb::egm::wrapper::Quaternion* unsafe_arena_release_quaternion();

  private:
  const ::abb::egm::wrapper::Quaternion& _internal_quaternion() const;
  ::abb::egm::wrapper::Quaternion* _internal_mutable_quaternion();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianPose)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Cartesian* position_;
    ::abb::egm::wrapper::Euler* euler_;
    ::abb::egm::wrapper::Quaternion* quaternion_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class External final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.External) */ {
 public:
  inline External() : External(nullptr) {}
  ~External() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR External(::google::protobuf::internal::ConstantInitialized);

  inline External(const External& from)
      : External(nullptr, from) {}
  External(External&& from) noexcept
    : External() {
    *this = ::std::move(from);
  }

  inline External& operator=(const External& from) {
    CopyFrom(from);
    return *this;
  }
  inline External& operator=(External&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const External& default_instance() {
    return *internal_default_instance();
  }
  static inline const External* internal_default_instance() {
    return reinterpret_cast<const External*>(
               &_External_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(External& a, External& b) {
    a.Swap(&b);
  }
  inline void Swap(External* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(External* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  External* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<External>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const External& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const External& from) {
    External::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(External* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.External";
  }
  protected:
  explicit External(::google::protobuf::Arena* arena);
  External(::google::protobuf::Arena* arena, const External& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
  };
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  bool has_joints() const;
  void clear_joints() ;
  const ::abb::egm::wrapper::JointSpace& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::JointSpace* release_joints();
  ::abb::egm::wrapper::JointSpace* mutable_joints();
  void set_allocated_joints(::abb::egm::wrapper::JointSpace* value);
  void unsafe_arena_set_allocated_joints(::abb::egm::wrapper::JointSpace* value);
  ::abb::egm::wrapper::JointSpace* unsafe_arena_release_joints();

  private:
  const ::abb::egm::wrapper::JointSpace& _internal_joints() const;
  ::abb::egm::wrapper::JointSpace* _internal_mutable_joints();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.External)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::JointSpace* joints_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class CartesianSpace final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.CartesianSpace) */ {
 public:
  inline CartesianSpace() : CartesianSpace(nullptr) {}
  ~CartesianSpace() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CartesianSpace(::google::protobuf::internal::ConstantInitialized);

  inline CartesianSpace(const CartesianSpace& from)
      : CartesianSpace(nullptr, from) {}
  CartesianSpace(CartesianSpace&& from) noexcept
    : CartesianSpace() {
    *this = ::std::move(from);
  }

  inline CartesianSpace& operator=(const CartesianSpace& from) {
    CopyFrom(from);
    return *this;
  }
  inline CartesianSpace& operator=(CartesianSpace&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CartesianSpace& default_instance() {
    return *internal_default_instance();
  }
  static inline const CartesianSpace* internal_default_instance() {
    return reinterpret_cast<const CartesianSpace*>(
               &_CartesianSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CartesianSpace& a, CartesianSpace& b) {
    a.Swap(&b);
  }
  inline void Swap(CartesianSpace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CartesianSpace* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CartesianSpace* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CartesianSpace>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CartesianSpace& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CartesianSpace& from) {
    CartesianSpace::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CartesianSpace* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.CartesianSpace";
  }
  protected:
  explicit CartesianSpace(::google::protobuf::Arena* arena);
  CartesianSpace(::google::protobuf::Arena* arena, const CartesianSpace& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
    kVelocityFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  bool has_pose() const;
  void clear_pose() ;
  const ::abb::egm::wrapper::CartesianPose& pose() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::CartesianPose* release_pose();
  ::abb::egm::wrapper::CartesianPose* mutable_pose();
  void set_allocated_pose(::abb::egm::wrapper::CartesianPose* value);
  void unsafe_arena_set_allocated_pose(::abb::egm::wrapper::CartesianPose* value);
  ::abb::egm::wrapper::CartesianPose* unsafe_arena_release_pose();

  private:
  const ::abb::egm::wrapper::CartesianPose& _internal_pose() const;
  ::abb::egm::wrapper::CartesianPose* _internal_mutable_pose();

  public:
  // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::abb::egm::wrapper::CartesianVelocity& velocity() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::CartesianVelocity* release_velocity();
  ::abb::egm::wrapper::CartesianVelocity* mutable_velocity();
  void set_allocated_velocity(::abb::egm::wrapper::CartesianVelocity* value);
  void unsafe_arena_set_allocated_velocity(::abb::egm::wrapper::CartesianVelocity* value);
  ::abb::egm::wrapper::CartesianVelocity* unsafe_arena_release_velocity();

  private:
  const ::abb::egm::wrapper::CartesianVelocity& _internal_velocity() const;
  ::abb::egm::wrapper::CartesianVelocity* _internal_mutable_velocity();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianSpace)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::CartesianPose* pose_;
    ::abb::egm::wrapper::CartesianVelocity* velocity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class Robot final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Robot) */ {
 public:
  inline Robot() : Robot(nullptr) {}
  ~Robot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Robot(::google::protobuf::internal::ConstantInitialized);

  inline Robot(const Robot& from)
      : Robot(nullptr, from) {}
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot& operator=(Robot&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Robot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Robot& from) {
    Robot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Robot* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.Robot";
  }
  protected:
  explicit Robot(::google::protobuf::Arena* arena);
  Robot(::google::protobuf::Arena* arena, const Robot& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesianFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  bool has_joints() const;
  void clear_joints() ;
  const ::abb::egm::wrapper::JointSpace& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::JointSpace* release_joints();
  ::abb::egm::wrapper::JointSpace* mutable_joints();
  void set_allocated_joints(::abb::egm::wrapper::JointSpace* value);
  void unsafe_arena_set_allocated_joints(::abb::egm::wrapper::JointSpace* value);
  ::abb::egm::wrapper::JointSpace* unsafe_arena_release_joints();

  private:
  const ::abb::egm::wrapper::JointSpace& _internal_joints() const;
  ::abb::egm::wrapper::JointSpace* _internal_mutable_joints();

  public:
  // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
  bool has_cartesian() const;
  void clear_cartesian() ;
  const ::abb::egm::wrapper::CartesianSpace& cartesian() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::CartesianSpace* release_cartesian();
  ::abb::egm::wrapper::CartesianSpace* mutable_cartesian();
  void set_allocated_cartesian(::abb::egm::wrapper::CartesianSpace* value);
  void unsafe_arena_set_allocated_cartesian(::abb::egm::wrapper::CartesianSpace* value);
  ::abb::egm::wrapper::CartesianSpace* unsafe_arena_release_cartesian();

  private:
  const ::abb::egm::wrapper::CartesianSpace& _internal_cartesian() const;
  ::abb::egm::wrapper::CartesianSpace* _internal_mutable_cartesian();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Robot)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::JointSpace* joints_;
    ::abb::egm::wrapper::CartesianSpace* cartesian_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class Planned final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Planned) */ {
 public:
  inline Planned() : Planned(nullptr) {}
  ~Planned() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Planned(::google::protobuf::internal::ConstantInitialized);

  inline Planned(const Planned& from)
      : Planned(nullptr, from) {}
  Planned(Planned&& from) noexcept
    : Planned() {
    *this = ::std::move(from);
  }

  inline Planned& operator=(const Planned& from) {
    CopyFrom(from);
    return *this;
  }
  inline Planned& operator=(Planned&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Planned& default_instance() {
    return *internal_default_instance();
  }
  static inline const Planned* internal_default_instance() {
    return reinterpret_cast<const Planned*>(
               &_Planned_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Planned& a, Planned& b) {
    a.Swap(&b);
  }
  inline void Swap(Planned* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Planned* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Planned* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Planned>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Planned& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Planned& from) {
    Planned::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Planned* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.Planned";
  }
  protected:
  explicit Planned(::google::protobuf::Arena* arena);
  Planned(::google::protobuf::Arena* arena, const Planned& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
    kExternalFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // optional .abb.egm.wrapper.Robot robot = 1;
  bool has_robot() const;
  void clear_robot() ;
  const ::abb::egm::wrapper::Robot& robot() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Robot* release_robot();
  ::abb::egm::wrapper::Robot* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::Robot* value);
  void unsafe_arena_set_allocated_robot(::abb::egm::wrapper::Robot* value);
  ::abb::egm::wrapper::Robot* unsafe_arena_release_robot();

  private:
  const ::abb::egm::wrapper::Robot& _internal_robot() const;
  ::abb::egm::wrapper::Robot* _internal_mutable_robot();

  public:
  // optional .abb.egm.wrapper.External external = 2;
  bool has_external() const;
  void clear_external() ;
  const ::abb::egm::wrapper::External& external() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::External* release_external();
  ::abb::egm::wrapper::External* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::External* value);
  void unsafe_arena_set_allocated_external(::abb::egm::wrapper::External* value);
  ::abb::egm::wrapper::External* unsafe_arena_release_external();

  private:
  const ::abb::egm::wrapper::External& _internal_external() const;
  ::abb::egm::wrapper::External* _internal_mutable_external();

  public:
  // optional .abb.egm.wrapper.Clock time = 3;
  bool has_time() const;
  void clear_time() ;
  const ::abb::egm::wrapper::Clock& time() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Clock* release_time();
  ::abb::egm::wrapper::Clock* mutable_time();
  void set_allocated_time(::abb::egm::wrapper::Clock* value);
  void unsafe_arena_set_allocated_time(::abb::egm::wrapper::Clock* value);
  ::abb::egm::wrapper::Clock* unsafe_arena_release_time();

  private:
  const ::abb::egm::wrapper::Clock& _internal_time() const;
  ::abb::egm::wrapper::Clock* _internal_mutable_time();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Planned)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Robot* robot_;
    ::abb::egm::wrapper::External* external_;
    ::abb::egm::wrapper::Clock* time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class Output final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Output) */ {
 public:
  inline Output() : Output(nullptr) {}
  ~Output() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Output(::google::protobuf::internal::ConstantInitialized);

  inline Output(const Output& from)
      : Output(nullptr, from) {}
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  inline Output& operator=(Output&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Output& default_instance() {
    return *internal_default_instance();
  }
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }
  inline void Swap(Output* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Output* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Output* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Output& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Output& from) {
    Output::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Output* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.Output";
  }
  protected:
  explicit Output(::google::protobuf::Arena* arena);
  Output(::google::protobuf::Arena* arena, const Output& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
    kExternalFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.Robot robot = 1;
  bool has_robot() const;
  void clear_robot() ;
  const ::abb::egm::wrapper::Robot& robot() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Robot* release_robot();
  ::abb::egm::wrapper::Robot* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::Robot* value);
  void unsafe_arena_set_allocated_robot(::abb::egm::wrapper::Robot* value);
  ::abb::egm::wrapper::Robot* unsafe_arena_release_robot();

  private:
  const ::abb::egm::wrapper::Robot& _internal_robot() const;
  ::abb::egm::wrapper::Robot* _internal_mutable_robot();

  public:
  // optional .abb.egm.wrapper.External external = 2;
  bool has_external() const;
  void clear_external() ;
  const ::abb::egm::wrapper::External& external() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::External* release_external();
  ::abb::egm::wrapper::External* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::External* value);
  void unsafe_arena_set_allocated_external(::abb::egm::wrapper::External* value);
  ::abb::egm::wrapper::External* unsafe_arena_release_external();

  private:
  const ::abb::egm::wrapper::External& _internal_external() const;
  ::abb::egm::wrapper::External* _internal_mutable_external();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Output)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Robot* robot_;
    ::abb::egm::wrapper::External* external_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class Feedback final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Feedback) */ {
 public:
  inline Feedback() : Feedback(nullptr) {}
  ~Feedback() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Feedback(::google::protobuf::internal::ConstantInitialized);

  inline Feedback(const Feedback& from)
      : Feedback(nullptr, from) {}
  Feedback(Feedback&& from) noexcept
    : Feedback() {
    *this = ::std::move(from);
  }

  inline Feedback& operator=(const Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline Feedback& operator=(Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const Feedback* internal_default_instance() {
    return reinterpret_cast<const Feedback*>(
               &_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Feedback& a, Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Feedback* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Feedback* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Feedback>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Feedback& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Feedback& from) {
    Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Feedback* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.Feedback";
  }
  protected:
  explicit Feedback(::google::protobuf::Arena* arena);
  Feedback(::google::protobuf::Arena* arena, const Feedback& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
    kExternalFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // optional .abb.egm.wrapper.Robot robot = 1;
  bool has_robot() const;
  void clear_robot() ;
  const ::abb::egm::wrapper::Robot& robot() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Robot* release_robot();
  ::abb::egm::wrapper::Robot* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::Robot* value);
  void unsafe_arena_set_allocated_robot(::abb::egm::wrapper::Robot* value);
  ::abb::egm::wrapper::Robot* unsafe_arena_release_robot();

  private:
  const ::abb::egm::wrapper::Robot& _internal_robot() const;
  ::abb::egm::wrapper::Robot* _internal_mutable_robot();

  public:
  // optional .abb.egm.wrapper.External external = 2;
  bool has_external() const;
  void clear_external() ;
  const ::abb::egm::wrapper::External& external() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::External* release_external();
  ::abb::egm::wrapper::External* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::External* value);
  void unsafe_arena_set_allocated_external(::abb::egm::wrapper::External* value);
  ::abb::egm::wrapper::External* unsafe_arena_release_external();

  private:
  const ::abb::egm::wrapper::External& _internal_external() const;
  ::abb::egm::wrapper::External* _internal_mutable_external();

  public:
  // optional .abb.egm.wrapper.Clock time = 3;
  bool has_time() const;
  void clear_time() ;
  const ::abb::egm::wrapper::Clock& time() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Clock* release_time();
  ::abb::egm::wrapper::Clock* mutable_time();
  void set_allocated_time(::abb::egm::wrapper::Clock* value);
  void unsafe_arena_set_allocated_time(::abb::egm::wrapper::Clock* value);
  ::abb::egm::wrapper::Clock* unsafe_arena_release_time();

  private:
  const ::abb::egm::wrapper::Clock& _internal_time() const;
  ::abb::egm::wrapper::Clock* _internal_mutable_time();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Feedback)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Robot* robot_;
    ::abb::egm::wrapper::External* external_;
    ::abb::egm::wrapper::Clock* time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};// -------------------------------------------------------------------

class Input final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Input) */ {
 public:
  inline Input() : Input(nullptr) {}
  ~Input() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Input(::google::protobuf::internal::ConstantInitialized);

  inline Input(const Input& from)
      : Input(nullptr, from) {}
  Input(Input&& from) noexcept
    : Input() {
    *this = ::std::move(from);
  }

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }
  inline Input& operator=(Input&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Input& default_instance() {
    return *internal_default_instance();
  }
  static inline const Input* internal_default_instance() {
    return reinterpret_cast<const Input*>(
               &_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Input& a, Input& b) {
    a.Swap(&b);
  }
  inline void Swap(Input* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Input* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Input* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Input>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Input& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Input& from) {
    Input::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Input* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.Input";
  }
  protected:
  explicit Input(::google::protobuf::Arena* arena);
  Input(::google::protobuf::Arena* arena, const Input& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFeedbackFieldNumber = 2,
    kPlannedFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // optional .abb.egm.wrapper.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::abb::egm::wrapper::Header& header() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Header* release_header();
  ::abb::egm::wrapper::Header* mutable_header();
  void set_allocated_header(::abb::egm::wrapper::Header* value);
  void unsafe_arena_set_allocated_header(::abb::egm::wrapper::Header* value);
  ::abb::egm::wrapper::Header* unsafe_arena_release_header();

  private:
  const ::abb::egm::wrapper::Header& _internal_header() const;
  ::abb::egm::wrapper::Header* _internal_mutable_header();

  public:
  // optional .abb.egm.wrapper.Feedback feedback = 2;
  bool has_feedback() const;
  void clear_feedback() ;
  const ::abb::egm::wrapper::Feedback& feedback() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Feedback* release_feedback();
  ::abb::egm::wrapper::Feedback* mutable_feedback();
  void set_allocated_feedback(::abb::egm::wrapper::Feedback* value);
  void unsafe_arena_set_allocated_feedback(::abb::egm::wrapper::Feedback* value);
  ::abb::egm::wrapper::Feedback* unsafe_arena_release_feedback();

  private:
  const ::abb::egm::wrapper::Feedback& _internal_feedback() const;
  ::abb::egm::wrapper::Feedback* _internal_mutable_feedback();

  public:
  // optional .abb.egm.wrapper.Planned planned = 3;
  bool has_planned() const;
  void clear_planned() ;
  const ::abb::egm::wrapper::Planned& planned() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Planned* release_planned();
  ::abb::egm::wrapper::Planned* mutable_planned();
  void set_allocated_planned(::abb::egm::wrapper::Planned* value);
  void unsafe_arena_set_allocated_planned(::abb::egm::wrapper::Planned* value);
  ::abb::egm::wrapper::Planned* unsafe_arena_release_planned();

  private:
  const ::abb::egm::wrapper::Planned& _internal_planned() const;
  ::abb::egm::wrapper::Planned* _internal_mutable_planned();

  public:
  // optional .abb.egm.wrapper.Status status = 4;
  bool has_status() const;
  void clear_status() ;
  const ::abb::egm::wrapper::Status& status() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Status* release_status();
  ::abb::egm::wrapper::Status* mutable_status();
  void set_allocated_status(::abb::egm::wrapper::Status* value);
  void unsafe_arena_set_allocated_status(::abb::egm::wrapper::Status* value);
  ::abb::egm::wrapper::Status* unsafe_arena_release_status();

  private:
  const ::abb::egm::wrapper::Status& _internal_status() const;
  ::abb::egm::wrapper::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Input)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Header* header_;
    ::abb::egm::wrapper::Feedback* feedback_;
    ::abb::egm::wrapper::Planned* planned_;
    ::abb::egm::wrapper::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Header

// optional uint32 sequence_number = 1;
inline bool Header::has_sequence_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Header::clear_sequence_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequence_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t Header::sequence_number() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.sequence_number)
  return _internal_sequence_number();
}
inline void Header::set_sequence_number(::uint32_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.sequence_number)
}
inline ::uint32_t Header::_internal_sequence_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_number_;
}
inline void Header::_internal_set_sequence_number(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sequence_number_ = value;
}

// optional uint32 time_stamp = 2;
inline bool Header::has_time_stamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Header::clear_time_stamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_stamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Header::time_stamp() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.time_stamp)
  return _internal_time_stamp();
}
inline void Header::set_time_stamp(::uint32_t value) {
  _internal_set_time_stamp(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.time_stamp)
}
inline ::uint32_t Header::_internal_time_stamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_stamp_;
}
inline void Header::_internal_set_time_stamp(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.time_stamp_ = value;
}

// optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
inline bool Header::has_message_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Header::clear_message_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::abb::egm::wrapper::Header_MessageType Header::message_type() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.message_type)
  return _internal_message_type();
}
inline void Header::set_message_type(::abb::egm::wrapper::Header_MessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.message_type)
}
inline ::abb::egm::wrapper::Header_MessageType Header::_internal_message_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::egm::wrapper::Header_MessageType>(_impl_.message_type_);
}
inline void Header::_internal_set_message_type(::abb::egm::wrapper::Header_MessageType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::egm::wrapper::Header_MessageType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.message_type_ = value;
}

// optional .abb.egm.wrapper.Header.RWVersion rw_version = 4 [default = RW_UNKNOWN];
inline bool Header::has_rw_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Header::clear_rw_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rw_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::abb::egm::wrapper::Header_RWVersion Header::rw_version() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.rw_version)
  return _internal_rw_version();
}
inline void Header::set_rw_version(::abb::egm::wrapper::Header_RWVersion value) {
  _internal_set_rw_version(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.rw_version)
}
inline ::abb::egm::wrapper::Header_RWVersion Header::_internal_rw_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::egm::wrapper::Header_RWVersion>(_impl_.rw_version_);
}
inline void Header::_internal_set_rw_version(::abb::egm::wrapper::Header_RWVersion value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::egm::wrapper::Header_RWVersion_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rw_version_ = value;
}

// optional .abb.egm.wrapper.Header.EGMVersion egm_version = 5 [default = EGM_UNKNOWN];
inline bool Header::has_egm_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Header::clear_egm_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.egm_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::abb::egm::wrapper::Header_EGMVersion Header::egm_version() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.egm_version)
  return _internal_egm_version();
}
inline void Header::set_egm_version(::abb::egm::wrapper::Header_EGMVersion value) {
  _internal_set_egm_version(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.egm_version)
}
inline ::abb::egm::wrapper::Header_EGMVersion Header::_internal_egm_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::egm::wrapper::Header_EGMVersion>(_impl_.egm_version_);
}
inline void Header::_internal_set_egm_version(::abb::egm::wrapper::Header_EGMVersion value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::egm::wrapper::Header_EGMVersion_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.egm_version_ = value;
}

// -------------------------------------------------------------------

// Status

// optional bool egm_convergence_met = 1;
inline bool Status::has_egm_convergence_met() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Status::clear_egm_convergence_met() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.egm_convergence_met_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool Status::egm_convergence_met() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.egm_convergence_met)
  return _internal_egm_convergence_met();
}
inline void Status::set_egm_convergence_met(bool value) {
  _internal_set_egm_convergence_met(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.egm_convergence_met)
}
inline bool Status::_internal_egm_convergence_met() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.egm_convergence_met_;
}
inline void Status::_internal_set_egm_convergence_met(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.egm_convergence_met_ = value;
}

// optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
inline bool Status::has_egm_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Status::clear_egm_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.egm_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::abb::egm::wrapper::Status_EGMState Status::egm_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.egm_state)
  return _internal_egm_state();
}
inline void Status::set_egm_state(::abb::egm::wrapper::Status_EGMState value) {
  _internal_set_egm_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.egm_state)
}
inline ::abb::egm::wrapper::Status_EGMState Status::_internal_egm_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::egm::wrapper::Status_EGMState>(_impl_.egm_state_);
}
inline void Status::_internal_set_egm_state(::abb::egm::wrapper::Status_EGMState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::egm::wrapper::Status_EGMState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.egm_state_ = value;
}

// optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
inline bool Status::has_motor_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Status::clear_motor_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.motor_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::abb::egm::wrapper::Status_MotorState Status::motor_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.motor_state)
  return _internal_motor_state();
}
inline void Status::set_motor_state(::abb::egm::wrapper::Status_MotorState value) {
  _internal_set_motor_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.motor_state)
}
inline ::abb::egm::wrapper::Status_MotorState Status::_internal_motor_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::egm::wrapper::Status_MotorState>(_impl_.motor_state_);
}
inline void Status::_internal_set_motor_state(::abb::egm::wrapper::Status_MotorState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::egm::wrapper::Status_MotorState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.motor_state_ = value;
}

// optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
inline bool Status::has_rapid_execution_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Status::clear_rapid_execution_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rapid_execution_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::abb::egm::wrapper::Status_RAPIDExecutionState Status::rapid_execution_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.rapid_execution_state)
  return _internal_rapid_execution_state();
}
inline void Status::set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value) {
  _internal_set_rapid_execution_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.rapid_execution_state)
}
inline ::abb::egm::wrapper::Status_RAPIDExecutionState Status::_internal_rapid_execution_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::egm::wrapper::Status_RAPIDExecutionState>(_impl_.rapid_execution_state_);
}
inline void Status::_internal_set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::egm::wrapper::Status_RAPIDExecutionState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rapid_execution_state_ = value;
}

// optional double utilization_rate = 5;
inline bool Status::has_utilization_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Status::clear_utilization_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.utilization_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double Status::utilization_rate() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.utilization_rate)
  return _internal_utilization_rate();
}
inline void Status::set_utilization_rate(double value) {
  _internal_set_utilization_rate(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.utilization_rate)
}
inline double Status::_internal_utilization_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.utilization_rate_;
}
inline void Status::_internal_set_utilization_rate(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.utilization_rate_ = value;
}

// -------------------------------------------------------------------

// Clock

// optional uint64 sec = 1;
inline bool Clock::has_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Clock::clear_sec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sec_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t Clock::sec() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Clock.sec)
  return _internal_sec();
}
inline void Clock::set_sec(::uint64_t value) {
  _internal_set_sec(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Clock.sec)
}
inline ::uint64_t Clock::_internal_sec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sec_;
}
inline void Clock::_internal_set_sec(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sec_ = value;
}

// optional uint64 usec = 2;
inline bool Clock::has_usec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Clock::clear_usec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.usec_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t Clock::usec() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Clock.usec)
  return _internal_usec();
}
inline void Clock::set_usec(::uint64_t value) {
  _internal_set_usec(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Clock.usec)
}
inline ::uint64_t Clock::_internal_usec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usec_;
}
inline void Clock::_internal_set_usec(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.usec_ = value;
}

// -------------------------------------------------------------------

// Joints

// repeated double values = 1;
inline int Joints::_internal_values_size() const {
  return _internal_values().size();
}
inline int Joints::values_size() const {
  return _internal_values_size();
}
inline void Joints::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline double Joints::values(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Joints.values)
  return _internal_values().Get(index);
}
inline void Joints::set_values(int index, double value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Joints.values)
}
inline void Joints::add_values(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:abb.egm.wrapper.Joints.values)
}
inline const ::google::protobuf::RepeatedField<double>& Joints::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.egm.wrapper.Joints.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<double>* Joints::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.wrapper.Joints.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<double>& Joints::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<double>* Joints::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// JointSpace

// optional .abb.egm.wrapper.Joints position = 1;
inline bool JointSpace::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void JointSpace::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Joints& JointSpace::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Joints* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Joints&>(::abb::egm::wrapper::_Joints_default_instance_);
}
inline const ::abb::egm::wrapper::Joints& JointSpace::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.JointSpace.position)
  return _internal_position();
}
inline void JointSpace::unsafe_arena_set_allocated_position(::abb::egm::wrapper::Joints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.JointSpace.position)
}
inline ::abb::egm::wrapper::Joints* JointSpace::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Joints* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Joints* JointSpace::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.JointSpace.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Joints* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointSpace::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArena());
    _impl_.position_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(p);
  }
  return _impl_.position_;
}
inline ::abb::egm::wrapper::Joints* JointSpace::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Joints* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.JointSpace.position)
  return _msg;
}
inline void JointSpace::set_allocated_position(::abb::egm::wrapper::Joints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Joints*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Joints*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.JointSpace.position)
}

// optional .abb.egm.wrapper.Joints velocity = 2;
inline bool JointSpace::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void JointSpace::clear_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::Joints& JointSpace::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Joints* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Joints&>(::abb::egm::wrapper::_Joints_default_instance_);
}
inline const ::abb::egm::wrapper::Joints& JointSpace::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.JointSpace.velocity)
  return _internal_velocity();
}
inline void JointSpace::unsafe_arena_set_allocated_velocity(::abb::egm::wrapper::Joints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.JointSpace.velocity)
}
inline ::abb::egm::wrapper::Joints* JointSpace::release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Joints* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Joints* JointSpace::unsafe_arena_release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.JointSpace.velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Joints* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointSpace::_internal_mutable_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(p);
  }
  return _impl_.velocity_;
}
inline ::abb::egm::wrapper::Joints* JointSpace::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Joints* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.JointSpace.velocity)
  return _msg;
}
inline void JointSpace::set_allocated_velocity(::abb::egm::wrapper::Joints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Joints*>(_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Joints*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.velocity_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.JointSpace.velocity)
}

// -------------------------------------------------------------------

// Cartesian

// optional double x = 1;
inline bool Cartesian::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Cartesian::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Cartesian::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.x)
  return _internal_x();
}
inline void Cartesian::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.x)
}
inline double Cartesian::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Cartesian::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// optional double y = 2;
inline bool Cartesian::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Cartesian::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Cartesian::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.y)
  return _internal_y();
}
inline void Cartesian::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.y)
}
inline double Cartesian::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Cartesian::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// optional double z = 3;
inline bool Cartesian::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Cartesian::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Cartesian::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.z)
  return _internal_z();
}
inline void Cartesian::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.z)
}
inline double Cartesian::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Cartesian::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Euler

// optional double x = 1;
inline bool Euler::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Euler::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Euler::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.x)
  return _internal_x();
}
inline void Euler::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.x)
}
inline double Euler::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Euler::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// optional double y = 2;
inline bool Euler::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Euler::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Euler::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.y)
  return _internal_y();
}
inline void Euler::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.y)
}
inline double Euler::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Euler::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// optional double z = 3;
inline bool Euler::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Euler::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Euler::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.z)
  return _internal_z();
}
inline void Euler::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.z)
}
inline double Euler::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Euler::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Quaternion

// optional double u0 = 1;
inline bool Quaternion::has_u0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Quaternion::clear_u0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.u0_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Quaternion::u0() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u0)
  return _internal_u0();
}
inline void Quaternion::set_u0(double value) {
  _internal_set_u0(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u0)
}
inline double Quaternion::_internal_u0() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.u0_;
}
inline void Quaternion::_internal_set_u0(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.u0_ = value;
}

// optional double u1 = 2;
inline bool Quaternion::has_u1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Quaternion::clear_u1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.u1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Quaternion::u1() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u1)
  return _internal_u1();
}
inline void Quaternion::set_u1(double value) {
  _internal_set_u1(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u1)
}
inline double Quaternion::_internal_u1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.u1_;
}
inline void Quaternion::_internal_set_u1(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.u1_ = value;
}

// optional double u2 = 3;
inline bool Quaternion::has_u2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Quaternion::clear_u2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.u2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Quaternion::u2() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u2)
  return _internal_u2();
}
inline void Quaternion::set_u2(double value) {
  _internal_set_u2(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u2)
}
inline double Quaternion::_internal_u2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.u2_;
}
inline void Quaternion::_internal_set_u2(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.u2_ = value;
}

// optional double u3 = 4;
inline bool Quaternion::has_u3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Quaternion::clear_u3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.u3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double Quaternion::u3() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u3)
  return _internal_u3();
}
inline void Quaternion::set_u3(double value) {
  _internal_set_u3(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u3)
}
inline double Quaternion::_internal_u3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.u3_;
}
inline void Quaternion::_internal_set_u3(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.u3_ = value;
}

// -------------------------------------------------------------------

// CartesianPose

// optional .abb.egm.wrapper.Cartesian position = 1;
inline bool CartesianPose::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void CartesianPose::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Cartesian& CartesianPose::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Cartesian* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Cartesian&>(::abb::egm::wrapper::_Cartesian_default_instance_);
}
inline const ::abb::egm::wrapper::Cartesian& CartesianPose::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.position)
  return _internal_position();
}
inline void CartesianPose::unsafe_arena_set_allocated_position(::abb::egm::wrapper::Cartesian* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianPose.position)
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Cartesian* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianPose.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Cartesian* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Cartesian>(GetArena());
    _impl_.position_ = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(p);
  }
  return _impl_.position_;
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Cartesian* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.position)
  return _msg;
}
inline void CartesianPose::set_allocated_position(::abb::egm::wrapper::Cartesian* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Cartesian*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.position)
}

// optional .abb.egm.wrapper.Euler euler = 2;
inline bool CartesianPose::has_euler() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.euler_ != nullptr);
  return value;
}
inline void CartesianPose::clear_euler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.euler_ != nullptr) _impl_.euler_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::Euler& CartesianPose::_internal_euler() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Euler* p = _impl_.euler_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Euler&>(::abb::egm::wrapper::_Euler_default_instance_);
}
inline const ::abb::egm::wrapper::Euler& CartesianPose::euler() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.euler)
  return _internal_euler();
}
inline void CartesianPose::unsafe_arena_set_allocated_euler(::abb::egm::wrapper::Euler* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.euler_);
  }
  _impl_.euler_ = reinterpret_cast<::abb::egm::wrapper::Euler*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianPose.euler)
}
inline ::abb::egm::wrapper::Euler* CartesianPose::release_euler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Euler* released = _impl_.euler_;
  _impl_.euler_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Euler* CartesianPose::unsafe_arena_release_euler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianPose.euler)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Euler* temp = _impl_.euler_;
  _impl_.euler_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Euler* CartesianPose::_internal_mutable_euler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.euler_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Euler>(GetArena());
    _impl_.euler_ = reinterpret_cast<::abb::egm::wrapper::Euler*>(p);
  }
  return _impl_.euler_;
}
inline ::abb::egm::wrapper::Euler* CartesianPose::mutable_euler() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Euler* _msg = _internal_mutable_euler();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.euler)
  return _msg;
}
inline void CartesianPose::set_allocated_euler(::abb::egm::wrapper::Euler* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Euler*>(_impl_.euler_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Euler*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.euler_ = reinterpret_cast<::abb::egm::wrapper::Euler*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.euler)
}

// optional .abb.egm.wrapper.Quaternion quaternion = 3;
inline bool CartesianPose::has_quaternion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quaternion_ != nullptr);
  return value;
}
inline void CartesianPose::clear_quaternion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.quaternion_ != nullptr) _impl_.quaternion_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::wrapper::Quaternion& CartesianPose::_internal_quaternion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Quaternion* p = _impl_.quaternion_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Quaternion&>(::abb::egm::wrapper::_Quaternion_default_instance_);
}
inline const ::abb::egm::wrapper::Quaternion& CartesianPose::quaternion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.quaternion)
  return _internal_quaternion();
}
inline void CartesianPose::unsafe_arena_set_allocated_quaternion(::abb::egm::wrapper::Quaternion* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quaternion_);
  }
  _impl_.quaternion_ = reinterpret_cast<::abb::egm::wrapper::Quaternion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianPose.quaternion)
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::release_quaternion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Quaternion* released = _impl_.quaternion_;
  _impl_.quaternion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::unsafe_arena_release_quaternion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianPose.quaternion)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Quaternion* temp = _impl_.quaternion_;
  _impl_.quaternion_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::_internal_mutable_quaternion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.quaternion_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Quaternion>(GetArena());
    _impl_.quaternion_ = reinterpret_cast<::abb::egm::wrapper::Quaternion*>(p);
  }
  return _impl_.quaternion_;
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::mutable_quaternion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Quaternion* _msg = _internal_mutable_quaternion();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.quaternion)
  return _msg;
}
inline void CartesianPose::set_allocated_quaternion(::abb::egm::wrapper::Quaternion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Quaternion*>(_impl_.quaternion_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Quaternion*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.quaternion_ = reinterpret_cast<::abb::egm::wrapper::Quaternion*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.quaternion)
}

// -------------------------------------------------------------------

// CartesianVelocity

// optional .abb.egm.wrapper.Cartesian linear = 1;
inline bool CartesianVelocity::has_linear() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_ != nullptr);
  return value;
}
inline void CartesianVelocity::clear_linear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.linear_ != nullptr) _impl_.linear_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Cartesian& CartesianVelocity::_internal_linear() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Cartesian* p = _impl_.linear_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Cartesian&>(::abb::egm::wrapper::_Cartesian_default_instance_);
}
inline const ::abb::egm::wrapper::Cartesian& CartesianVelocity::linear() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianVelocity.linear)
  return _internal_linear();
}
inline void CartesianVelocity::unsafe_arena_set_allocated_linear(::abb::egm::wrapper::Cartesian* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.linear_);
  }
  _impl_.linear_ = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianVelocity.linear)
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::release_linear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Cartesian* released = _impl_.linear_;
  _impl_.linear_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::unsafe_arena_release_linear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianVelocity.linear)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Cartesian* temp = _impl_.linear_;
  _impl_.linear_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::_internal_mutable_linear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.linear_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Cartesian>(GetArena());
    _impl_.linear_ = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(p);
  }
  return _impl_.linear_;
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::mutable_linear() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Cartesian* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianVelocity.linear)
  return _msg;
}
inline void CartesianVelocity::set_allocated_linear(::abb::egm::wrapper::Cartesian* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Cartesian*>(_impl_.linear_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.linear_ = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianVelocity.linear)
}

// optional .abb.egm.wrapper.Euler angular = 2;
inline bool CartesianVelocity::has_angular() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.angular_ != nullptr);
  return value;
}
inline void CartesianVelocity::clear_angular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.angular_ != nullptr) _impl_.angular_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::Euler& CartesianVelocity::_internal_angular() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Euler* p = _impl_.angular_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Euler&>(::abb::egm::wrapper::_Euler_default_instance_);
}
inline const ::abb::egm::wrapper::Euler& CartesianVelocity::angular() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianVelocity.angular)
  return _internal_angular();
}
inline void CartesianVelocity::unsafe_arena_set_allocated_angular(::abb::egm::wrapper::Euler* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.angular_);
  }
  _impl_.angular_ = reinterpret_cast<::abb::egm::wrapper::Euler*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianVelocity.angular)
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::release_angular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Euler* released = _impl_.angular_;
  _impl_.angular_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::unsafe_arena_release_angular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianVelocity.angular)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Euler* temp = _impl_.angular_;
  _impl_.angular_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::_internal_mutable_angular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.angular_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Euler>(GetArena());
    _impl_.angular_ = reinterpret_cast<::abb::egm::wrapper::Euler*>(p);
  }
  return _impl_.angular_;
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::mutable_angular() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Euler* _msg = _internal_mutable_angular();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianVelocity.angular)
  return _msg;
}
inline void CartesianVelocity::set_allocated_angular(::abb::egm::wrapper::Euler* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Euler*>(_impl_.angular_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Euler*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.angular_ = reinterpret_cast<::abb::egm::wrapper::Euler*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianVelocity.angular)
}

// -------------------------------------------------------------------

// CartesianSpace

// optional .abb.egm.wrapper.CartesianPose pose = 1;
inline bool CartesianSpace::has_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pose_ != nullptr);
  return value;
}
inline void CartesianSpace::clear_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pose_ != nullptr) _impl_.pose_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::CartesianPose& CartesianSpace::_internal_pose() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::CartesianPose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::CartesianPose&>(::abb::egm::wrapper::_CartesianPose_default_instance_);
}
inline const ::abb::egm::wrapper::CartesianPose& CartesianSpace::pose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianSpace.pose)
  return _internal_pose();
}
inline void CartesianSpace::unsafe_arena_set_allocated_pose(::abb::egm::wrapper::CartesianPose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = reinterpret_cast<::abb::egm::wrapper::CartesianPose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianSpace.pose)
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::CartesianPose* released = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::unsafe_arena_release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianSpace.pose)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::CartesianPose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::_internal_mutable_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianPose>(GetArena());
    _impl_.pose_ = reinterpret_cast<::abb::egm::wrapper::CartesianPose*>(p);
  }
  return _impl_.pose_;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::mutable_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::CartesianPose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianSpace.pose)
  return _msg;
}
inline void CartesianSpace::set_allocated_pose(::abb::egm::wrapper::CartesianPose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::CartesianPose*>(_impl_.pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::CartesianPose*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pose_ = reinterpret_cast<::abb::egm::wrapper::CartesianPose*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianSpace.pose)
}

// optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
inline bool CartesianSpace::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void CartesianSpace::clear_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::CartesianVelocity& CartesianSpace::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::CartesianVelocity* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::CartesianVelocity&>(::abb::egm::wrapper::_CartesianVelocity_default_instance_);
}
inline const ::abb::egm::wrapper::CartesianVelocity& CartesianSpace::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianSpace.velocity)
  return _internal_velocity();
}
inline void CartesianSpace::unsafe_arena_set_allocated_velocity(::abb::egm::wrapper::CartesianVelocity* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::abb::egm::wrapper::CartesianVelocity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianSpace.velocity)
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianVelocity* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::unsafe_arena_release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianSpace.velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianVelocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::_internal_mutable_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianVelocity>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::abb::egm::wrapper::CartesianVelocity*>(p);
  }
  return _impl_.velocity_;
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::CartesianVelocity* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianSpace.velocity)
  return _msg;
}
inline void CartesianSpace::set_allocated_velocity(::abb::egm::wrapper::CartesianVelocity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::CartesianVelocity*>(_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::CartesianVelocity*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.velocity_ = reinterpret_cast<::abb::egm::wrapper::CartesianVelocity*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianSpace.velocity)
}

// -------------------------------------------------------------------

// Robot

// optional .abb.egm.wrapper.JointSpace joints = 1;
inline bool Robot::has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline void Robot::clear_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.joints_ != nullptr) _impl_.joints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::JointSpace& Robot::_internal_joints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::JointSpace* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::JointSpace&>(::abb::egm::wrapper::_JointSpace_default_instance_);
}
inline const ::abb::egm::wrapper::JointSpace& Robot::joints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Robot.joints)
  return _internal_joints();
}
inline void Robot::unsafe_arena_set_allocated_joints(::abb::egm::wrapper::JointSpace* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::JointSpace*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Robot.joints)
}
inline ::abb::egm::wrapper::JointSpace* Robot::release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::JointSpace* released = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::JointSpace* Robot::unsafe_arena_release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Robot.joints)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::JointSpace* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::JointSpace* Robot::_internal_mutable_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::JointSpace>(GetArena());
    _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::JointSpace*>(p);
  }
  return _impl_.joints_;
}
inline ::abb::egm::wrapper::JointSpace* Robot::mutable_joints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::JointSpace* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Robot.joints)
  return _msg;
}
inline void Robot::set_allocated_joints(::abb::egm::wrapper::JointSpace* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::JointSpace*>(_impl_.joints_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::JointSpace*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::JointSpace*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Robot.joints)
}

// optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
inline bool Robot::has_cartesian() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cartesian_ != nullptr);
  return value;
}
inline void Robot::clear_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.cartesian_ != nullptr) _impl_.cartesian_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::CartesianSpace& Robot::_internal_cartesian() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::CartesianSpace* p = _impl_.cartesian_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::CartesianSpace&>(::abb::egm::wrapper::_CartesianSpace_default_instance_);
}
inline const ::abb::egm::wrapper::CartesianSpace& Robot::cartesian() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Robot.cartesian)
  return _internal_cartesian();
}
inline void Robot::unsafe_arena_set_allocated_cartesian(::abb::egm::wrapper::CartesianSpace* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cartesian_);
  }
  _impl_.cartesian_ = reinterpret_cast<::abb::egm::wrapper::CartesianSpace*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Robot.cartesian)
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::release_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianSpace* released = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::unsafe_arena_release_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Robot.cartesian)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianSpace* temp = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::_internal_mutable_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cartesian_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianSpace>(GetArena());
    _impl_.cartesian_ = reinterpret_cast<::abb::egm::wrapper::CartesianSpace*>(p);
  }
  return _impl_.cartesian_;
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::mutable_cartesian() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::CartesianSpace* _msg = _internal_mutable_cartesian();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Robot.cartesian)
  return _msg;
}
inline void Robot::set_allocated_cartesian(::abb::egm::wrapper::CartesianSpace* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::CartesianSpace*>(_impl_.cartesian_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::CartesianSpace*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.cartesian_ = reinterpret_cast<::abb::egm::wrapper::CartesianSpace*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Robot.cartesian)
}

// -------------------------------------------------------------------

// External

// optional .abb.egm.wrapper.JointSpace joints = 1;
inline bool External::has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline void External::clear_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.joints_ != nullptr) _impl_.joints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::JointSpace& External::_internal_joints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::JointSpace* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::JointSpace&>(::abb::egm::wrapper::_JointSpace_default_instance_);
}
inline const ::abb::egm::wrapper::JointSpace& External::joints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.External.joints)
  return _internal_joints();
}
inline void External::unsafe_arena_set_allocated_joints(::abb::egm::wrapper::JointSpace* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::JointSpace*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.External.joints)
}
inline ::abb::egm::wrapper::JointSpace* External::release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::JointSpace* released = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::JointSpace* External::unsafe_arena_release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.External.joints)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::JointSpace* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::JointSpace* External::_internal_mutable_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::JointSpace>(GetArena());
    _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::JointSpace*>(p);
  }
  return _impl_.joints_;
}
inline ::abb::egm::wrapper::JointSpace* External::mutable_joints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::JointSpace* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.External.joints)
  return _msg;
}
inline void External::set_allocated_joints(::abb::egm::wrapper::JointSpace* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::JointSpace*>(_impl_.joints_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::JointSpace*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::JointSpace*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.External.joints)
}

// -------------------------------------------------------------------

// Feedback

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Feedback::has_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ != nullptr);
  return value;
}
inline void Feedback::clear_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.robot_ != nullptr) _impl_.robot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Robot& Feedback::_internal_robot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Robot* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Robot&>(::abb::egm::wrapper::_Robot_default_instance_);
}
inline const ::abb::egm::wrapper::Robot& Feedback::robot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.robot)
  return _internal_robot();
}
inline void Feedback::unsafe_arena_set_allocated_robot(::abb::egm::wrapper::Robot* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::Robot*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Feedback.robot)
}
inline ::abb::egm::wrapper::Robot* Feedback::release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* released = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Robot* Feedback::unsafe_arena_release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Feedback.robot)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Robot* Feedback::_internal_mutable_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Robot>(GetArena());
    _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::Robot*>(p);
  }
  return _impl_.robot_;
}
inline ::abb::egm::wrapper::Robot* Feedback::mutable_robot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.robot)
  return _msg;
}
inline void Feedback::set_allocated_robot(::abb::egm::wrapper::Robot* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Robot*>(_impl_.robot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Robot*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::Robot*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Feedback::has_external() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_ != nullptr);
  return value;
}
inline void Feedback::clear_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.external_ != nullptr) _impl_.external_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::External& Feedback::_internal_external() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::External* p = _impl_.external_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::External&>(::abb::egm::wrapper::_External_default_instance_);
}
inline const ::abb::egm::wrapper::External& Feedback::external() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.external)
  return _internal_external();
}
inline void Feedback::unsafe_arena_set_allocated_external(::abb::egm::wrapper::External* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.external_);
  }
  _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::External*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Feedback.external)
}
inline ::abb::egm::wrapper::External* Feedback::release_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* released = _impl_.external_;
  _impl_.external_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::External* Feedback::unsafe_arena_release_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Feedback.external)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = _impl_.external_;
  _impl_.external_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::External* Feedback::_internal_mutable_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.external_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::External>(GetArena());
    _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::External*>(p);
  }
  return _impl_.external_;
}
inline ::abb::egm::wrapper::External* Feedback::mutable_external() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::External* _msg = _internal_mutable_external();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.external)
  return _msg;
}
inline void Feedback::set_allocated_external(::abb::egm::wrapper::External* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::External*>(_impl_.external_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::External*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::External*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.external)
}

// optional .abb.egm.wrapper.Clock time = 3;
inline bool Feedback::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline void Feedback::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::wrapper::Clock& Feedback::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Clock* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Clock&>(::abb::egm::wrapper::_Clock_default_instance_);
}
inline const ::abb::egm::wrapper::Clock& Feedback::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.time)
  return _internal_time();
}
inline void Feedback::unsafe_arena_set_allocated_time(::abb::egm::wrapper::Clock* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::abb::egm::wrapper::Clock*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Feedback.time)
}
inline ::abb::egm::wrapper::Clock* Feedback::release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Clock* released = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Clock* Feedback::unsafe_arena_release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Feedback.time)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Clock* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Clock* Feedback::_internal_mutable_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Clock>(GetArena());
    _impl_.time_ = reinterpret_cast<::abb::egm::wrapper::Clock*>(p);
  }
  return _impl_.time_;
}
inline ::abb::egm::wrapper::Clock* Feedback::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Clock* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.time)
  return _msg;
}
inline void Feedback::set_allocated_time(::abb::egm::wrapper::Clock* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Clock*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Clock*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.time_ = reinterpret_cast<::abb::egm::wrapper::Clock*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.time)
}

// -------------------------------------------------------------------

// Planned

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Planned::has_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ != nullptr);
  return value;
}
inline void Planned::clear_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.robot_ != nullptr) _impl_.robot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Robot& Planned::_internal_robot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Robot* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Robot&>(::abb::egm::wrapper::_Robot_default_instance_);
}
inline const ::abb::egm::wrapper::Robot& Planned::robot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.robot)
  return _internal_robot();
}
inline void Planned::unsafe_arena_set_allocated_robot(::abb::egm::wrapper::Robot* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::Robot*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Planned.robot)
}
inline ::abb::egm::wrapper::Robot* Planned::release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* released = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Robot* Planned::unsafe_arena_release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Planned.robot)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Robot* Planned::_internal_mutable_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Robot>(GetArena());
    _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::Robot*>(p);
  }
  return _impl_.robot_;
}
inline ::abb::egm::wrapper::Robot* Planned::mutable_robot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.robot)
  return _msg;
}
inline void Planned::set_allocated_robot(::abb::egm::wrapper::Robot* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Robot*>(_impl_.robot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Robot*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::Robot*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Planned::has_external() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_ != nullptr);
  return value;
}
inline void Planned::clear_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.external_ != nullptr) _impl_.external_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::External& Planned::_internal_external() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::External* p = _impl_.external_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::External&>(::abb::egm::wrapper::_External_default_instance_);
}
inline const ::abb::egm::wrapper::External& Planned::external() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.external)
  return _internal_external();
}
inline void Planned::unsafe_arena_set_allocated_external(::abb::egm::wrapper::External* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.external_);
  }
  _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::External*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Planned.external)
}
inline ::abb::egm::wrapper::External* Planned::release_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* released = _impl_.external_;
  _impl_.external_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::External* Planned::unsafe_arena_release_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Planned.external)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = _impl_.external_;
  _impl_.external_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::External* Planned::_internal_mutable_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.external_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::External>(GetArena());
    _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::External*>(p);
  }
  return _impl_.external_;
}
inline ::abb::egm::wrapper::External* Planned::mutable_external() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::External* _msg = _internal_mutable_external();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.external)
  return _msg;
}
inline void Planned::set_allocated_external(::abb::egm::wrapper::External* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::External*>(_impl_.external_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::External*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::External*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.external)
}

// optional .abb.egm.wrapper.Clock time = 3;
inline bool Planned::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline void Planned::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::wrapper::Clock& Planned::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Clock* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Clock&>(::abb::egm::wrapper::_Clock_default_instance_);
}
inline const ::abb::egm::wrapper::Clock& Planned::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.time)
  return _internal_time();
}
inline void Planned::unsafe_arena_set_allocated_time(::abb::egm::wrapper::Clock* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::abb::egm::wrapper::Clock*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Planned.time)
}
inline ::abb::egm::wrapper::Clock* Planned::release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Clock* released = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Clock* Planned::unsafe_arena_release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Planned.time)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Clock* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Clock* Planned::_internal_mutable_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Clock>(GetArena());
    _impl_.time_ = reinterpret_cast<::abb::egm::wrapper::Clock*>(p);
  }
  return _impl_.time_;
}
inline ::abb::egm::wrapper::Clock* Planned::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Clock* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.time)
  return _msg;
}
inline void Planned::set_allocated_time(::abb::egm::wrapper::Clock* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Clock*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Clock*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.time_ = reinterpret_cast<::abb::egm::wrapper::Clock*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.time)
}

// -------------------------------------------------------------------

// Input

// optional .abb.egm.wrapper.Header header = 1;
inline bool Input::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void Input::clear_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Header& Input::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Header&>(::abb::egm::wrapper::_Header_default_instance_);
}
inline const ::abb::egm::wrapper::Header& Input::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.header)
  return _internal_header();
}
inline void Input::unsafe_arena_set_allocated_header(::abb::egm::wrapper::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::abb::egm::wrapper::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Input.header)
}
inline ::abb::egm::wrapper::Header* Input::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Header* Input::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Header* Input::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::abb::egm::wrapper::Header*>(p);
  }
  return _impl_.header_;
}
inline ::abb::egm::wrapper::Header* Input::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.header)
  return _msg;
}
inline void Input::set_allocated_header(::abb::egm::wrapper::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Header*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Header*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::abb::egm::wrapper::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.header)
}

// optional .abb.egm.wrapper.Feedback feedback = 2;
inline bool Input::has_feedback() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.feedback_ != nullptr);
  return value;
}
inline void Input::clear_feedback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.feedback_ != nullptr) _impl_.feedback_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::Feedback& Input::_internal_feedback() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Feedback* p = _impl_.feedback_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Feedback&>(::abb::egm::wrapper::_Feedback_default_instance_);
}
inline const ::abb::egm::wrapper::Feedback& Input::feedback() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.feedback)
  return _internal_feedback();
}
inline void Input::unsafe_arena_set_allocated_feedback(::abb::egm::wrapper::Feedback* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.feedback_);
  }
  _impl_.feedback_ = reinterpret_cast<::abb::egm::wrapper::Feedback*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Input.feedback)
}
inline ::abb::egm::wrapper::Feedback* Input::release_feedback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Feedback* released = _impl_.feedback_;
  _impl_.feedback_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Feedback* Input::unsafe_arena_release_feedback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.feedback)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Feedback* temp = _impl_.feedback_;
  _impl_.feedback_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Feedback* Input::_internal_mutable_feedback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Feedback>(GetArena());
    _impl_.feedback_ = reinterpret_cast<::abb::egm::wrapper::Feedback*>(p);
  }
  return _impl_.feedback_;
}
inline ::abb::egm::wrapper::Feedback* Input::mutable_feedback() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Feedback* _msg = _internal_mutable_feedback();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.feedback)
  return _msg;
}
inline void Input::set_allocated_feedback(::abb::egm::wrapper::Feedback* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Feedback*>(_impl_.feedback_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Feedback*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.feedback_ = reinterpret_cast<::abb::egm::wrapper::Feedback*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.feedback)
}

// optional .abb.egm.wrapper.Planned planned = 3;
inline bool Input::has_planned() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.planned_ != nullptr);
  return value;
}
inline void Input::clear_planned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.planned_ != nullptr) _impl_.planned_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::wrapper::Planned& Input::_internal_planned() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Planned* p = _impl_.planned_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Planned&>(::abb::egm::wrapper::_Planned_default_instance_);
}
inline const ::abb::egm::wrapper::Planned& Input::planned() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.planned)
  return _internal_planned();
}
inline void Input::unsafe_arena_set_allocated_planned(::abb::egm::wrapper::Planned* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.planned_);
  }
  _impl_.planned_ = reinterpret_cast<::abb::egm::wrapper::Planned*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Input.planned)
}
inline ::abb::egm::wrapper::Planned* Input::release_planned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Planned* released = _impl_.planned_;
  _impl_.planned_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Planned* Input::unsafe_arena_release_planned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.planned)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Planned* temp = _impl_.planned_;
  _impl_.planned_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Planned* Input::_internal_mutable_planned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.planned_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Planned>(GetArena());
    _impl_.planned_ = reinterpret_cast<::abb::egm::wrapper::Planned*>(p);
  }
  return _impl_.planned_;
}
inline ::abb::egm::wrapper::Planned* Input::mutable_planned() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Planned* _msg = _internal_mutable_planned();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.planned)
  return _msg;
}
inline void Input::set_allocated_planned(::abb::egm::wrapper::Planned* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Planned*>(_impl_.planned_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Planned*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.planned_ = reinterpret_cast<::abb::egm::wrapper::Planned*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.planned)
}

// optional .abb.egm.wrapper.Status status = 4;
inline bool Input::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void Input::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::wrapper::Status& Input::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Status&>(::abb::egm::wrapper::_Status_default_instance_);
}
inline const ::abb::egm::wrapper::Status& Input::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.status)
  return _internal_status();
}
inline void Input::unsafe_arena_set_allocated_status(::abb::egm::wrapper::Status* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::abb::egm::wrapper::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Input.status)
}
inline ::abb::egm::wrapper::Status* Input::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::wrapper::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Status* Input::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.status)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::wrapper::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Status* Input::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::abb::egm::wrapper::Status*>(p);
  }
  return _impl_.status_;
}
inline ::abb::egm::wrapper::Status* Input::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.status)
  return _msg;
}
inline void Input::set_allocated_status(::abb::egm::wrapper::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Status*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Status*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.status_ = reinterpret_cast<::abb::egm::wrapper::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.status)
}

// -------------------------------------------------------------------

// Output

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Output::has_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ != nullptr);
  return value;
}
inline void Output::clear_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.robot_ != nullptr) _impl_.robot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Robot& Output::_internal_robot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Robot* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Robot&>(::abb::egm::wrapper::_Robot_default_instance_);
}
inline const ::abb::egm::wrapper::Robot& Output::robot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Output.robot)
  return _internal_robot();
}
inline void Output::unsafe_arena_set_allocated_robot(::abb::egm::wrapper::Robot* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::Robot*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Output.robot)
}
inline ::abb::egm::wrapper::Robot* Output::release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* released = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Robot* Output::unsafe_arena_release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Output.robot)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Robot* Output::_internal_mutable_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Robot>(GetArena());
    _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::Robot*>(p);
  }
  return _impl_.robot_;
}
inline ::abb::egm::wrapper::Robot* Output::mutable_robot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Output.robot)
  return _msg;
}
inline void Output::set_allocated_robot(::abb::egm::wrapper::Robot* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::Robot*>(_impl_.robot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::Robot*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::Robot*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Output.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Output::has_external() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_ != nullptr);
  return value;
}
inline void Output::clear_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.external_ != nullptr) _impl_.external_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::External& Output::_internal_external() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::External* p = _impl_.external_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::External&>(::abb::egm::wrapper::_External_default_instance_);
}
inline const ::abb::egm::wrapper::External& Output::external() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Output.external)
  return _internal_external();
}
inline void Output::unsafe_arena_set_allocated_external(::abb::egm::wrapper::External* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.external_);
  }
  _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::External*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Output.external)
}
inline ::abb::egm::wrapper::External* Output::release_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* released = _impl_.external_;
  _impl_.external_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::External* Output::unsafe_arena_release_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Output.external)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = _impl_.external_;
  _impl_.external_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::External* Output::_internal_mutable_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.external_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::External>(GetArena());
    _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::External*>(p);
  }
  return _impl_.external_;
}
inline ::abb::egm::wrapper::External* Output::mutable_external() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::External* _msg = _internal_mutable_external();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Output.external)
  return _msg;
}
inline void Output::set_allocated_external(::abb::egm::wrapper::External* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::External*>(_impl_.external_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::External*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::External*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Output.external)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace wrapper
}  // namespace egm
}  // namespace abb


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::abb::egm::wrapper::Header_MessageType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::egm::wrapper::Header_MessageType>() {
  return ::abb::egm::wrapper::Header_MessageType_descriptor();
}
template <>
struct is_proto_enum<::abb::egm::wrapper::Header_RWVersion> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::egm::wrapper::Header_RWVersion>() {
  return ::abb::egm::wrapper::Header_RWVersion_descriptor();
}
template <>
struct is_proto_enum<::abb::egm::wrapper::Header_EGMVersion> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::egm::wrapper::Header_EGMVersion>() {
  return ::abb::egm::wrapper::Header_EGMVersion_descriptor();
}
template <>
struct is_proto_enum<::abb::egm::wrapper::Status_EGMState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::egm::wrapper::Status_EGMState>() {
  return ::abb::egm::wrapper::Status_EGMState_descriptor();
}
template <>
struct is_proto_enum<::abb::egm::wrapper::Status_MotorState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::egm::wrapper::Status_MotorState>() {
  return ::abb::egm::wrapper::Status_MotorState_descriptor();
}
template <>
struct is_proto_enum<::abb::egm::wrapper::Status_RAPIDExecutionState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::egm::wrapper::Status_RAPIDExecutionState>() {
  return ::abb::egm::wrapper::Status_RAPIDExecutionState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_egm_5fwrapper_2eproto_2epb_2eh
