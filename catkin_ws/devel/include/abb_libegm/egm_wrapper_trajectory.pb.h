// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm_wrapper_trajectory.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_egm_5fwrapper_5ftrajectory_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_egm_5fwrapper_5ftrajectory_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "egm_wrapper.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_5ftrajectory_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_egm_5fwrapper_5ftrajectory_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_egm_5fwrapper_5ftrajectory_2eproto;
namespace abb {
namespace egm {
namespace wrapper {
namespace trajectory {
class CartesianGoal;
struct CartesianGoalDefaultTypeInternal;
extern CartesianGoalDefaultTypeInternal _CartesianGoal_default_instance_;
class ExecutionProgress;
struct ExecutionProgressDefaultTypeInternal;
extern ExecutionProgressDefaultTypeInternal _ExecutionProgress_default_instance_;
class ExternalGoal;
struct ExternalGoalDefaultTypeInternal;
extern ExternalGoalDefaultTypeInternal _ExternalGoal_default_instance_;
class JointGoal;
struct JointGoalDefaultTypeInternal;
extern JointGoalDefaultTypeInternal _JointGoal_default_instance_;
class PointGoal;
struct PointGoalDefaultTypeInternal;
extern PointGoalDefaultTypeInternal _PointGoal_default_instance_;
class RobotGoal;
struct RobotGoalDefaultTypeInternal;
extern RobotGoalDefaultTypeInternal _RobotGoal_default_instance_;
class RobotPositionGoal;
struct RobotPositionGoalDefaultTypeInternal;
extern RobotPositionGoalDefaultTypeInternal _RobotPositionGoal_default_instance_;
class RobotVelocityGoal;
struct RobotVelocityGoalDefaultTypeInternal;
extern RobotVelocityGoalDefaultTypeInternal _RobotVelocityGoal_default_instance_;
class StaticPositionGoal;
struct StaticPositionGoalDefaultTypeInternal;
extern StaticPositionGoalDefaultTypeInternal _StaticPositionGoal_default_instance_;
class StaticVelocityGoal;
struct StaticVelocityGoalDefaultTypeInternal;
extern StaticVelocityGoalDefaultTypeInternal _StaticVelocityGoal_default_instance_;
class TrajectoryGoal;
struct TrajectoryGoalDefaultTypeInternal;
extern TrajectoryGoalDefaultTypeInternal _TrajectoryGoal_default_instance_;
}  // namespace trajectory
}  // namespace wrapper
}  // namespace egm
}  // namespace abb
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace abb {
namespace egm {
namespace wrapper {
namespace trajectory {
enum ExecutionProgress_State : int {
  ExecutionProgress_State_UNDEFINED = 0,
  ExecutionProgress_State_NORMAL = 1,
  ExecutionProgress_State_RAMP_DOWN = 2,
  ExecutionProgress_State_STATIC_GOAL = 3,
};

bool ExecutionProgress_State_IsValid(int value);
extern const uint32_t ExecutionProgress_State_internal_data_[];
constexpr ExecutionProgress_State ExecutionProgress_State_State_MIN = static_cast<ExecutionProgress_State>(0);
constexpr ExecutionProgress_State ExecutionProgress_State_State_MAX = static_cast<ExecutionProgress_State>(3);
constexpr int ExecutionProgress_State_State_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ExecutionProgress_State_descriptor();
template <typename T>
const std::string& ExecutionProgress_State_Name(T value) {
  static_assert(std::is_same<T, ExecutionProgress_State>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to State_Name().");
  return ExecutionProgress_State_Name(static_cast<ExecutionProgress_State>(value));
}
template <>
inline const std::string& ExecutionProgress_State_Name(ExecutionProgress_State value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ExecutionProgress_State_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ExecutionProgress_State_Parse(absl::string_view name, ExecutionProgress_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecutionProgress_State>(
      ExecutionProgress_State_descriptor(), name, value);
}
enum ExecutionProgress_SubState : int {
  ExecutionProgress_SubState_NONE = 0,
  ExecutionProgress_SubState_RUNNING = 1,
  ExecutionProgress_SubState_FINISHED = 2,
};

bool ExecutionProgress_SubState_IsValid(int value);
extern const uint32_t ExecutionProgress_SubState_internal_data_[];
constexpr ExecutionProgress_SubState ExecutionProgress_SubState_SubState_MIN = static_cast<ExecutionProgress_SubState>(0);
constexpr ExecutionProgress_SubState ExecutionProgress_SubState_SubState_MAX = static_cast<ExecutionProgress_SubState>(2);
constexpr int ExecutionProgress_SubState_SubState_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ExecutionProgress_SubState_descriptor();
template <typename T>
const std::string& ExecutionProgress_SubState_Name(T value) {
  static_assert(std::is_same<T, ExecutionProgress_SubState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SubState_Name().");
  return ExecutionProgress_SubState_Name(static_cast<ExecutionProgress_SubState>(value));
}
template <>
inline const std::string& ExecutionProgress_SubState_Name(ExecutionProgress_SubState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ExecutionProgress_SubState_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ExecutionProgress_SubState_Parse(absl::string_view name, ExecutionProgress_SubState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecutionProgress_SubState>(
      ExecutionProgress_SubState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class JointGoal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.trajectory.JointGoal) */ {
 public:
  inline JointGoal() : JointGoal(nullptr) {}
  ~JointGoal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JointGoal(::google::protobuf::internal::ConstantInitialized);

  inline JointGoal(const JointGoal& from)
      : JointGoal(nullptr, from) {}
  JointGoal(JointGoal&& from) noexcept
    : JointGoal() {
    *this = ::std::move(from);
  }

  inline JointGoal& operator=(const JointGoal& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointGoal& operator=(JointGoal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JointGoal& default_instance() {
    return *internal_default_instance();
  }
  static inline const JointGoal* internal_default_instance() {
    return reinterpret_cast<const JointGoal*>(
               &_JointGoal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(JointGoal& a, JointGoal& b) {
    a.Swap(&b);
  }
  inline void Swap(JointGoal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointGoal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JointGoal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JointGoal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JointGoal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const JointGoal& from) {
    JointGoal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JointGoal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.trajectory.JointGoal";
  }
  protected:
  explicit JointGoal(::google::protobuf::Arena* arena);
  JointGoal(::google::protobuf::Arena* arena, const JointGoal& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kVelocityFieldNumber = 2,
    kAccelerationFieldNumber = 3,
  };
  // optional .abb.egm.wrapper.Joints position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::abb::egm::wrapper::Joints& position() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Joints* release_position();
  ::abb::egm::wrapper::Joints* mutable_position();
  void set_allocated_position(::abb::egm::wrapper::Joints* value);
  void unsafe_arena_set_allocated_position(::abb::egm::wrapper::Joints* value);
  ::abb::egm::wrapper::Joints* unsafe_arena_release_position();

  private:
  const ::abb::egm::wrapper::Joints& _internal_position() const;
  ::abb::egm::wrapper::Joints* _internal_mutable_position();

  public:
  // optional .abb.egm.wrapper.Joints velocity = 2;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::abb::egm::wrapper::Joints& velocity() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Joints* release_velocity();
  ::abb::egm::wrapper::Joints* mutable_velocity();
  void set_allocated_velocity(::abb::egm::wrapper::Joints* value);
  void unsafe_arena_set_allocated_velocity(::abb::egm::wrapper::Joints* value);
  ::abb::egm::wrapper::Joints* unsafe_arena_release_velocity();

  private:
  const ::abb::egm::wrapper::Joints& _internal_velocity() const;
  ::abb::egm::wrapper::Joints* _internal_mutable_velocity();

  public:
  // optional .abb.egm.wrapper.Joints acceleration = 3;
  bool has_acceleration() const;
  void clear_acceleration() ;
  const ::abb::egm::wrapper::Joints& acceleration() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Joints* release_acceleration();
  ::abb::egm::wrapper::Joints* mutable_acceleration();
  void set_allocated_acceleration(::abb::egm::wrapper::Joints* value);
  void unsafe_arena_set_allocated_acceleration(::abb::egm::wrapper::Joints* value);
  ::abb::egm::wrapper::Joints* unsafe_arena_release_acceleration();

  private:
  const ::abb::egm::wrapper::Joints& _internal_acceleration() const;
  ::abb::egm::wrapper::Joints* _internal_mutable_acceleration();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.trajectory.JointGoal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Joints* position_;
    ::abb::egm::wrapper::Joints* velocity_;
    ::abb::egm::wrapper::Joints* acceleration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_5ftrajectory_2eproto;
};// -------------------------------------------------------------------

class RobotVelocityGoal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.trajectory.RobotVelocityGoal) */ {
 public:
  inline RobotVelocityGoal() : RobotVelocityGoal(nullptr) {}
  ~RobotVelocityGoal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RobotVelocityGoal(::google::protobuf::internal::ConstantInitialized);

  inline RobotVelocityGoal(const RobotVelocityGoal& from)
      : RobotVelocityGoal(nullptr, from) {}
  RobotVelocityGoal(RobotVelocityGoal&& from) noexcept
    : RobotVelocityGoal() {
    *this = ::std::move(from);
  }

  inline RobotVelocityGoal& operator=(const RobotVelocityGoal& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotVelocityGoal& operator=(RobotVelocityGoal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotVelocityGoal& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotVelocityGoal* internal_default_instance() {
    return reinterpret_cast<const RobotVelocityGoal*>(
               &_RobotVelocityGoal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RobotVelocityGoal& a, RobotVelocityGoal& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotVelocityGoal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotVelocityGoal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotVelocityGoal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotVelocityGoal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RobotVelocityGoal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RobotVelocityGoal& from) {
    RobotVelocityGoal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RobotVelocityGoal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.trajectory.RobotVelocityGoal";
  }
  protected:
  explicit RobotVelocityGoal(::google::protobuf::Arena* arena);
  RobotVelocityGoal(::google::protobuf::Arena* arena, const RobotVelocityGoal& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesianFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.Joints joints = 1;
  bool has_joints() const;
  void clear_joints() ;
  const ::abb::egm::wrapper::Joints& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Joints* release_joints();
  ::abb::egm::wrapper::Joints* mutable_joints();
  void set_allocated_joints(::abb::egm::wrapper::Joints* value);
  void unsafe_arena_set_allocated_joints(::abb::egm::wrapper::Joints* value);
  ::abb::egm::wrapper::Joints* unsafe_arena_release_joints();

  private:
  const ::abb::egm::wrapper::Joints& _internal_joints() const;
  ::abb::egm::wrapper::Joints* _internal_mutable_joints();

  public:
  // optional .abb.egm.wrapper.CartesianVelocity cartesian = 2;
  bool has_cartesian() const;
  void clear_cartesian() ;
  const ::abb::egm::wrapper::CartesianVelocity& cartesian() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::CartesianVelocity* release_cartesian();
  ::abb::egm::wrapper::CartesianVelocity* mutable_cartesian();
  void set_allocated_cartesian(::abb::egm::wrapper::CartesianVelocity* value);
  void unsafe_arena_set_allocated_cartesian(::abb::egm::wrapper::CartesianVelocity* value);
  ::abb::egm::wrapper::CartesianVelocity* unsafe_arena_release_cartesian();

  private:
  const ::abb::egm::wrapper::CartesianVelocity& _internal_cartesian() const;
  ::abb::egm::wrapper::CartesianVelocity* _internal_mutable_cartesian();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.trajectory.RobotVelocityGoal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Joints* joints_;
    ::abb::egm::wrapper::CartesianVelocity* cartesian_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_5ftrajectory_2eproto;
};// -------------------------------------------------------------------

class RobotPositionGoal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.trajectory.RobotPositionGoal) */ {
 public:
  inline RobotPositionGoal() : RobotPositionGoal(nullptr) {}
  ~RobotPositionGoal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RobotPositionGoal(::google::protobuf::internal::ConstantInitialized);

  inline RobotPositionGoal(const RobotPositionGoal& from)
      : RobotPositionGoal(nullptr, from) {}
  RobotPositionGoal(RobotPositionGoal&& from) noexcept
    : RobotPositionGoal() {
    *this = ::std::move(from);
  }

  inline RobotPositionGoal& operator=(const RobotPositionGoal& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotPositionGoal& operator=(RobotPositionGoal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotPositionGoal& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotPositionGoal* internal_default_instance() {
    return reinterpret_cast<const RobotPositionGoal*>(
               &_RobotPositionGoal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RobotPositionGoal& a, RobotPositionGoal& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotPositionGoal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotPositionGoal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotPositionGoal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotPositionGoal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RobotPositionGoal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RobotPositionGoal& from) {
    RobotPositionGoal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RobotPositionGoal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.trajectory.RobotPositionGoal";
  }
  protected:
  explicit RobotPositionGoal(::google::protobuf::Arena* arena);
  RobotPositionGoal(::google::protobuf::Arena* arena, const RobotPositionGoal& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesianFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.Joints joints = 1;
  bool has_joints() const;
  void clear_joints() ;
  const ::abb::egm::wrapper::Joints& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Joints* release_joints();
  ::abb::egm::wrapper::Joints* mutable_joints();
  void set_allocated_joints(::abb::egm::wrapper::Joints* value);
  void unsafe_arena_set_allocated_joints(::abb::egm::wrapper::Joints* value);
  ::abb::egm::wrapper::Joints* unsafe_arena_release_joints();

  private:
  const ::abb::egm::wrapper::Joints& _internal_joints() const;
  ::abb::egm::wrapper::Joints* _internal_mutable_joints();

  public:
  // optional .abb.egm.wrapper.CartesianPose cartesian = 2;
  bool has_cartesian() const;
  void clear_cartesian() ;
  const ::abb::egm::wrapper::CartesianPose& cartesian() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::CartesianPose* release_cartesian();
  ::abb::egm::wrapper::CartesianPose* mutable_cartesian();
  void set_allocated_cartesian(::abb::egm::wrapper::CartesianPose* value);
  void unsafe_arena_set_allocated_cartesian(::abb::egm::wrapper::CartesianPose* value);
  ::abb::egm::wrapper::CartesianPose* unsafe_arena_release_cartesian();

  private:
  const ::abb::egm::wrapper::CartesianPose& _internal_cartesian() const;
  ::abb::egm::wrapper::CartesianPose* _internal_mutable_cartesian();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.trajectory.RobotPositionGoal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Joints* joints_;
    ::abb::egm::wrapper::CartesianPose* cartesian_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_5ftrajectory_2eproto;
};// -------------------------------------------------------------------

class ExternalGoal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.trajectory.ExternalGoal) */ {
 public:
  inline ExternalGoal() : ExternalGoal(nullptr) {}
  ~ExternalGoal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExternalGoal(::google::protobuf::internal::ConstantInitialized);

  inline ExternalGoal(const ExternalGoal& from)
      : ExternalGoal(nullptr, from) {}
  ExternalGoal(ExternalGoal&& from) noexcept
    : ExternalGoal() {
    *this = ::std::move(from);
  }

  inline ExternalGoal& operator=(const ExternalGoal& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalGoal& operator=(ExternalGoal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalGoal& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalGoal* internal_default_instance() {
    return reinterpret_cast<const ExternalGoal*>(
               &_ExternalGoal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ExternalGoal& a, ExternalGoal& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalGoal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalGoal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalGoal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalGoal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExternalGoal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ExternalGoal& from) {
    ExternalGoal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExternalGoal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.trajectory.ExternalGoal";
  }
  protected:
  explicit ExternalGoal(::google::protobuf::Arena* arena);
  ExternalGoal(::google::protobuf::Arena* arena, const ExternalGoal& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
  };
  // optional .abb.egm.wrapper.trajectory.JointGoal joints = 1;
  bool has_joints() const;
  void clear_joints() ;
  const ::abb::egm::wrapper::trajectory::JointGoal& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::trajectory::JointGoal* release_joints();
  ::abb::egm::wrapper::trajectory::JointGoal* mutable_joints();
  void set_allocated_joints(::abb::egm::wrapper::trajectory::JointGoal* value);
  void unsafe_arena_set_allocated_joints(::abb::egm::wrapper::trajectory::JointGoal* value);
  ::abb::egm::wrapper::trajectory::JointGoal* unsafe_arena_release_joints();

  private:
  const ::abb::egm::wrapper::trajectory::JointGoal& _internal_joints() const;
  ::abb::egm::wrapper::trajectory::JointGoal* _internal_mutable_joints();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.trajectory.ExternalGoal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::trajectory::JointGoal* joints_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_5ftrajectory_2eproto;
};// -------------------------------------------------------------------

class CartesianGoal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.trajectory.CartesianGoal) */ {
 public:
  inline CartesianGoal() : CartesianGoal(nullptr) {}
  ~CartesianGoal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CartesianGoal(::google::protobuf::internal::ConstantInitialized);

  inline CartesianGoal(const CartesianGoal& from)
      : CartesianGoal(nullptr, from) {}
  CartesianGoal(CartesianGoal&& from) noexcept
    : CartesianGoal() {
    *this = ::std::move(from);
  }

  inline CartesianGoal& operator=(const CartesianGoal& from) {
    CopyFrom(from);
    return *this;
  }
  inline CartesianGoal& operator=(CartesianGoal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CartesianGoal& default_instance() {
    return *internal_default_instance();
  }
  static inline const CartesianGoal* internal_default_instance() {
    return reinterpret_cast<const CartesianGoal*>(
               &_CartesianGoal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CartesianGoal& a, CartesianGoal& b) {
    a.Swap(&b);
  }
  inline void Swap(CartesianGoal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CartesianGoal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CartesianGoal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CartesianGoal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CartesianGoal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CartesianGoal& from) {
    CartesianGoal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CartesianGoal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.trajectory.CartesianGoal";
  }
  protected:
  explicit CartesianGoal(::google::protobuf::Arena* arena);
  CartesianGoal(::google::protobuf::Arena* arena, const CartesianGoal& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
    kVelocityFieldNumber = 2,
    kAccelerationFieldNumber = 3,
  };
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  bool has_pose() const;
  void clear_pose() ;
  const ::abb::egm::wrapper::CartesianPose& pose() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::CartesianPose* release_pose();
  ::abb::egm::wrapper::CartesianPose* mutable_pose();
  void set_allocated_pose(::abb::egm::wrapper::CartesianPose* value);
  void unsafe_arena_set_allocated_pose(::abb::egm::wrapper::CartesianPose* value);
  ::abb::egm::wrapper::CartesianPose* unsafe_arena_release_pose();

  private:
  const ::abb::egm::wrapper::CartesianPose& _internal_pose() const;
  ::abb::egm::wrapper::CartesianPose* _internal_mutable_pose();

  public:
  // optional .abb.egm.wrapper.Cartesian velocity = 2;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::abb::egm::wrapper::Cartesian& velocity() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Cartesian* release_velocity();
  ::abb::egm::wrapper::Cartesian* mutable_velocity();
  void set_allocated_velocity(::abb::egm::wrapper::Cartesian* value);
  void unsafe_arena_set_allocated_velocity(::abb::egm::wrapper::Cartesian* value);
  ::abb::egm::wrapper::Cartesian* unsafe_arena_release_velocity();

  private:
  const ::abb::egm::wrapper::Cartesian& _internal_velocity() const;
  ::abb::egm::wrapper::Cartesian* _internal_mutable_velocity();

  public:
  // optional .abb.egm.wrapper.Cartesian acceleration = 3;
  bool has_acceleration() const;
  void clear_acceleration() ;
  const ::abb::egm::wrapper::Cartesian& acceleration() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Cartesian* release_acceleration();
  ::abb::egm::wrapper::Cartesian* mutable_acceleration();
  void set_allocated_acceleration(::abb::egm::wrapper::Cartesian* value);
  void unsafe_arena_set_allocated_acceleration(::abb::egm::wrapper::Cartesian* value);
  ::abb::egm::wrapper::Cartesian* unsafe_arena_release_acceleration();

  private:
  const ::abb::egm::wrapper::Cartesian& _internal_acceleration() const;
  ::abb::egm::wrapper::Cartesian* _internal_mutable_acceleration();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.trajectory.CartesianGoal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::CartesianPose* pose_;
    ::abb::egm::wrapper::Cartesian* velocity_;
    ::abb::egm::wrapper::Cartesian* acceleration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_5ftrajectory_2eproto;
};// -------------------------------------------------------------------

class StaticVelocityGoal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.trajectory.StaticVelocityGoal) */ {
 public:
  inline StaticVelocityGoal() : StaticVelocityGoal(nullptr) {}
  ~StaticVelocityGoal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StaticVelocityGoal(::google::protobuf::internal::ConstantInitialized);

  inline StaticVelocityGoal(const StaticVelocityGoal& from)
      : StaticVelocityGoal(nullptr, from) {}
  StaticVelocityGoal(StaticVelocityGoal&& from) noexcept
    : StaticVelocityGoal() {
    *this = ::std::move(from);
  }

  inline StaticVelocityGoal& operator=(const StaticVelocityGoal& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaticVelocityGoal& operator=(StaticVelocityGoal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaticVelocityGoal& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaticVelocityGoal* internal_default_instance() {
    return reinterpret_cast<const StaticVelocityGoal*>(
               &_StaticVelocityGoal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StaticVelocityGoal& a, StaticVelocityGoal& b) {
    a.Swap(&b);
  }
  inline void Swap(StaticVelocityGoal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaticVelocityGoal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaticVelocityGoal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaticVelocityGoal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StaticVelocityGoal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StaticVelocityGoal& from) {
    StaticVelocityGoal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StaticVelocityGoal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.trajectory.StaticVelocityGoal";
  }
  protected:
  explicit StaticVelocityGoal(::google::protobuf::Arena* arena);
  StaticVelocityGoal(::google::protobuf::Arena* arena, const StaticVelocityGoal& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
    kExternalFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.trajectory.RobotVelocityGoal robot = 1;
  bool has_robot() const;
  void clear_robot() ;
  const ::abb::egm::wrapper::trajectory::RobotVelocityGoal& robot() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::trajectory::RobotVelocityGoal* release_robot();
  ::abb::egm::wrapper::trajectory::RobotVelocityGoal* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::trajectory::RobotVelocityGoal* value);
  void unsafe_arena_set_allocated_robot(::abb::egm::wrapper::trajectory::RobotVelocityGoal* value);
  ::abb::egm::wrapper::trajectory::RobotVelocityGoal* unsafe_arena_release_robot();

  private:
  const ::abb::egm::wrapper::trajectory::RobotVelocityGoal& _internal_robot() const;
  ::abb::egm::wrapper::trajectory::RobotVelocityGoal* _internal_mutable_robot();

  public:
  // optional .abb.egm.wrapper.Joints external = 2;
  bool has_external() const;
  void clear_external() ;
  const ::abb::egm::wrapper::Joints& external() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Joints* release_external();
  ::abb::egm::wrapper::Joints* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::Joints* value);
  void unsafe_arena_set_allocated_external(::abb::egm::wrapper::Joints* value);
  ::abb::egm::wrapper::Joints* unsafe_arena_release_external();

  private:
  const ::abb::egm::wrapper::Joints& _internal_external() const;
  ::abb::egm::wrapper::Joints* _internal_mutable_external();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.trajectory.StaticVelocityGoal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::trajectory::RobotVelocityGoal* robot_;
    ::abb::egm::wrapper::Joints* external_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_5ftrajectory_2eproto;
};// -------------------------------------------------------------------

class StaticPositionGoal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.trajectory.StaticPositionGoal) */ {
 public:
  inline StaticPositionGoal() : StaticPositionGoal(nullptr) {}
  ~StaticPositionGoal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StaticPositionGoal(::google::protobuf::internal::ConstantInitialized);

  inline StaticPositionGoal(const StaticPositionGoal& from)
      : StaticPositionGoal(nullptr, from) {}
  StaticPositionGoal(StaticPositionGoal&& from) noexcept
    : StaticPositionGoal() {
    *this = ::std::move(from);
  }

  inline StaticPositionGoal& operator=(const StaticPositionGoal& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaticPositionGoal& operator=(StaticPositionGoal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaticPositionGoal& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaticPositionGoal* internal_default_instance() {
    return reinterpret_cast<const StaticPositionGoal*>(
               &_StaticPositionGoal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StaticPositionGoal& a, StaticPositionGoal& b) {
    a.Swap(&b);
  }
  inline void Swap(StaticPositionGoal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaticPositionGoal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaticPositionGoal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaticPositionGoal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StaticPositionGoal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StaticPositionGoal& from) {
    StaticPositionGoal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StaticPositionGoal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.trajectory.StaticPositionGoal";
  }
  protected:
  explicit StaticPositionGoal(::google::protobuf::Arena* arena);
  StaticPositionGoal(::google::protobuf::Arena* arena, const StaticPositionGoal& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
    kExternalFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.trajectory.RobotPositionGoal robot = 1;
  bool has_robot() const;
  void clear_robot() ;
  const ::abb::egm::wrapper::trajectory::RobotPositionGoal& robot() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::trajectory::RobotPositionGoal* release_robot();
  ::abb::egm::wrapper::trajectory::RobotPositionGoal* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::trajectory::RobotPositionGoal* value);
  void unsafe_arena_set_allocated_robot(::abb::egm::wrapper::trajectory::RobotPositionGoal* value);
  ::abb::egm::wrapper::trajectory::RobotPositionGoal* unsafe_arena_release_robot();

  private:
  const ::abb::egm::wrapper::trajectory::RobotPositionGoal& _internal_robot() const;
  ::abb::egm::wrapper::trajectory::RobotPositionGoal* _internal_mutable_robot();

  public:
  // optional .abb.egm.wrapper.Joints external = 2;
  bool has_external() const;
  void clear_external() ;
  const ::abb::egm::wrapper::Joints& external() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Joints* release_external();
  ::abb::egm::wrapper::Joints* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::Joints* value);
  void unsafe_arena_set_allocated_external(::abb::egm::wrapper::Joints* value);
  ::abb::egm::wrapper::Joints* unsafe_arena_release_external();

  private:
  const ::abb::egm::wrapper::Joints& _internal_external() const;
  ::abb::egm::wrapper::Joints* _internal_mutable_external();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.trajectory.StaticPositionGoal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::trajectory::RobotPositionGoal* robot_;
    ::abb::egm::wrapper::Joints* external_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_5ftrajectory_2eproto;
};// -------------------------------------------------------------------

class RobotGoal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.trajectory.RobotGoal) */ {
 public:
  inline RobotGoal() : RobotGoal(nullptr) {}
  ~RobotGoal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RobotGoal(::google::protobuf::internal::ConstantInitialized);

  inline RobotGoal(const RobotGoal& from)
      : RobotGoal(nullptr, from) {}
  RobotGoal(RobotGoal&& from) noexcept
    : RobotGoal() {
    *this = ::std::move(from);
  }

  inline RobotGoal& operator=(const RobotGoal& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotGoal& operator=(RobotGoal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotGoal& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotGoal* internal_default_instance() {
    return reinterpret_cast<const RobotGoal*>(
               &_RobotGoal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RobotGoal& a, RobotGoal& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotGoal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotGoal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotGoal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotGoal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RobotGoal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RobotGoal& from) {
    RobotGoal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RobotGoal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.trajectory.RobotGoal";
  }
  protected:
  explicit RobotGoal(::google::protobuf::Arena* arena);
  RobotGoal(::google::protobuf::Arena* arena, const RobotGoal& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesianFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.trajectory.JointGoal joints = 1;
  bool has_joints() const;
  void clear_joints() ;
  const ::abb::egm::wrapper::trajectory::JointGoal& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::trajectory::JointGoal* release_joints();
  ::abb::egm::wrapper::trajectory::JointGoal* mutable_joints();
  void set_allocated_joints(::abb::egm::wrapper::trajectory::JointGoal* value);
  void unsafe_arena_set_allocated_joints(::abb::egm::wrapper::trajectory::JointGoal* value);
  ::abb::egm::wrapper::trajectory::JointGoal* unsafe_arena_release_joints();

  private:
  const ::abb::egm::wrapper::trajectory::JointGoal& _internal_joints() const;
  ::abb::egm::wrapper::trajectory::JointGoal* _internal_mutable_joints();

  public:
  // optional .abb.egm.wrapper.trajectory.CartesianGoal cartesian = 2;
  bool has_cartesian() const;
  void clear_cartesian() ;
  const ::abb::egm::wrapper::trajectory::CartesianGoal& cartesian() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::trajectory::CartesianGoal* release_cartesian();
  ::abb::egm::wrapper::trajectory::CartesianGoal* mutable_cartesian();
  void set_allocated_cartesian(::abb::egm::wrapper::trajectory::CartesianGoal* value);
  void unsafe_arena_set_allocated_cartesian(::abb::egm::wrapper::trajectory::CartesianGoal* value);
  ::abb::egm::wrapper::trajectory::CartesianGoal* unsafe_arena_release_cartesian();

  private:
  const ::abb::egm::wrapper::trajectory::CartesianGoal& _internal_cartesian() const;
  ::abb::egm::wrapper::trajectory::CartesianGoal* _internal_mutable_cartesian();

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.trajectory.RobotGoal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::trajectory::JointGoal* joints_;
    ::abb::egm::wrapper::trajectory::CartesianGoal* cartesian_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_5ftrajectory_2eproto;
};// -------------------------------------------------------------------

class PointGoal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.trajectory.PointGoal) */ {
 public:
  inline PointGoal() : PointGoal(nullptr) {}
  ~PointGoal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointGoal(::google::protobuf::internal::ConstantInitialized);

  inline PointGoal(const PointGoal& from)
      : PointGoal(nullptr, from) {}
  PointGoal(PointGoal&& from) noexcept
    : PointGoal() {
    *this = ::std::move(from);
  }

  inline PointGoal& operator=(const PointGoal& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointGoal& operator=(PointGoal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointGoal& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointGoal* internal_default_instance() {
    return reinterpret_cast<const PointGoal*>(
               &_PointGoal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PointGoal& a, PointGoal& b) {
    a.Swap(&b);
  }
  inline void Swap(PointGoal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointGoal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointGoal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointGoal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointGoal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PointGoal& from) {
    PointGoal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PointGoal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.trajectory.PointGoal";
  }
  protected:
  explicit PointGoal(::google::protobuf::Arena* arena);
  PointGoal(::google::protobuf::Arena* arena, const PointGoal& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 2,
    kExternalFieldNumber = 3,
    kDurationFieldNumber = 1,
    kReachFieldNumber = 4,
  };
  // optional .abb.egm.wrapper.trajectory.RobotGoal robot = 2;
  bool has_robot() const;
  void clear_robot() ;
  const ::abb::egm::wrapper::trajectory::RobotGoal& robot() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::trajectory::RobotGoal* release_robot();
  ::abb::egm::wrapper::trajectory::RobotGoal* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::trajectory::RobotGoal* value);
  void unsafe_arena_set_allocated_robot(::abb::egm::wrapper::trajectory::RobotGoal* value);
  ::abb::egm::wrapper::trajectory::RobotGoal* unsafe_arena_release_robot();

  private:
  const ::abb::egm::wrapper::trajectory::RobotGoal& _internal_robot() const;
  ::abb::egm::wrapper::trajectory::RobotGoal* _internal_mutable_robot();

  public:
  // optional .abb.egm.wrapper.trajectory.ExternalGoal external = 3;
  bool has_external() const;
  void clear_external() ;
  const ::abb::egm::wrapper::trajectory::ExternalGoal& external() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::trajectory::ExternalGoal* release_external();
  ::abb::egm::wrapper::trajectory::ExternalGoal* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::trajectory::ExternalGoal* value);
  void unsafe_arena_set_allocated_external(::abb::egm::wrapper::trajectory::ExternalGoal* value);
  ::abb::egm::wrapper::trajectory::ExternalGoal* unsafe_arena_release_external();

  private:
  const ::abb::egm::wrapper::trajectory::ExternalGoal& _internal_external() const;
  ::abb::egm::wrapper::trajectory::ExternalGoal* _internal_mutable_external();

  public:
  // optional double duration = 1;
  bool has_duration() const;
  void clear_duration() ;
  double duration() const;
  void set_duration(double value);

  private:
  double _internal_duration() const;
  void _internal_set_duration(double value);

  public:
  // optional bool reach = 4;
  bool has_reach() const;
  void clear_reach() ;
  bool reach() const;
  void set_reach(bool value);

  private:
  bool _internal_reach() const;
  void _internal_set_reach(bool value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.trajectory.PointGoal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::trajectory::RobotGoal* robot_;
    ::abb::egm::wrapper::trajectory::ExternalGoal* external_;
    double duration_;
    bool reach_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_5ftrajectory_2eproto;
};// -------------------------------------------------------------------

class TrajectoryGoal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.trajectory.TrajectoryGoal) */ {
 public:
  inline TrajectoryGoal() : TrajectoryGoal(nullptr) {}
  ~TrajectoryGoal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrajectoryGoal(::google::protobuf::internal::ConstantInitialized);

  inline TrajectoryGoal(const TrajectoryGoal& from)
      : TrajectoryGoal(nullptr, from) {}
  TrajectoryGoal(TrajectoryGoal&& from) noexcept
    : TrajectoryGoal() {
    *this = ::std::move(from);
  }

  inline TrajectoryGoal& operator=(const TrajectoryGoal& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrajectoryGoal& operator=(TrajectoryGoal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrajectoryGoal& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrajectoryGoal* internal_default_instance() {
    return reinterpret_cast<const TrajectoryGoal*>(
               &_TrajectoryGoal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TrajectoryGoal& a, TrajectoryGoal& b) {
    a.Swap(&b);
  }
  inline void Swap(TrajectoryGoal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrajectoryGoal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrajectoryGoal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrajectoryGoal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrajectoryGoal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrajectoryGoal& from) {
    TrajectoryGoal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrajectoryGoal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.trajectory.TrajectoryGoal";
  }
  protected:
  explicit TrajectoryGoal(::google::protobuf::Arena* arena);
  TrajectoryGoal(::google::protobuf::Arena* arena, const TrajectoryGoal& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
  };
  // repeated .abb.egm.wrapper.trajectory.PointGoal points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::abb::egm::wrapper::trajectory::PointGoal* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::egm::wrapper::trajectory::PointGoal >*
      mutable_points();
  private:
  const ::google::protobuf::RepeatedPtrField<::abb::egm::wrapper::trajectory::PointGoal>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::abb::egm::wrapper::trajectory::PointGoal>* _internal_mutable_points();
  public:
  const ::abb::egm::wrapper::trajectory::PointGoal& points(int index) const;
  ::abb::egm::wrapper::trajectory::PointGoal* add_points();
  const ::google::protobuf::RepeatedPtrField< ::abb::egm::wrapper::trajectory::PointGoal >&
      points() const;
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.trajectory.TrajectoryGoal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::abb::egm::wrapper::trajectory::PointGoal > points_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_5ftrajectory_2eproto;
};// -------------------------------------------------------------------

class ExecutionProgress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.trajectory.ExecutionProgress) */ {
 public:
  inline ExecutionProgress() : ExecutionProgress(nullptr) {}
  ~ExecutionProgress() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExecutionProgress(::google::protobuf::internal::ConstantInitialized);

  inline ExecutionProgress(const ExecutionProgress& from)
      : ExecutionProgress(nullptr, from) {}
  ExecutionProgress(ExecutionProgress&& from) noexcept
    : ExecutionProgress() {
    *this = ::std::move(from);
  }

  inline ExecutionProgress& operator=(const ExecutionProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionProgress& operator=(ExecutionProgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionProgress& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionProgress* internal_default_instance() {
    return reinterpret_cast<const ExecutionProgress*>(
               &_ExecutionProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ExecutionProgress& a, ExecutionProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionProgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionProgress* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionProgress* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionProgress>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExecutionProgress& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ExecutionProgress& from) {
    ExecutionProgress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExecutionProgress* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "abb.egm.wrapper.trajectory.ExecutionProgress";
  }
  protected:
  explicit ExecutionProgress(::google::protobuf::Arena* arena);
  ExecutionProgress(::google::protobuf::Arena* arena, const ExecutionProgress& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using State = ExecutionProgress_State;
  static constexpr State UNDEFINED = ExecutionProgress_State_UNDEFINED;
  static constexpr State NORMAL = ExecutionProgress_State_NORMAL;
  static constexpr State RAMP_DOWN = ExecutionProgress_State_RAMP_DOWN;
  static constexpr State STATIC_GOAL = ExecutionProgress_State_STATIC_GOAL;
  static inline bool State_IsValid(int value) {
    return ExecutionProgress_State_IsValid(value);
  }
  static constexpr State State_MIN = ExecutionProgress_State_State_MIN;
  static constexpr State State_MAX = ExecutionProgress_State_State_MAX;
  static constexpr int State_ARRAYSIZE = ExecutionProgress_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* State_descriptor() {
    return ExecutionProgress_State_descriptor();
  }
  template <typename T>
  static inline const std::string& State_Name(T value) {
    return ExecutionProgress_State_Name(value);
  }
  static inline bool State_Parse(absl::string_view name, State* value) {
    return ExecutionProgress_State_Parse(name, value);
  }

  using SubState = ExecutionProgress_SubState;
  static constexpr SubState NONE = ExecutionProgress_SubState_NONE;
  static constexpr SubState RUNNING = ExecutionProgress_SubState_RUNNING;
  static constexpr SubState FINISHED = ExecutionProgress_SubState_FINISHED;
  static inline bool SubState_IsValid(int value) {
    return ExecutionProgress_SubState_IsValid(value);
  }
  static constexpr SubState SubState_MIN = ExecutionProgress_SubState_SubState_MIN;
  static constexpr SubState SubState_MAX = ExecutionProgress_SubState_SubState_MAX;
  static constexpr int SubState_ARRAYSIZE = ExecutionProgress_SubState_SubState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SubState_descriptor() {
    return ExecutionProgress_SubState_descriptor();
  }
  template <typename T>
  static inline const std::string& SubState_Name(T value) {
    return ExecutionProgress_SubState_Name(value);
  }
  static inline bool SubState_Parse(absl::string_view name, SubState* value) {
    return ExecutionProgress_SubState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 3,
    kOutputsFieldNumber = 4,
    kGoalFieldNumber = 7,
    kActiveTrajectoryFieldNumber = 8,
    kStateFieldNumber = 1,
    kSubStateFieldNumber = 2,
    kTimePassedFieldNumber = 5,
    kGoalActiveFieldNumber = 6,
    kPendingTrajectoriesFieldNumber = 9,
  };
  // optional .abb.egm.wrapper.Input inputs = 3;
  bool has_inputs() const;
  void clear_inputs() ;
  const ::abb::egm::wrapper::Input& inputs() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Input* release_inputs();
  ::abb::egm::wrapper::Input* mutable_inputs();
  void set_allocated_inputs(::abb::egm::wrapper::Input* value);
  void unsafe_arena_set_allocated_inputs(::abb::egm::wrapper::Input* value);
  ::abb::egm::wrapper::Input* unsafe_arena_release_inputs();

  private:
  const ::abb::egm::wrapper::Input& _internal_inputs() const;
  ::abb::egm::wrapper::Input* _internal_mutable_inputs();

  public:
  // optional .abb.egm.wrapper.Output outputs = 4;
  bool has_outputs() const;
  void clear_outputs() ;
  const ::abb::egm::wrapper::Output& outputs() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Output* release_outputs();
  ::abb::egm::wrapper::Output* mutable_outputs();
  void set_allocated_outputs(::abb::egm::wrapper::Output* value);
  void unsafe_arena_set_allocated_outputs(::abb::egm::wrapper::Output* value);
  ::abb::egm::wrapper::Output* unsafe_arena_release_outputs();

  private:
  const ::abb::egm::wrapper::Output& _internal_outputs() const;
  ::abb::egm::wrapper::Output* _internal_mutable_outputs();

  public:
  // optional .abb.egm.wrapper.trajectory.PointGoal goal = 7;
  bool has_goal() const;
  void clear_goal() ;
  const ::abb::egm::wrapper::trajectory::PointGoal& goal() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::trajectory::PointGoal* release_goal();
  ::abb::egm::wrapper::trajectory::PointGoal* mutable_goal();
  void set_allocated_goal(::abb::egm::wrapper::trajectory::PointGoal* value);
  void unsafe_arena_set_allocated_goal(::abb::egm::wrapper::trajectory::PointGoal* value);
  ::abb::egm::wrapper::trajectory::PointGoal* unsafe_arena_release_goal();

  private:
  const ::abb::egm::wrapper::trajectory::PointGoal& _internal_goal() const;
  ::abb::egm::wrapper::trajectory::PointGoal* _internal_mutable_goal();

  public:
  // optional .abb.egm.wrapper.trajectory.TrajectoryGoal active_trajectory = 8;
  bool has_active_trajectory() const;
  void clear_active_trajectory() ;
  const ::abb::egm::wrapper::trajectory::TrajectoryGoal& active_trajectory() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::trajectory::TrajectoryGoal* release_active_trajectory();
  ::abb::egm::wrapper::trajectory::TrajectoryGoal* mutable_active_trajectory();
  void set_allocated_active_trajectory(::abb::egm::wrapper::trajectory::TrajectoryGoal* value);
  void unsafe_arena_set_allocated_active_trajectory(::abb::egm::wrapper::trajectory::TrajectoryGoal* value);
  ::abb::egm::wrapper::trajectory::TrajectoryGoal* unsafe_arena_release_active_trajectory();

  private:
  const ::abb::egm::wrapper::trajectory::TrajectoryGoal& _internal_active_trajectory() const;
  ::abb::egm::wrapper::trajectory::TrajectoryGoal* _internal_mutable_active_trajectory();

  public:
  // optional .abb.egm.wrapper.trajectory.ExecutionProgress.State state = 1 [default = UNDEFINED];
  bool has_state() const;
  void clear_state() ;
  ::abb::egm::wrapper::trajectory::ExecutionProgress_State state() const;
  void set_state(::abb::egm::wrapper::trajectory::ExecutionProgress_State value);

  private:
  ::abb::egm::wrapper::trajectory::ExecutionProgress_State _internal_state() const;
  void _internal_set_state(::abb::egm::wrapper::trajectory::ExecutionProgress_State value);

  public:
  // optional .abb.egm.wrapper.trajectory.ExecutionProgress.SubState sub_state = 2 [default = NONE];
  bool has_sub_state() const;
  void clear_sub_state() ;
  ::abb::egm::wrapper::trajectory::ExecutionProgress_SubState sub_state() const;
  void set_sub_state(::abb::egm::wrapper::trajectory::ExecutionProgress_SubState value);

  private:
  ::abb::egm::wrapper::trajectory::ExecutionProgress_SubState _internal_sub_state() const;
  void _internal_set_sub_state(::abb::egm::wrapper::trajectory::ExecutionProgress_SubState value);

  public:
  // optional double time_passed = 5;
  bool has_time_passed() const;
  void clear_time_passed() ;
  double time_passed() const;
  void set_time_passed(double value);

  private:
  double _internal_time_passed() const;
  void _internal_set_time_passed(double value);

  public:
  // optional bool goal_active = 6;
  bool has_goal_active() const;
  void clear_goal_active() ;
  bool goal_active() const;
  void set_goal_active(bool value);

  private:
  bool _internal_goal_active() const;
  void _internal_set_goal_active(bool value);

  public:
  // optional uint32 pending_trajectories = 9;
  bool has_pending_trajectories() const;
  void clear_pending_trajectories() ;
  ::uint32_t pending_trajectories() const;
  void set_pending_trajectories(::uint32_t value);

  private:
  ::uint32_t _internal_pending_trajectories() const;
  void _internal_set_pending_trajectories(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.trajectory.ExecutionProgress)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 6,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Input* inputs_;
    ::abb::egm::wrapper::Output* outputs_;
    ::abb::egm::wrapper::trajectory::PointGoal* goal_;
    ::abb::egm::wrapper::trajectory::TrajectoryGoal* active_trajectory_;
    int state_;
    int sub_state_;
    double time_passed_;
    bool goal_active_;
    ::uint32_t pending_trajectories_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_5ftrajectory_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// JointGoal

// optional .abb.egm.wrapper.Joints position = 1;
inline bool JointGoal::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::Joints& JointGoal::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Joints* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Joints&>(::abb::egm::wrapper::_Joints_default_instance_);
}
inline const ::abb::egm::wrapper::Joints& JointGoal::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.JointGoal.position)
  return _internal_position();
}
inline void JointGoal::unsafe_arena_set_allocated_position(::abb::egm::wrapper::Joints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.JointGoal.position)
}
inline ::abb::egm::wrapper::Joints* JointGoal::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Joints* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Joints* JointGoal::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.JointGoal.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Joints* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointGoal::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArena());
    _impl_.position_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(p);
  }
  return _impl_.position_;
}
inline ::abb::egm::wrapper::Joints* JointGoal::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Joints* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.JointGoal.position)
  return _msg;
}
inline void JointGoal::set_allocated_position(::abb::egm::wrapper::Joints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.JointGoal.position)
}

// optional .abb.egm.wrapper.Joints velocity = 2;
inline bool JointGoal::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::Joints& JointGoal::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Joints* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Joints&>(::abb::egm::wrapper::_Joints_default_instance_);
}
inline const ::abb::egm::wrapper::Joints& JointGoal::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.JointGoal.velocity)
  return _internal_velocity();
}
inline void JointGoal::unsafe_arena_set_allocated_velocity(::abb::egm::wrapper::Joints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.JointGoal.velocity)
}
inline ::abb::egm::wrapper::Joints* JointGoal::release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Joints* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Joints* JointGoal::unsafe_arena_release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.JointGoal.velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Joints* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointGoal::_internal_mutable_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(p);
  }
  return _impl_.velocity_;
}
inline ::abb::egm::wrapper::Joints* JointGoal::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Joints* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.JointGoal.velocity)
  return _msg;
}
inline void JointGoal::set_allocated_velocity(::abb::egm::wrapper::Joints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.velocity_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.JointGoal.velocity)
}

// optional .abb.egm.wrapper.Joints acceleration = 3;
inline bool JointGoal::has_acceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.acceleration_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::Joints& JointGoal::_internal_acceleration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Joints* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Joints&>(::abb::egm::wrapper::_Joints_default_instance_);
}
inline const ::abb::egm::wrapper::Joints& JointGoal::acceleration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.JointGoal.acceleration)
  return _internal_acceleration();
}
inline void JointGoal::unsafe_arena_set_allocated_acceleration(::abb::egm::wrapper::Joints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.JointGoal.acceleration)
}
inline ::abb::egm::wrapper::Joints* JointGoal::release_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Joints* released = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Joints* JointGoal::unsafe_arena_release_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.JointGoal.acceleration)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Joints* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointGoal::_internal_mutable_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArena());
    _impl_.acceleration_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(p);
  }
  return _impl_.acceleration_;
}
inline ::abb::egm::wrapper::Joints* JointGoal::mutable_acceleration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Joints* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.JointGoal.acceleration)
  return _msg;
}
inline void JointGoal::set_allocated_acceleration(::abb::egm::wrapper::Joints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.acceleration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.acceleration_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.JointGoal.acceleration)
}

// -------------------------------------------------------------------

// CartesianGoal

// optional .abb.egm.wrapper.CartesianPose pose = 1;
inline bool CartesianGoal::has_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pose_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::CartesianPose& CartesianGoal::_internal_pose() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::CartesianPose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::CartesianPose&>(::abb::egm::wrapper::_CartesianPose_default_instance_);
}
inline const ::abb::egm::wrapper::CartesianPose& CartesianGoal::pose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.CartesianGoal.pose)
  return _internal_pose();
}
inline void CartesianGoal::unsafe_arena_set_allocated_pose(::abb::egm::wrapper::CartesianPose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = reinterpret_cast<::abb::egm::wrapper::CartesianPose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.CartesianGoal.pose)
}
inline ::abb::egm::wrapper::CartesianPose* CartesianGoal::release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::CartesianPose* released = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianGoal::unsafe_arena_release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.CartesianGoal.pose)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::CartesianPose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianGoal::_internal_mutable_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianPose>(GetArena());
    _impl_.pose_ = reinterpret_cast<::abb::egm::wrapper::CartesianPose*>(p);
  }
  return _impl_.pose_;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianGoal::mutable_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::CartesianPose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.CartesianGoal.pose)
  return _msg;
}
inline void CartesianGoal::set_allocated_pose(::abb::egm::wrapper::CartesianPose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pose_ = reinterpret_cast<::abb::egm::wrapper::CartesianPose*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.CartesianGoal.pose)
}

// optional .abb.egm.wrapper.Cartesian velocity = 2;
inline bool CartesianGoal::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::Cartesian& CartesianGoal::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Cartesian* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Cartesian&>(::abb::egm::wrapper::_Cartesian_default_instance_);
}
inline const ::abb::egm::wrapper::Cartesian& CartesianGoal::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.CartesianGoal.velocity)
  return _internal_velocity();
}
inline void CartesianGoal::unsafe_arena_set_allocated_velocity(::abb::egm::wrapper::Cartesian* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.CartesianGoal.velocity)
}
inline ::abb::egm::wrapper::Cartesian* CartesianGoal::release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Cartesian* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Cartesian* CartesianGoal::unsafe_arena_release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.CartesianGoal.velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Cartesian* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianGoal::_internal_mutable_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Cartesian>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(p);
  }
  return _impl_.velocity_;
}
inline ::abb::egm::wrapper::Cartesian* CartesianGoal::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Cartesian* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.CartesianGoal.velocity)
  return _msg;
}
inline void CartesianGoal::set_allocated_velocity(::abb::egm::wrapper::Cartesian* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.velocity_ = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.CartesianGoal.velocity)
}

// optional .abb.egm.wrapper.Cartesian acceleration = 3;
inline bool CartesianGoal::has_acceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.acceleration_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::Cartesian& CartesianGoal::_internal_acceleration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Cartesian* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Cartesian&>(::abb::egm::wrapper::_Cartesian_default_instance_);
}
inline const ::abb::egm::wrapper::Cartesian& CartesianGoal::acceleration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.CartesianGoal.acceleration)
  return _internal_acceleration();
}
inline void CartesianGoal::unsafe_arena_set_allocated_acceleration(::abb::egm::wrapper::Cartesian* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.CartesianGoal.acceleration)
}
inline ::abb::egm::wrapper::Cartesian* CartesianGoal::release_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Cartesian* released = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Cartesian* CartesianGoal::unsafe_arena_release_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.CartesianGoal.acceleration)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Cartesian* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianGoal::_internal_mutable_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Cartesian>(GetArena());
    _impl_.acceleration_ = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(p);
  }
  return _impl_.acceleration_;
}
inline ::abb::egm::wrapper::Cartesian* CartesianGoal::mutable_acceleration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Cartesian* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.CartesianGoal.acceleration)
  return _msg;
}
inline void CartesianGoal::set_allocated_acceleration(::abb::egm::wrapper::Cartesian* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.acceleration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.acceleration_ = reinterpret_cast<::abb::egm::wrapper::Cartesian*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.CartesianGoal.acceleration)
}

// -------------------------------------------------------------------

// RobotGoal

// optional .abb.egm.wrapper.trajectory.JointGoal joints = 1;
inline bool RobotGoal::has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline void RobotGoal::clear_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.joints_ != nullptr) _impl_.joints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::trajectory::JointGoal& RobotGoal::_internal_joints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::trajectory::JointGoal* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::trajectory::JointGoal&>(::abb::egm::wrapper::trajectory::_JointGoal_default_instance_);
}
inline const ::abb::egm::wrapper::trajectory::JointGoal& RobotGoal::joints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.RobotGoal.joints)
  return _internal_joints();
}
inline void RobotGoal::unsafe_arena_set_allocated_joints(::abb::egm::wrapper::trajectory::JointGoal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::trajectory::JointGoal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.RobotGoal.joints)
}
inline ::abb::egm::wrapper::trajectory::JointGoal* RobotGoal::release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::trajectory::JointGoal* released = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::trajectory::JointGoal* RobotGoal::unsafe_arena_release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.RobotGoal.joints)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::trajectory::JointGoal* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::trajectory::JointGoal* RobotGoal::_internal_mutable_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::trajectory::JointGoal>(GetArena());
    _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::trajectory::JointGoal*>(p);
  }
  return _impl_.joints_;
}
inline ::abb::egm::wrapper::trajectory::JointGoal* RobotGoal::mutable_joints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::trajectory::JointGoal* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.RobotGoal.joints)
  return _msg;
}
inline void RobotGoal::set_allocated_joints(::abb::egm::wrapper::trajectory::JointGoal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::trajectory::JointGoal*>(_impl_.joints_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::trajectory::JointGoal*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::trajectory::JointGoal*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.RobotGoal.joints)
}

// optional .abb.egm.wrapper.trajectory.CartesianGoal cartesian = 2;
inline bool RobotGoal::has_cartesian() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cartesian_ != nullptr);
  return value;
}
inline void RobotGoal::clear_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.cartesian_ != nullptr) _impl_.cartesian_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::trajectory::CartesianGoal& RobotGoal::_internal_cartesian() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::trajectory::CartesianGoal* p = _impl_.cartesian_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::trajectory::CartesianGoal&>(::abb::egm::wrapper::trajectory::_CartesianGoal_default_instance_);
}
inline const ::abb::egm::wrapper::trajectory::CartesianGoal& RobotGoal::cartesian() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.RobotGoal.cartesian)
  return _internal_cartesian();
}
inline void RobotGoal::unsafe_arena_set_allocated_cartesian(::abb::egm::wrapper::trajectory::CartesianGoal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cartesian_);
  }
  _impl_.cartesian_ = reinterpret_cast<::abb::egm::wrapper::trajectory::CartesianGoal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.RobotGoal.cartesian)
}
inline ::abb::egm::wrapper::trajectory::CartesianGoal* RobotGoal::release_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::trajectory::CartesianGoal* released = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::trajectory::CartesianGoal* RobotGoal::unsafe_arena_release_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.RobotGoal.cartesian)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::trajectory::CartesianGoal* temp = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::trajectory::CartesianGoal* RobotGoal::_internal_mutable_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cartesian_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::trajectory::CartesianGoal>(GetArena());
    _impl_.cartesian_ = reinterpret_cast<::abb::egm::wrapper::trajectory::CartesianGoal*>(p);
  }
  return _impl_.cartesian_;
}
inline ::abb::egm::wrapper::trajectory::CartesianGoal* RobotGoal::mutable_cartesian() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::trajectory::CartesianGoal* _msg = _internal_mutable_cartesian();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.RobotGoal.cartesian)
  return _msg;
}
inline void RobotGoal::set_allocated_cartesian(::abb::egm::wrapper::trajectory::CartesianGoal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::trajectory::CartesianGoal*>(_impl_.cartesian_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::trajectory::CartesianGoal*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.cartesian_ = reinterpret_cast<::abb::egm::wrapper::trajectory::CartesianGoal*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.RobotGoal.cartesian)
}

// -------------------------------------------------------------------

// ExternalGoal

// optional .abb.egm.wrapper.trajectory.JointGoal joints = 1;
inline bool ExternalGoal::has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline void ExternalGoal::clear_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.joints_ != nullptr) _impl_.joints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::trajectory::JointGoal& ExternalGoal::_internal_joints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::trajectory::JointGoal* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::trajectory::JointGoal&>(::abb::egm::wrapper::trajectory::_JointGoal_default_instance_);
}
inline const ::abb::egm::wrapper::trajectory::JointGoal& ExternalGoal::joints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.ExternalGoal.joints)
  return _internal_joints();
}
inline void ExternalGoal::unsafe_arena_set_allocated_joints(::abb::egm::wrapper::trajectory::JointGoal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::trajectory::JointGoal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.ExternalGoal.joints)
}
inline ::abb::egm::wrapper::trajectory::JointGoal* ExternalGoal::release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::trajectory::JointGoal* released = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::trajectory::JointGoal* ExternalGoal::unsafe_arena_release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.ExternalGoal.joints)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::trajectory::JointGoal* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::trajectory::JointGoal* ExternalGoal::_internal_mutable_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::trajectory::JointGoal>(GetArena());
    _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::trajectory::JointGoal*>(p);
  }
  return _impl_.joints_;
}
inline ::abb::egm::wrapper::trajectory::JointGoal* ExternalGoal::mutable_joints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::trajectory::JointGoal* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.ExternalGoal.joints)
  return _msg;
}
inline void ExternalGoal::set_allocated_joints(::abb::egm::wrapper::trajectory::JointGoal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::trajectory::JointGoal*>(_impl_.joints_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::trajectory::JointGoal*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::trajectory::JointGoal*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.ExternalGoal.joints)
}

// -------------------------------------------------------------------

// PointGoal

// optional double duration = 1;
inline bool PointGoal::has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PointGoal::clear_duration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.duration_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double PointGoal::duration() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.PointGoal.duration)
  return _internal_duration();
}
inline void PointGoal::set_duration(double value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.trajectory.PointGoal.duration)
}
inline double PointGoal::_internal_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_;
}
inline void PointGoal::_internal_set_duration(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.duration_ = value;
}

// optional .abb.egm.wrapper.trajectory.RobotGoal robot = 2;
inline bool PointGoal::has_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ != nullptr);
  return value;
}
inline void PointGoal::clear_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.robot_ != nullptr) _impl_.robot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::trajectory::RobotGoal& PointGoal::_internal_robot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::trajectory::RobotGoal* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::trajectory::RobotGoal&>(::abb::egm::wrapper::trajectory::_RobotGoal_default_instance_);
}
inline const ::abb::egm::wrapper::trajectory::RobotGoal& PointGoal::robot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.PointGoal.robot)
  return _internal_robot();
}
inline void PointGoal::unsafe_arena_set_allocated_robot(::abb::egm::wrapper::trajectory::RobotGoal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::trajectory::RobotGoal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.PointGoal.robot)
}
inline ::abb::egm::wrapper::trajectory::RobotGoal* PointGoal::release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::trajectory::RobotGoal* released = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::trajectory::RobotGoal* PointGoal::unsafe_arena_release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.PointGoal.robot)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::trajectory::RobotGoal* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::trajectory::RobotGoal* PointGoal::_internal_mutable_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::trajectory::RobotGoal>(GetArena());
    _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::trajectory::RobotGoal*>(p);
  }
  return _impl_.robot_;
}
inline ::abb::egm::wrapper::trajectory::RobotGoal* PointGoal::mutable_robot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::trajectory::RobotGoal* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.PointGoal.robot)
  return _msg;
}
inline void PointGoal::set_allocated_robot(::abb::egm::wrapper::trajectory::RobotGoal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::trajectory::RobotGoal*>(_impl_.robot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::trajectory::RobotGoal*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::trajectory::RobotGoal*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.PointGoal.robot)
}

// optional .abb.egm.wrapper.trajectory.ExternalGoal external = 3;
inline bool PointGoal::has_external() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_ != nullptr);
  return value;
}
inline void PointGoal::clear_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.external_ != nullptr) _impl_.external_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::trajectory::ExternalGoal& PointGoal::_internal_external() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::trajectory::ExternalGoal* p = _impl_.external_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::trajectory::ExternalGoal&>(::abb::egm::wrapper::trajectory::_ExternalGoal_default_instance_);
}
inline const ::abb::egm::wrapper::trajectory::ExternalGoal& PointGoal::external() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.PointGoal.external)
  return _internal_external();
}
inline void PointGoal::unsafe_arena_set_allocated_external(::abb::egm::wrapper::trajectory::ExternalGoal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.external_);
  }
  _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::trajectory::ExternalGoal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.PointGoal.external)
}
inline ::abb::egm::wrapper::trajectory::ExternalGoal* PointGoal::release_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::trajectory::ExternalGoal* released = _impl_.external_;
  _impl_.external_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::trajectory::ExternalGoal* PointGoal::unsafe_arena_release_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.PointGoal.external)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::trajectory::ExternalGoal* temp = _impl_.external_;
  _impl_.external_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::trajectory::ExternalGoal* PointGoal::_internal_mutable_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.external_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::trajectory::ExternalGoal>(GetArena());
    _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::trajectory::ExternalGoal*>(p);
  }
  return _impl_.external_;
}
inline ::abb::egm::wrapper::trajectory::ExternalGoal* PointGoal::mutable_external() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::trajectory::ExternalGoal* _msg = _internal_mutable_external();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.PointGoal.external)
  return _msg;
}
inline void PointGoal::set_allocated_external(::abb::egm::wrapper::trajectory::ExternalGoal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::trajectory::ExternalGoal*>(_impl_.external_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::trajectory::ExternalGoal*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::trajectory::ExternalGoal*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.PointGoal.external)
}

// optional bool reach = 4;
inline bool PointGoal::has_reach() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PointGoal::clear_reach() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reach_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool PointGoal::reach() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.PointGoal.reach)
  return _internal_reach();
}
inline void PointGoal::set_reach(bool value) {
  _internal_set_reach(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.trajectory.PointGoal.reach)
}
inline bool PointGoal::_internal_reach() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reach_;
}
inline void PointGoal::_internal_set_reach(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.reach_ = value;
}

// -------------------------------------------------------------------

// RobotPositionGoal

// optional .abb.egm.wrapper.Joints joints = 1;
inline bool RobotPositionGoal::has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::Joints& RobotPositionGoal::_internal_joints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Joints* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Joints&>(::abb::egm::wrapper::_Joints_default_instance_);
}
inline const ::abb::egm::wrapper::Joints& RobotPositionGoal::joints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.RobotPositionGoal.joints)
  return _internal_joints();
}
inline void RobotPositionGoal::unsafe_arena_set_allocated_joints(::abb::egm::wrapper::Joints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.RobotPositionGoal.joints)
}
inline ::abb::egm::wrapper::Joints* RobotPositionGoal::release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Joints* released = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Joints* RobotPositionGoal::unsafe_arena_release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.RobotPositionGoal.joints)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Joints* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Joints* RobotPositionGoal::_internal_mutable_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArena());
    _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(p);
  }
  return _impl_.joints_;
}
inline ::abb::egm::wrapper::Joints* RobotPositionGoal::mutable_joints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Joints* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.RobotPositionGoal.joints)
  return _msg;
}
inline void RobotPositionGoal::set_allocated_joints(::abb::egm::wrapper::Joints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joints_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.RobotPositionGoal.joints)
}

// optional .abb.egm.wrapper.CartesianPose cartesian = 2;
inline bool RobotPositionGoal::has_cartesian() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cartesian_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::CartesianPose& RobotPositionGoal::_internal_cartesian() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::CartesianPose* p = _impl_.cartesian_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::CartesianPose&>(::abb::egm::wrapper::_CartesianPose_default_instance_);
}
inline const ::abb::egm::wrapper::CartesianPose& RobotPositionGoal::cartesian() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.RobotPositionGoal.cartesian)
  return _internal_cartesian();
}
inline void RobotPositionGoal::unsafe_arena_set_allocated_cartesian(::abb::egm::wrapper::CartesianPose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cartesian_);
  }
  _impl_.cartesian_ = reinterpret_cast<::abb::egm::wrapper::CartesianPose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.RobotPositionGoal.cartesian)
}
inline ::abb::egm::wrapper::CartesianPose* RobotPositionGoal::release_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianPose* released = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::CartesianPose* RobotPositionGoal::unsafe_arena_release_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.RobotPositionGoal.cartesian)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianPose* temp = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::CartesianPose* RobotPositionGoal::_internal_mutable_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cartesian_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianPose>(GetArena());
    _impl_.cartesian_ = reinterpret_cast<::abb::egm::wrapper::CartesianPose*>(p);
  }
  return _impl_.cartesian_;
}
inline ::abb::egm::wrapper::CartesianPose* RobotPositionGoal::mutable_cartesian() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::CartesianPose* _msg = _internal_mutable_cartesian();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.RobotPositionGoal.cartesian)
  return _msg;
}
inline void RobotPositionGoal::set_allocated_cartesian(::abb::egm::wrapper::CartesianPose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cartesian_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.cartesian_ = reinterpret_cast<::abb::egm::wrapper::CartesianPose*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.RobotPositionGoal.cartesian)
}

// -------------------------------------------------------------------

// RobotVelocityGoal

// optional .abb.egm.wrapper.Joints joints = 1;
inline bool RobotVelocityGoal::has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::Joints& RobotVelocityGoal::_internal_joints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Joints* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Joints&>(::abb::egm::wrapper::_Joints_default_instance_);
}
inline const ::abb::egm::wrapper::Joints& RobotVelocityGoal::joints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.RobotVelocityGoal.joints)
  return _internal_joints();
}
inline void RobotVelocityGoal::unsafe_arena_set_allocated_joints(::abb::egm::wrapper::Joints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.RobotVelocityGoal.joints)
}
inline ::abb::egm::wrapper::Joints* RobotVelocityGoal::release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Joints* released = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Joints* RobotVelocityGoal::unsafe_arena_release_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.RobotVelocityGoal.joints)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Joints* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Joints* RobotVelocityGoal::_internal_mutable_joints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArena());
    _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(p);
  }
  return _impl_.joints_;
}
inline ::abb::egm::wrapper::Joints* RobotVelocityGoal::mutable_joints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Joints* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.RobotVelocityGoal.joints)
  return _msg;
}
inline void RobotVelocityGoal::set_allocated_joints(::abb::egm::wrapper::Joints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joints_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.joints_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.RobotVelocityGoal.joints)
}

// optional .abb.egm.wrapper.CartesianVelocity cartesian = 2;
inline bool RobotVelocityGoal::has_cartesian() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cartesian_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::CartesianVelocity& RobotVelocityGoal::_internal_cartesian() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::CartesianVelocity* p = _impl_.cartesian_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::CartesianVelocity&>(::abb::egm::wrapper::_CartesianVelocity_default_instance_);
}
inline const ::abb::egm::wrapper::CartesianVelocity& RobotVelocityGoal::cartesian() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.RobotVelocityGoal.cartesian)
  return _internal_cartesian();
}
inline void RobotVelocityGoal::unsafe_arena_set_allocated_cartesian(::abb::egm::wrapper::CartesianVelocity* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cartesian_);
  }
  _impl_.cartesian_ = reinterpret_cast<::abb::egm::wrapper::CartesianVelocity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.RobotVelocityGoal.cartesian)
}
inline ::abb::egm::wrapper::CartesianVelocity* RobotVelocityGoal::release_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianVelocity* released = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::CartesianVelocity* RobotVelocityGoal::unsafe_arena_release_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.RobotVelocityGoal.cartesian)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianVelocity* temp = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::CartesianVelocity* RobotVelocityGoal::_internal_mutable_cartesian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cartesian_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianVelocity>(GetArena());
    _impl_.cartesian_ = reinterpret_cast<::abb::egm::wrapper::CartesianVelocity*>(p);
  }
  return _impl_.cartesian_;
}
inline ::abb::egm::wrapper::CartesianVelocity* RobotVelocityGoal::mutable_cartesian() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::CartesianVelocity* _msg = _internal_mutable_cartesian();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.RobotVelocityGoal.cartesian)
  return _msg;
}
inline void RobotVelocityGoal::set_allocated_cartesian(::abb::egm::wrapper::CartesianVelocity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cartesian_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.cartesian_ = reinterpret_cast<::abb::egm::wrapper::CartesianVelocity*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.RobotVelocityGoal.cartesian)
}

// -------------------------------------------------------------------

// TrajectoryGoal

// repeated .abb.egm.wrapper.trajectory.PointGoal points = 1;
inline int TrajectoryGoal::_internal_points_size() const {
  return _internal_points().size();
}
inline int TrajectoryGoal::points_size() const {
  return _internal_points_size();
}
inline void TrajectoryGoal::clear_points() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.points_.Clear();
}
inline ::abb::egm::wrapper::trajectory::PointGoal* TrajectoryGoal::mutable_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.TrajectoryGoal.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::abb::egm::wrapper::trajectory::PointGoal>* TrajectoryGoal::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.wrapper.trajectory.TrajectoryGoal.points)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_points();
}
inline const ::abb::egm::wrapper::trajectory::PointGoal& TrajectoryGoal::points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.TrajectoryGoal.points)
  return _internal_points().Get(index);
}
inline ::abb::egm::wrapper::trajectory::PointGoal* TrajectoryGoal::add_points() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::abb::egm::wrapper::trajectory::PointGoal* _add = _internal_mutable_points()->Add();
  // @@protoc_insertion_point(field_add:abb.egm.wrapper.trajectory.TrajectoryGoal.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::abb::egm::wrapper::trajectory::PointGoal>& TrajectoryGoal::points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:abb.egm.wrapper.trajectory.TrajectoryGoal.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::abb::egm::wrapper::trajectory::PointGoal>&
TrajectoryGoal::_internal_points() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::abb::egm::wrapper::trajectory::PointGoal>*
TrajectoryGoal::_internal_mutable_points() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.points_;
}

// -------------------------------------------------------------------

// StaticPositionGoal

// optional .abb.egm.wrapper.trajectory.RobotPositionGoal robot = 1;
inline bool StaticPositionGoal::has_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ != nullptr);
  return value;
}
inline void StaticPositionGoal::clear_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.robot_ != nullptr) _impl_.robot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::trajectory::RobotPositionGoal& StaticPositionGoal::_internal_robot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::trajectory::RobotPositionGoal* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::trajectory::RobotPositionGoal&>(::abb::egm::wrapper::trajectory::_RobotPositionGoal_default_instance_);
}
inline const ::abb::egm::wrapper::trajectory::RobotPositionGoal& StaticPositionGoal::robot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.StaticPositionGoal.robot)
  return _internal_robot();
}
inline void StaticPositionGoal::unsafe_arena_set_allocated_robot(::abb::egm::wrapper::trajectory::RobotPositionGoal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::trajectory::RobotPositionGoal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.StaticPositionGoal.robot)
}
inline ::abb::egm::wrapper::trajectory::RobotPositionGoal* StaticPositionGoal::release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::trajectory::RobotPositionGoal* released = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::trajectory::RobotPositionGoal* StaticPositionGoal::unsafe_arena_release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.StaticPositionGoal.robot)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::trajectory::RobotPositionGoal* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::trajectory::RobotPositionGoal* StaticPositionGoal::_internal_mutable_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::trajectory::RobotPositionGoal>(GetArena());
    _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::trajectory::RobotPositionGoal*>(p);
  }
  return _impl_.robot_;
}
inline ::abb::egm::wrapper::trajectory::RobotPositionGoal* StaticPositionGoal::mutable_robot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::trajectory::RobotPositionGoal* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.StaticPositionGoal.robot)
  return _msg;
}
inline void StaticPositionGoal::set_allocated_robot(::abb::egm::wrapper::trajectory::RobotPositionGoal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::trajectory::RobotPositionGoal*>(_impl_.robot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::trajectory::RobotPositionGoal*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::trajectory::RobotPositionGoal*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.StaticPositionGoal.robot)
}

// optional .abb.egm.wrapper.Joints external = 2;
inline bool StaticPositionGoal::has_external() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::Joints& StaticPositionGoal::_internal_external() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Joints* p = _impl_.external_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Joints&>(::abb::egm::wrapper::_Joints_default_instance_);
}
inline const ::abb::egm::wrapper::Joints& StaticPositionGoal::external() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.StaticPositionGoal.external)
  return _internal_external();
}
inline void StaticPositionGoal::unsafe_arena_set_allocated_external(::abb::egm::wrapper::Joints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.external_);
  }
  _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.StaticPositionGoal.external)
}
inline ::abb::egm::wrapper::Joints* StaticPositionGoal::release_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Joints* released = _impl_.external_;
  _impl_.external_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Joints* StaticPositionGoal::unsafe_arena_release_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.StaticPositionGoal.external)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Joints* temp = _impl_.external_;
  _impl_.external_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Joints* StaticPositionGoal::_internal_mutable_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.external_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArena());
    _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(p);
  }
  return _impl_.external_;
}
inline ::abb::egm::wrapper::Joints* StaticPositionGoal::mutable_external() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Joints* _msg = _internal_mutable_external();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.StaticPositionGoal.external)
  return _msg;
}
inline void StaticPositionGoal::set_allocated_external(::abb::egm::wrapper::Joints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.external_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.StaticPositionGoal.external)
}

// -------------------------------------------------------------------

// StaticVelocityGoal

// optional .abb.egm.wrapper.trajectory.RobotVelocityGoal robot = 1;
inline bool StaticVelocityGoal::has_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ != nullptr);
  return value;
}
inline void StaticVelocityGoal::clear_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.robot_ != nullptr) _impl_.robot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::trajectory::RobotVelocityGoal& StaticVelocityGoal::_internal_robot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::trajectory::RobotVelocityGoal* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::trajectory::RobotVelocityGoal&>(::abb::egm::wrapper::trajectory::_RobotVelocityGoal_default_instance_);
}
inline const ::abb::egm::wrapper::trajectory::RobotVelocityGoal& StaticVelocityGoal::robot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.StaticVelocityGoal.robot)
  return _internal_robot();
}
inline void StaticVelocityGoal::unsafe_arena_set_allocated_robot(::abb::egm::wrapper::trajectory::RobotVelocityGoal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::trajectory::RobotVelocityGoal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.StaticVelocityGoal.robot)
}
inline ::abb::egm::wrapper::trajectory::RobotVelocityGoal* StaticVelocityGoal::release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::trajectory::RobotVelocityGoal* released = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::trajectory::RobotVelocityGoal* StaticVelocityGoal::unsafe_arena_release_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.StaticVelocityGoal.robot)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::trajectory::RobotVelocityGoal* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::trajectory::RobotVelocityGoal* StaticVelocityGoal::_internal_mutable_robot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::trajectory::RobotVelocityGoal>(GetArena());
    _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::trajectory::RobotVelocityGoal*>(p);
  }
  return _impl_.robot_;
}
inline ::abb::egm::wrapper::trajectory::RobotVelocityGoal* StaticVelocityGoal::mutable_robot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::trajectory::RobotVelocityGoal* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.StaticVelocityGoal.robot)
  return _msg;
}
inline void StaticVelocityGoal::set_allocated_robot(::abb::egm::wrapper::trajectory::RobotVelocityGoal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::trajectory::RobotVelocityGoal*>(_impl_.robot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::trajectory::RobotVelocityGoal*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.robot_ = reinterpret_cast<::abb::egm::wrapper::trajectory::RobotVelocityGoal*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.StaticVelocityGoal.robot)
}

// optional .abb.egm.wrapper.Joints external = 2;
inline bool StaticVelocityGoal::has_external() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::Joints& StaticVelocityGoal::_internal_external() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Joints* p = _impl_.external_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Joints&>(::abb::egm::wrapper::_Joints_default_instance_);
}
inline const ::abb::egm::wrapper::Joints& StaticVelocityGoal::external() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.StaticVelocityGoal.external)
  return _internal_external();
}
inline void StaticVelocityGoal::unsafe_arena_set_allocated_external(::abb::egm::wrapper::Joints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.external_);
  }
  _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.StaticVelocityGoal.external)
}
inline ::abb::egm::wrapper::Joints* StaticVelocityGoal::release_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Joints* released = _impl_.external_;
  _impl_.external_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Joints* StaticVelocityGoal::unsafe_arena_release_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.StaticVelocityGoal.external)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Joints* temp = _impl_.external_;
  _impl_.external_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Joints* StaticVelocityGoal::_internal_mutable_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.external_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArena());
    _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(p);
  }
  return _impl_.external_;
}
inline ::abb::egm::wrapper::Joints* StaticVelocityGoal::mutable_external() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Joints* _msg = _internal_mutable_external();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.StaticVelocityGoal.external)
  return _msg;
}
inline void StaticVelocityGoal::set_allocated_external(::abb::egm::wrapper::Joints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.external_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.external_ = reinterpret_cast<::abb::egm::wrapper::Joints*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.StaticVelocityGoal.external)
}

// -------------------------------------------------------------------

// ExecutionProgress

// optional .abb.egm.wrapper.trajectory.ExecutionProgress.State state = 1 [default = UNDEFINED];
inline bool ExecutionProgress::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ExecutionProgress::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::abb::egm::wrapper::trajectory::ExecutionProgress_State ExecutionProgress::state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.ExecutionProgress.state)
  return _internal_state();
}
inline void ExecutionProgress::set_state(::abb::egm::wrapper::trajectory::ExecutionProgress_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.trajectory.ExecutionProgress.state)
}
inline ::abb::egm::wrapper::trajectory::ExecutionProgress_State ExecutionProgress::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::egm::wrapper::trajectory::ExecutionProgress_State>(_impl_.state_);
}
inline void ExecutionProgress::_internal_set_state(::abb::egm::wrapper::trajectory::ExecutionProgress_State value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::egm::wrapper::trajectory::ExecutionProgress_State_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.state_ = value;
}

// optional .abb.egm.wrapper.trajectory.ExecutionProgress.SubState sub_state = 2 [default = NONE];
inline bool ExecutionProgress::has_sub_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ExecutionProgress::clear_sub_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sub_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::abb::egm::wrapper::trajectory::ExecutionProgress_SubState ExecutionProgress::sub_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.ExecutionProgress.sub_state)
  return _internal_sub_state();
}
inline void ExecutionProgress::set_sub_state(::abb::egm::wrapper::trajectory::ExecutionProgress_SubState value) {
  _internal_set_sub_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.trajectory.ExecutionProgress.sub_state)
}
inline ::abb::egm::wrapper::trajectory::ExecutionProgress_SubState ExecutionProgress::_internal_sub_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::abb::egm::wrapper::trajectory::ExecutionProgress_SubState>(_impl_.sub_state_);
}
inline void ExecutionProgress::_internal_set_sub_state(::abb::egm::wrapper::trajectory::ExecutionProgress_SubState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::abb::egm::wrapper::trajectory::ExecutionProgress_SubState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sub_state_ = value;
}

// optional .abb.egm.wrapper.Input inputs = 3;
inline bool ExecutionProgress::has_inputs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inputs_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::Input& ExecutionProgress::_internal_inputs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Input* p = _impl_.inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Input&>(::abb::egm::wrapper::_Input_default_instance_);
}
inline const ::abb::egm::wrapper::Input& ExecutionProgress::inputs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.ExecutionProgress.inputs)
  return _internal_inputs();
}
inline void ExecutionProgress::unsafe_arena_set_allocated_inputs(::abb::egm::wrapper::Input* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inputs_);
  }
  _impl_.inputs_ = reinterpret_cast<::abb::egm::wrapper::Input*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.ExecutionProgress.inputs)
}
inline ::abb::egm::wrapper::Input* ExecutionProgress::release_inputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Input* released = _impl_.inputs_;
  _impl_.inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Input* ExecutionProgress::unsafe_arena_release_inputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.ExecutionProgress.inputs)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Input* temp = _impl_.inputs_;
  _impl_.inputs_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Input* ExecutionProgress::_internal_mutable_inputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Input>(GetArena());
    _impl_.inputs_ = reinterpret_cast<::abb::egm::wrapper::Input*>(p);
  }
  return _impl_.inputs_;
}
inline ::abb::egm::wrapper::Input* ExecutionProgress::mutable_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Input* _msg = _internal_mutable_inputs();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.ExecutionProgress.inputs)
  return _msg;
}
inline void ExecutionProgress::set_allocated_inputs(::abb::egm::wrapper::Input* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inputs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.inputs_ = reinterpret_cast<::abb::egm::wrapper::Input*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.ExecutionProgress.inputs)
}

// optional .abb.egm.wrapper.Output outputs = 4;
inline bool ExecutionProgress::has_outputs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.outputs_ != nullptr);
  return value;
}
inline const ::abb::egm::wrapper::Output& ExecutionProgress::_internal_outputs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::Output* p = _impl_.outputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Output&>(::abb::egm::wrapper::_Output_default_instance_);
}
inline const ::abb::egm::wrapper::Output& ExecutionProgress::outputs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.ExecutionProgress.outputs)
  return _internal_outputs();
}
inline void ExecutionProgress::unsafe_arena_set_allocated_outputs(::abb::egm::wrapper::Output* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.outputs_);
  }
  _impl_.outputs_ = reinterpret_cast<::abb::egm::wrapper::Output*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.ExecutionProgress.outputs)
}
inline ::abb::egm::wrapper::Output* ExecutionProgress::release_outputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Output* released = _impl_.outputs_;
  _impl_.outputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::Output* ExecutionProgress::unsafe_arena_release_outputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.ExecutionProgress.outputs)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Output* temp = _impl_.outputs_;
  _impl_.outputs_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Output* ExecutionProgress::_internal_mutable_outputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.outputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Output>(GetArena());
    _impl_.outputs_ = reinterpret_cast<::abb::egm::wrapper::Output*>(p);
  }
  return _impl_.outputs_;
}
inline ::abb::egm::wrapper::Output* ExecutionProgress::mutable_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::Output* _msg = _internal_mutable_outputs();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.ExecutionProgress.outputs)
  return _msg;
}
inline void ExecutionProgress::set_allocated_outputs(::abb::egm::wrapper::Output* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.outputs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.outputs_ = reinterpret_cast<::abb::egm::wrapper::Output*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.ExecutionProgress.outputs)
}

// optional double time_passed = 5;
inline bool ExecutionProgress::has_time_passed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ExecutionProgress::clear_time_passed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_passed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double ExecutionProgress::time_passed() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.ExecutionProgress.time_passed)
  return _internal_time_passed();
}
inline void ExecutionProgress::set_time_passed(double value) {
  _internal_set_time_passed(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.trajectory.ExecutionProgress.time_passed)
}
inline double ExecutionProgress::_internal_time_passed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_passed_;
}
inline void ExecutionProgress::_internal_set_time_passed(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.time_passed_ = value;
}

// optional bool goal_active = 6;
inline bool ExecutionProgress::has_goal_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void ExecutionProgress::clear_goal_active() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goal_active_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool ExecutionProgress::goal_active() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.ExecutionProgress.goal_active)
  return _internal_goal_active();
}
inline void ExecutionProgress::set_goal_active(bool value) {
  _internal_set_goal_active(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.trajectory.ExecutionProgress.goal_active)
}
inline bool ExecutionProgress::_internal_goal_active() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goal_active_;
}
inline void ExecutionProgress::_internal_set_goal_active(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.goal_active_ = value;
}

// optional .abb.egm.wrapper.trajectory.PointGoal goal = 7;
inline bool ExecutionProgress::has_goal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.goal_ != nullptr);
  return value;
}
inline void ExecutionProgress::clear_goal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.goal_ != nullptr) _impl_.goal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::wrapper::trajectory::PointGoal& ExecutionProgress::_internal_goal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::trajectory::PointGoal* p = _impl_.goal_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::trajectory::PointGoal&>(::abb::egm::wrapper::trajectory::_PointGoal_default_instance_);
}
inline const ::abb::egm::wrapper::trajectory::PointGoal& ExecutionProgress::goal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.ExecutionProgress.goal)
  return _internal_goal();
}
inline void ExecutionProgress::unsafe_arena_set_allocated_goal(::abb::egm::wrapper::trajectory::PointGoal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.goal_);
  }
  _impl_.goal_ = reinterpret_cast<::abb::egm::wrapper::trajectory::PointGoal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.ExecutionProgress.goal)
}
inline ::abb::egm::wrapper::trajectory::PointGoal* ExecutionProgress::release_goal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::trajectory::PointGoal* released = _impl_.goal_;
  _impl_.goal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::trajectory::PointGoal* ExecutionProgress::unsafe_arena_release_goal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.ExecutionProgress.goal)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::trajectory::PointGoal* temp = _impl_.goal_;
  _impl_.goal_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::trajectory::PointGoal* ExecutionProgress::_internal_mutable_goal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.goal_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::trajectory::PointGoal>(GetArena());
    _impl_.goal_ = reinterpret_cast<::abb::egm::wrapper::trajectory::PointGoal*>(p);
  }
  return _impl_.goal_;
}
inline ::abb::egm::wrapper::trajectory::PointGoal* ExecutionProgress::mutable_goal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::trajectory::PointGoal* _msg = _internal_mutable_goal();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.ExecutionProgress.goal)
  return _msg;
}
inline void ExecutionProgress::set_allocated_goal(::abb::egm::wrapper::trajectory::PointGoal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::trajectory::PointGoal*>(_impl_.goal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::trajectory::PointGoal*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.goal_ = reinterpret_cast<::abb::egm::wrapper::trajectory::PointGoal*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.ExecutionProgress.goal)
}

// optional .abb.egm.wrapper.trajectory.TrajectoryGoal active_trajectory = 8;
inline bool ExecutionProgress::has_active_trajectory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.active_trajectory_ != nullptr);
  return value;
}
inline void ExecutionProgress::clear_active_trajectory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.active_trajectory_ != nullptr) _impl_.active_trajectory_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::wrapper::trajectory::TrajectoryGoal& ExecutionProgress::_internal_active_trajectory() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::abb::egm::wrapper::trajectory::TrajectoryGoal* p = _impl_.active_trajectory_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::trajectory::TrajectoryGoal&>(::abb::egm::wrapper::trajectory::_TrajectoryGoal_default_instance_);
}
inline const ::abb::egm::wrapper::trajectory::TrajectoryGoal& ExecutionProgress::active_trajectory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.ExecutionProgress.active_trajectory)
  return _internal_active_trajectory();
}
inline void ExecutionProgress::unsafe_arena_set_allocated_active_trajectory(::abb::egm::wrapper::trajectory::TrajectoryGoal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.active_trajectory_);
  }
  _impl_.active_trajectory_ = reinterpret_cast<::abb::egm::wrapper::trajectory::TrajectoryGoal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.trajectory.ExecutionProgress.active_trajectory)
}
inline ::abb::egm::wrapper::trajectory::TrajectoryGoal* ExecutionProgress::release_active_trajectory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::wrapper::trajectory::TrajectoryGoal* released = _impl_.active_trajectory_;
  _impl_.active_trajectory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::abb::egm::wrapper::trajectory::TrajectoryGoal* ExecutionProgress::unsafe_arena_release_active_trajectory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.trajectory.ExecutionProgress.active_trajectory)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::wrapper::trajectory::TrajectoryGoal* temp = _impl_.active_trajectory_;
  _impl_.active_trajectory_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::trajectory::TrajectoryGoal* ExecutionProgress::_internal_mutable_active_trajectory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.active_trajectory_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::trajectory::TrajectoryGoal>(GetArena());
    _impl_.active_trajectory_ = reinterpret_cast<::abb::egm::wrapper::trajectory::TrajectoryGoal*>(p);
  }
  return _impl_.active_trajectory_;
}
inline ::abb::egm::wrapper::trajectory::TrajectoryGoal* ExecutionProgress::mutable_active_trajectory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::abb::egm::wrapper::trajectory::TrajectoryGoal* _msg = _internal_mutable_active_trajectory();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.trajectory.ExecutionProgress.active_trajectory)
  return _msg;
}
inline void ExecutionProgress::set_allocated_active_trajectory(::abb::egm::wrapper::trajectory::TrajectoryGoal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::abb::egm::wrapper::trajectory::TrajectoryGoal*>(_impl_.active_trajectory_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::abb::egm::wrapper::trajectory::TrajectoryGoal*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.active_trajectory_ = reinterpret_cast<::abb::egm::wrapper::trajectory::TrajectoryGoal*>(value);
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.trajectory.ExecutionProgress.active_trajectory)
}

// optional uint32 pending_trajectories = 9;
inline bool ExecutionProgress::has_pending_trajectories() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void ExecutionProgress::clear_pending_trajectories() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pending_trajectories_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t ExecutionProgress::pending_trajectories() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.trajectory.ExecutionProgress.pending_trajectories)
  return _internal_pending_trajectories();
}
inline void ExecutionProgress::set_pending_trajectories(::uint32_t value) {
  _internal_set_pending_trajectories(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.trajectory.ExecutionProgress.pending_trajectories)
}
inline ::uint32_t ExecutionProgress::_internal_pending_trajectories() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pending_trajectories_;
}
inline void ExecutionProgress::_internal_set_pending_trajectories(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.pending_trajectories_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace trajectory
}  // namespace wrapper
}  // namespace egm
}  // namespace abb


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::abb::egm::wrapper::trajectory::ExecutionProgress_State> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::egm::wrapper::trajectory::ExecutionProgress_State>() {
  return ::abb::egm::wrapper::trajectory::ExecutionProgress_State_descriptor();
}
template <>
struct is_proto_enum<::abb::egm::wrapper::trajectory::ExecutionProgress_SubState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::abb::egm::wrapper::trajectory::ExecutionProgress_SubState>() {
  return ::abb::egm::wrapper::trajectory::ExecutionProgress_SubState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_egm_5fwrapper_5ftrajectory_2eproto_2epb_2eh
